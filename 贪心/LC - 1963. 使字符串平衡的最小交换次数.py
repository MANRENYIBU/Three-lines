# 题目来源：https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/description/?envType=daily-question&envId=2025-03-17

'''
考察平衡字符串的性质。

在平衡字符串的任意一个前缀中, 左括号的数量都大于等于右括号的数量。例如平衡字符串 "[[]][]", 它的前缀有 "[[]", "[[]][" 等, 都满足这一性质。
为什么？
因为对于前缀来说, 每个右括号的左边, 必然有与之匹配的左括号, 但左括号不一定有与之匹配的右括号。

根据这一性质, 从左到右遍历字符串 s, 统计未匹配的左括号的个数 c: 
遇到左括号就把 c 加一, 遇到右括号就把 c 减一。如果任何时刻 c 都不为负数, 那么 s 就是平衡字符串。
(注意题目保证左右括号个数相等, 所以最终 c 一定为 0。)
反之, 如果遍历到右括号, 且此时 c=0, 那么减一后 c 是负数; 
说明右括号比左括号多, 必然存在一个右括号, 没有相匹配的左括号, 无论后面的字符是什么样的, s 都不可能是平衡字符串。例如 s = "[]]["。
这时就需要把这个右括号换走了。和另一个右括号交换是没有意义的(s 不变), 所以一定要和左括号交换。如何交换最优呢？
根据 c 的计算规则, 把左括号视作 +1, 右括号视作 -1。为了让 c 不是负数, 执行 -1 的时刻越晚(越靠后), c 就越不可能变成负数。
所以这个右括号要换到最后面去, 也就是找最右边的左括号交换。

例如 s="][][": 
如果把第一个右括号和第一个左括号交换, 得 "[]][", 不是平衡字符串, 仍需继续交换。
如果把第一个右括号和第二个左括号交换, 得 "[[]]", 是平衡字符串。
'''

# 优化前：模拟交换流程

class Solution:
    def minSwaps(self, s: str) -> int:
        s = list(s)
        ans = c = 0
        j = len(s) - 1
        for b in s:
            if b == '[':
                c += 1
            elif c > 0:
                c -= 1
            else:  # c == 0
                # 找最右边的左括号交换
                while s[j] == ']':
                    j -= 1
                s[j] = ']'  # s[i] = '[' 可以省略
                ans += 1
                c += 1  # s[i] 变成左括号, c 加一
        return ans


# 优化一：不需要真的交换

'''
如果不交换, 继续向后遍历, 若在下标 i 处遇到了（本该被交换的）左括号, 那么在执行了交换的字符串中, [i,n - 1] 中的左括号全部被换成了右括号; 
即此时该字符串已经是平衡的了, 继续遍历不会导致 c<0, 不会继续增大答案, 所以不交换并不会导致计算错误。
因此, 当遍历到右括号且 c=0 时, 只需将 c 和答案（交换次数）加一, 即视作将后面的一个左括号与该右括号交换。

示例 2 的 s="]]][[[", 第一、第三个右括号与后两个左括号交换, 得 "[][[]]"。但实际上我们只是把第一、第三个右括号视作左括号, 没有真的交换; 
所以看上去遍历的是 "[][[[[", 最终 c = 4。
但这并不会导致计算错误, 正如上文所说, 如果遍历到了这些（本该被交换的）左括号, 那么后面 c 不会再变成负数, 我们不会继续增大答案。
'''

class Solution:
    def minSwaps(self, s: str) -> int:
        ans = c = 0
        for b in s:
            if b == '[':
                c += 1
            elif c > 0:
                c -= 1
            else:  # c == 0
                ans += 1
                c += 1  # s[i] 变成左括号, c 加一
        return ans


# 优化二：去掉 ans 变量

class Solution:
    def minSwaps(self, s: str) -> int:
        c = 0
        for b in s:
            if b == '[' or c == 0:
                c += 1
            else:
                c -= 1
        return c // 2
